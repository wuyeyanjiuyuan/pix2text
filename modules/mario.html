<style>
    /* === æ¸¸æˆå®¹å™¨ === */
    #mario-app {
        position: relative;
        width: 100%;
        height: 600px; /* é€‚é…ä¸»é¡µå®¹å™¨é«˜åº¦ */
        background: #000;
        font-family: 'Courier New', Courier, monospace;
        border-radius: 12px;
        overflow: hidden;
        user-select: none;
        box-shadow: 0 10px 30px rgba(0,0,0,0.3);
    }

    /* æ¸¸æˆç”»å¸ƒï¼šå±…ä¸­æ˜¾ç¤ºï¼Œåƒç´ é£æ ¼ */
    #mario-game-canvas {
        display: block;
        width: 100%;
        height: 100%;
        image-rendering: pixelated; /* å…³é”®ï¼šåƒç´ ç”»ä¸æ¨¡ç³Š */
        background: #5c94fc; /* ç»å…¸è“å¤© */
    }

    /* === UI å±‚ === */
    .mario-ui {
        position: absolute; top: 20px; left: 20px; z-index: 10;
        color: white; text-shadow: 2px 2px 0 #000; pointer-events: none;
    }
    .score-board { font-size: 20px; font-weight: bold; margin-bottom: 5px; }
    
    .gesture-hint-box { 
        font-size: 13px; background: rgba(0,0,0,0.6); 
        padding: 10px; border-radius: 8px; border-left: 4px solid #e52521;
        display: flex; flex-direction: column; gap: 5px;
    }

    /* === æ‘„åƒå¤´ç”»ä¸­ç”» === */
    .mario-cam-preview {
        position: absolute; bottom: 20px; right: 20px;
        width: 160px; height: 120px; 
        border: 3px solid #fff; border-radius: 8px; 
        background: #000; overflow: hidden; z-index: 20;
        box-shadow: 0 5px 15px rgba(0,0,0,0.5);
    }
    #mario-video-input { display: none; } /* éšè—åŸå§‹æµ */
    #mario-hand-canvas { width: 100%; height: 100%; transform: scaleX(-1); }

    /* === å¼€å§‹/ç»“æŸ é®ç½© === */
    #mario-overlay {
        position: absolute; top: 0; left: 0; width: 100%; height: 100%;
        background: rgba(0,0,0,0.85); z-index: 50;
        display: flex; flex-direction: column;
        justify-content: center; align-items: center;
        color: #fff; text-align: center;
        backdrop-filter: blur(5px);
    }
    .mario-title { 
        font-size: 40px; color: #ffce00; 
        text-shadow: 4px 4px 0 #d32f2f; margin-bottom: 20px; letter-spacing: 2px;
    }
    .mario-btn {
        padding: 12px 30px; font-size: 20px; background: #e52521; color: white;
        border: 3px solid #fff; cursor: pointer; font-family: inherit; font-weight: bold;
        transition: transform 0.1s; border-radius: 4px;
    }
    .mario-btn:hover { background: #ff4444; }
    .mario-btn:active { transform: scale(0.95); }
    .hidden { display: none !important; }
</style>

<div id="mario-app">
    <div class="mario-ui">
        <div class="score-board">WORLD 1-1 <span style="margin-left:20px">COINS: <span id="mario-coin-count">0</span></span></div>
        <div class="gesture-hint-box">
            <div>âœ‹ <b>æ‰‹æŒå€¾æ–œ</b> âœ å·¦å³è·‘</div>
            <div>ğŸ‘Œ <b>é£ŸæŒ‡æ‹‡æŒ‡æåˆ</b> âœ è·³è·ƒ</div>
        </div>
    </div>

    <canvas id="mario-game-canvas"></canvas>

    <div class="mario-cam-preview">
        <canvas id="mario-hand-canvas"></canvas>
    </div>
    
    <div id="mario-overlay">
        <div class="mario-title">GESTURE MARIO</div>
        <div style="margin-bottom: 30px; line-height: 1.6; color: #ccc; font-size: 14px;">
            è¯·å¼€å¯æ‘„åƒå¤´å¹¶ç«™åœ¨å±å¹•å‰<br>
            éœ²å‡ºå•æ‰‹è¿›è¡Œæ§åˆ¶
        </div>
        <button class="mario-btn" id="btn-start-mario">START GAME</button>
    </div>

    <video id="mario-video-input" playsinline></video>
</div>

<script src="js/camera_utils.js"></script>
<script src="js/control_utils.js"></script>
<script src="js/drawing_utils.js"></script>
<script src="js/hands.js"></script>

<script>
// ä½¿ç”¨ IIFE (ç«‹å³æ‰§è¡Œå‡½æ•°) åŒ…è£¹ï¼Œé˜²æ­¢å˜é‡æ±¡æŸ“å…¨å±€ window
(function() {
    // ================= é…ç½®å¸¸é‡ =================
    const CANVAS_WIDTH = 800;
    const CANVAS_HEIGHT = 600;
    const TILE_SIZE = 40;

    // DOM å…ƒç´ å¼•ç”¨
    const appContainer = document.getElementById('mario-app');
    const canvas = document.getElementById('mario-game-canvas');
    const ctx = canvas.getContext('2d');
    const handCanvas = document.getElementById('mario-hand-canvas');
    const handCtx = handCanvas.getContext('2d');
    const videoElement = document.getElementById('mario-video-input');
    const overlay = document.getElementById('mario-overlay');
    const btnStart = document.getElementById('btn-start-mario');
    const coinUi = document.getElementById('mario-coin-count');

    // æ¸¸æˆçŠ¶æ€
    const GAME = {
        running: false,
        gameOver: false,
        coins: 0,
        cameraX: 0,
        gravity: 0.6,
        friction: 0.85,
        frame: 0
    };

    // è¾“å…¥çŠ¶æ€ (ç”±æ‰‹åŠ¿æ›´æ–°)
    const INPUT = {
        left: false,
        right: false,
        jump: false,
        jumpPressed: false
    };

    // é€‚é… Canvas å°ºå¯¸
    function resizeCanvas() {
        if (!appContainer) return;
        // å¼ºåˆ¶ç”»å¸ƒå†…éƒ¨åˆ†è¾¨ç‡
        canvas.width = CANVAS_WIDTH;
        canvas.height = CANVAS_HEIGHT;
    }
    // åˆå§‹åŒ–è°ƒç”¨ä¸€æ¬¡
    resizeCanvas();

    // ================= å®ä½“ç±»å®šä¹‰ =================

    class Player {
        constructor() {
            this.w = 30; this.h = 30;
            this.x = 100; this.y = 100;
            this.vx = 0; this.vy = 0;
            this.speed = 6;
            this.jumpForce = -14;
            this.grounded = false;
            this.dead = false;
            this.facingRight = true;
        }

        update() {
            if (this.dead) { this.y += 8; return; }

            // è¾“å…¥å“åº”
            if (INPUT.left) {
                if (this.vx > -this.speed) this.vx--;
                this.facingRight = false;
            }
            if (INPUT.right) {
                if (this.vx < this.speed) this.vx++;
                this.facingRight = true;
            }
            this.vx *= GAME.friction; // æ‘©æ“¦åŠ›

            // è·³è·ƒé€»è¾‘
            if (INPUT.jump && !INPUT.jumpPressed && this.grounded) {
                this.vy = this.jumpForce;
                this.grounded = false;
                INPUT.jumpPressed = true;
            }
            if (!INPUT.jump) INPUT.jumpPressed = false;

            // ç‰©ç†ç§»åŠ¨
            this.x += this.vx;
            checkCollision(this, 'x'); // Xè½´ç¢°æ’
            
            this.vy += GAME.gravity;
            this.y += this.vy;
            this.grounded = false;
            checkCollision(this, 'y'); // Yè½´ç¢°æ’

            // æ‰è½æ­»äº¡
            if (this.y > CANVAS_HEIGHT) die();
        }

        draw(ctx, camX) {
            let dx = Math.floor(this.x - camX);
            let dy = Math.floor(this.y);
            
            // èº«ä½“
            ctx.fillStyle = '#e52521'; // çº¢
            ctx.fillRect(dx, dy, this.w, this.h);
            
            // èƒŒå¸¦è£¤
            ctx.fillStyle = '#2233cc'; // è“
            ctx.fillRect(dx + 5, dy + 15, 20, 15);

            // è„¸æ–¹å‘
            ctx.fillStyle = '#ffcc99'; // è‚¤è‰²
            let faceX = this.facingRight ? dx + 15 : dx;
            ctx.fillRect(faceX, dy + 5, 15, 10);
        }
    }

    class Goomba { // æ•Œäºº
        constructor(x, y) {
            this.x = x; this.y = y;
            this.w = 30; this.h = 30;
            this.vx = -1.5; this.vy = 0;
            this.dead = false;
            this.deadTimer = 0;
        }
        update() {
            if (this.dead) { this.deadTimer++; return; }
            this.vy += GAME.gravity;
            this.x += this.vx;
            checkCollision(this, 'x', true); // æ’å¢™åå¼¹
            this.y += this.vy;
            checkCollision(this, 'y');
        }
        draw(ctx, camX) {
            if (this.deadTimer > 30) return;
            let dx = Math.floor(this.x - camX);
            let dy = Math.floor(this.y);
            
            if (this.dead) {
                ctx.fillStyle = '#8b4513';
                ctx.fillRect(dx, dy + 15, 30, 15); // è¸©æ‰
            } else {
                ctx.fillStyle = '#8b4513'; // æ£•è‰²èº«ä½“
                ctx.beginPath();
                ctx.moveTo(dx+5, dy+30); ctx.lineTo(dx+25, dy+30);
                ctx.lineTo(dx+30, dy+10); ctx.lineTo(dx+15, dy); ctx.lineTo(dx, dy+10);
                ctx.fill();
                // çœ¼ç›
                ctx.fillStyle = 'white';
                ctx.fillRect(dx+6, dy+10, 6, 6); ctx.fillRect(dx+18, dy+10, 6, 6);
                ctx.fillStyle = 'black';
                ctx.fillRect(dx+8, dy+12, 2, 2); ctx.fillRect(dx+20, dy+12, 2, 2);
            }
        }
    }

    class Coin {
        constructor(x, y) {
            this.x = x; this.y = y; this.w = 20; this.h = 28;
            this.collected = false;
        }
        update() {
            if (this.collected) return;
            // æ£€æµ‹ç¢°æ’
            if (rectIntersect(player.x, player.y, player.w, player.h, this.x, this.y, this.w, this.h)) {
                this.collected = true;
                GAME.coins++;
                coinUi.innerText = GAME.coins;
            }
        }
        draw(ctx, camX) {
            if (this.collected) return;
            let offset = Math.sin(GAME.frame * 0.1) * 3;
            let dx = Math.floor(this.x - camX);
            let dy = Math.floor(this.y + offset);
            ctx.fillStyle = '#ffd700';
            ctx.beginPath(); ctx.ellipse(dx+10, dy+14, 8, 12, 0, 0, Math.PI*2); ctx.fill();
        }
    }

    // ================= åœ°å›¾ç³»ç»Ÿ =================
    // 1=åœ°é¢, 2=ç –, 3=é‡‘å¸ç –, g=æ•Œäºº
    const LEVEL_MAP = [
        "                                                                                ",
        "                                                                                ",
        "                                                                                ",
        "                                                                                ",
        "      3                                                                         ",
        "               222                                                              ",
        "                                  3 3                                    2      ",
        "          222            222     2   2                                  22      ",
        "                       22       2     2                                222      ",
        "     g               g           2   2          g                     2222      ",
        "1111111111111111111111111111111111   111111111111111111111  11111111111111111111",
        "1111111111111111111111111111111111   111111111111111111111  11111111111111111111"
    ];

    let player;
    let blocks = [];
    let enemies = [];
    let coins = [];

    function initLevel() {
        blocks = []; enemies = []; coins = [];
        
        for (let r = 0; r < LEVEL_MAP.length; r++) {
            for (let c = 0; c < LEVEL_MAP[r].length; c++) {
                let char = LEVEL_MAP[r][c];
                let x = c * TILE_SIZE;
                let y = r * TILE_SIZE;
                
                if (char === '1') blocks.push({x, y, w: TILE_SIZE, h: TILE_SIZE, type: 'ground'});
                else if (char === '2') blocks.push({x, y, w: TILE_SIZE, h: TILE_SIZE, type: 'brick'});
                else if (char === '3') {
                    blocks.push({x, y, w: TILE_SIZE, h: TILE_SIZE, type: 'brick'});
                    coins.push(new Coin(x+10, y-40));
                } else if (char === 'g') {
                    enemies.push(new Goomba(x, y));
                }
            }
        }
        player = new Player();
        GAME.coins = 0;
        coinUi.innerText = "0";
        GAME.cameraX = 0;
    }

    // ================= ç‰©ç†å¼•æ“ =================
    function rectIntersect(x1, y1, w1, h1, x2, y2, w2, h2) {
        return x2 < x1 + w1 && x2 + w2 > x1 && y2 < y1 + h1 && y2 + h2 > y1;
    }

    function checkCollision(obj, axis, bounce = false) {
        for (let b of blocks) {
            if (rectIntersect(obj.x, obj.y, obj.w, obj.h, b.x, b.y, b.w, b.h)) {
                if (axis === 'x') {
                    if (obj.vx > 0) { obj.x = b.x - obj.w; if(bounce) obj.vx = -obj.vx; else obj.vx = 0; }
                    else if (obj.vx < 0) { obj.x = b.x + b.w; if(bounce) obj.vx = -obj.vx; else obj.vx = 0; }
                } else {
                    if (obj.vy > 0) { obj.y = b.y - obj.h; obj.vy = 0; obj.grounded = true; }
                    else if (obj.vy < 0) { obj.y = b.y + b.h; obj.vy = 0; }
                }
            }
        }
    }

    function checkEnemyCollision() {
        for (let e of enemies) {
            if (e.dead) continue;
            if (rectIntersect(player.x, player.y, player.w, player.h, e.x, e.y, e.w, e.h)) {
                // åˆ¤å®šï¼šä¸‹è½æ—¶è¸©ä¸­
                if (player.vy > 0 && player.y + player.h < e.y + e.h / 1.5) {
                    e.dead = true;
                    player.vy = -8; // è¸©æ€ªå¼¹è·³
                    GAME.coins += 10;
                    coinUi.innerText = GAME.coins;
                } else {
                    die();
                }
            }
        }
    }

    function die() {
        if (player.dead) return;
        player.dead = true;
        player.vy = -12; // æ­»äº¡å¼¹èµ·
        setTimeout(() => {
            GAME.gameOver = true;
            GAME.running = false;
            // æ˜¾ç¤º Game Over
            overlay.classList.remove('hidden');
            document.querySelector('.mario-title').innerText = "GAME OVER";
            document.querySelector('.mario-title').style.color = "red";
            btnStart.innerText = "TRY AGAIN";
        }, 1500);
    }

    // ================= æ¸²æŸ“å¾ªç¯ =================
    function gameLoop() {
        // â˜… å®‰å…¨æ£€æŸ¥ï¼šå¦‚æœæ¨¡å—è¢«å¸è½½(DOMä¸å­˜åœ¨)ï¼Œåœæ­¢å¾ªç¯ â˜…
        if (!document.getElementById('mario-app')) return;

        if (GAME.running) {
            requestAnimationFrame(gameLoop);
        } else if (player && player.dead) {
            // æ­»äº¡åŠ¨ç”»ç»§ç»­æ’­ä¸€ä¼š
            requestAnimationFrame(gameLoop);
        }

        GAME.frame++;
        
        // 1. é€»è¾‘æ›´æ–°
        if (!GAME.gameOver) {
            player.update();
            enemies.forEach(e => e.update());
            coins.forEach(c => c.update());
            checkEnemyCollision();
            
            // ç›¸æœºè·Ÿéš (ç©å®¶åœ¨å±å¹•å·¦ä¾§ 1/3 å¤„)
            let targetCamX = player.x - 250;
            targetCamX = Math.max(0, targetCamX); // ä¸å°äº0
            GAME.cameraX += (targetCamX - GAME.cameraX) * 0.1; // å¹³æ»‘ç§»åŠ¨
        }

        // 2. ç»˜åˆ¶
        ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
        
        // èƒŒæ™¯ (éšç›¸æœºç§»åŠ¨äº§ç”Ÿè§†å·®æ•ˆæœï¼Œè¿™é‡Œç®€åŒ–ä¸ºå›ºå®š)
        ctx.fillStyle = '#5c94fc'; // å¤©ç©ºè“
        ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
        
        // åœ°é¢è£…é¥° (äº‘)
        ctx.fillStyle = 'rgba(255,255,255,0.3)';
        ctx.fillRect(100 - GAME.cameraX * 0.5, 100, 100, 30);
        ctx.fillRect(500 - GAME.cameraX * 0.5, 50, 150, 40);

        // åœºæ™¯ç‰©ä½“ (è§†é”¥å‰”é™¤ï¼šåªç”»å±å¹•å†…çš„)
        blocks.forEach(b => {
            if (b.x - GAME.cameraX > -50 && b.x - GAME.cameraX < CANVAS_WIDTH) {
                let dx = Math.floor(b.x - GAME.cameraX);
                let dy = Math.floor(b.y);
                if (b.type === 'ground') {
                    ctx.fillStyle = '#009900';
                    ctx.fillRect(dx, dy, b.w, b.h);
                    ctx.fillStyle = '#007700'; // ç»†èŠ‚çº¹ç†
                    ctx.fillRect(dx, dy, b.w, 4);
                } else {
                    ctx.fillStyle = '#b74b16';
                    ctx.fillRect(dx, dy, b.w, b.h);
                    ctx.strokeStyle = '#000';
                    ctx.strokeRect(dx, dy, b.w, b.h);
                }
            }
        });

        coins.forEach(c => c.draw(ctx, GAME.cameraX));
        enemies.forEach(e => e.draw(ctx, GAME.cameraX));
        player.draw(ctx, GAME.cameraX);
    }

    // å¯åŠ¨é€»è¾‘
    btnStart.onclick = () => {
        overlay.classList.add('hidden');
        initLevel();
        GAME.running = true;
        GAME.frame = 0;
        gameLoop();
    };

    // ================= æ‰‹åŠ¿è¯†åˆ« (æ ¸å¿ƒ) =================
    
    // åˆå§‹åŒ– MediaPipe Hands
    const hands = new Hands({locateFile: (file) => {
        return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
    }});
    hands.setOptions({
        maxNumHands: 1,
        modelComplexity: 1,
        minDetectionConfidence: 0.5,
        minTrackingConfidence: 0.5
    });

    hands.onResults(onResults);

    // æ‘„åƒå¤´å·¥å…·
    const cameraUtils = new Camera(videoElement, {
        onFrame: async () => { 
            // â˜… å®‰å…¨æ£€æŸ¥ï¼šå¦‚æœæ¨¡å—è¢«å¸è½½ï¼Œåœæ­¢å‘é€å¸§ â˜…
            if (!document.getElementById('mario-app')) {
                cameraUtils.stop(); 
                return;
            }
            await hands.send({image: videoElement}); 
        },
        width: 320, height: 240
    });
    cameraUtils.start();

    // æ‰‹åŠ¿å›è°ƒ
    function onResults(results) {
        if (!document.getElementById('mario-app')) return;

        handCtx.save();
        handCtx.clearRect(0, 0, handCanvas.width, handCanvas.height);
        
        // ç»˜åˆ¶æ‘„åƒå¤´åŸå›¾
        handCtx.drawImage(results.image, 0, 0, handCanvas.width, handCanvas.height);

        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
            const landmarks = results.multiHandLandmarks[0];
            
            // ç»˜åˆ¶éª¨æ¶
            drawConnectors(handCtx, landmarks, HAND_CONNECTIONS, {color: '#00FF00', lineWidth: 2});
            drawLandmarks(handCtx, landmarks, {color: '#FF0000', lineWidth: 1, radius: 2});

            // --- æ ¸å¿ƒæ§åˆ¶ç®—æ³• ---
            
            // 1. ç§»åŠ¨æ§åˆ¶ (Tilt): æ¯”è¾ƒ [0]æ‰‹è…• å’Œ [9]ä¸­æŒ‡æ ¹ çš„Xåæ ‡
            // é•œåƒåï¼šæ‰‹å‘å³æ­ª -> [9].x < [0].x -> è®¤ä¸ºæ˜¯ Left (å› ä¸ºé•œåƒ)
            // å®é™…ä¸Šä¸ºäº†ç›´è§‚ï¼šæ‰‹å‘é‚£è¾¹æ­ªï¼Œäººå°±å¾€é‚£è¾¹è·‘
            const wrist = landmarks[0];
            const middleBase = landmarks[9];
            const tiltX = middleBase.x - wrist.x; 
            const TILT_THRESHOLD = 0.04; // çµæ•åº¦é˜ˆå€¼

            // ç»˜åˆ¶ä¸­è½´è¾…åŠ©çº¿
            handCtx.strokeStyle = "yellow";
            handCtx.beginPath();
            handCtx.moveTo(wrist.x * handCanvas.width, wrist.y * handCanvas.height);
            handCtx.lineTo(wrist.x * handCanvas.width, (wrist.y - 0.2) * handCanvas.height);
            handCtx.stroke();

            if (tiltX < -TILT_THRESHOLD) {
                // å±å¹•ä¸Šçœ‹èµ·æ¥æ˜¯å‘å³æ­ª (é•œåƒå) -> å¾€å³è·‘
                INPUT.right = true; 
                INPUT.left = false;
                drawHint(">> RIGHT", handCanvas.width - 60);
            } else if (tiltX > TILT_THRESHOLD) {
                // å±å¹•ä¸Šçœ‹èµ·æ¥æ˜¯å‘å·¦æ­ª -> å¾€å·¦è·‘
                INPUT.left = true;
                INPUT.right = false;
                drawHint("LEFT <<", 10);
            } else {
                INPUT.left = false;
                INPUT.right = false;
            }

            // 2. è·³è·ƒæ§åˆ¶ (Pinch): [4]æ‹‡æŒ‡å°– å’Œ [8]é£ŸæŒ‡å°– çš„è·ç¦»
            const thumb = landmarks[4];
            const index = landmarks[8];
            const dist = Math.hypot(thumb.x - index.x, thumb.y - index.y);
            
            if (dist < 0.05) { // æåˆé˜ˆå€¼
                INPUT.jump = true;
                handCtx.fillStyle = "cyan";
                handCtx.font = "bold 24px Arial";
                handCtx.fillText("JUMP!", handCanvas.width/2 - 30, handCanvas.height - 20);
                
                // ç”»ä¸ªåœˆæç¤º
                handCtx.strokeStyle = "cyan";
                handCtx.lineWidth = 3;
                handCtx.beginPath();
                handCtx.arc(thumb.x * handCanvas.width, thumb.y * handCanvas.height, 20, 0, Math.PI*2);
                handCtx.stroke();
            } else {
                INPUT.jump = false;
            }

        } else {
            // æ²¡æ‰‹æ—¶åœæ­¢è¾“å…¥
            INPUT.left = false; INPUT.right = false; INPUT.jump = false;
        }
        handCtx.restore();
    }

    function drawHint(text, x) {
        handCtx.fillStyle = "yellow";
        handCtx.font = "bold 16px Arial";
        handCtx.fillText(text, x, 50);
    }

})();
</script>