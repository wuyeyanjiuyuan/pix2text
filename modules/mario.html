<style>
    /* === 容器布局 === */
    #mario-wrapper {
        position: relative;
        width: 100%;
        height: 600px;
        background: #000;
        border-radius: 12px;
        overflow: hidden;
        display: flex;
        justify-content: center;
        align-items: center;
    }

    #game-iframe {
        width: 100%;
        height: 100%;
        border: none;
        outline: none;
        display: block;
    }

    /* === UI 层 === */
    .overlay-ui {
        position: absolute; top: 0; left: 0; width: 100%; height: 100%;
        pointer-events: none;
        z-index: 10;
    }

    /* 摄像头画中画 */
    .cam-box {
        position: absolute; bottom: 20px; right: 20px;
        width: 160px; height: 120px;
        border: 3px solid rgba(255,255,255,0.5);
        border-radius: 8px; background: #000;
        overflow: hidden;
        transform: scaleX(-1);
        z-index: 20;
    }
    #input-video { display: none; }
    #debug-canvas { width: 100%; height: 100%; }

    /* 调试面板 */
    .debug-console {
        position: absolute; top: 10px; left: 10px;
        background: rgba(0, 0, 0, 0.8);
        padding: 8px; border-radius: 4px;
        color: lime; font-family: monospace; font-size: 12px;
        width: 200px;
        pointer-events: none;
    }

    /* 遮罩 */
    #loading-mask {
        position: absolute; top: 0; left: 0; width: 100%; height: 100%;
        background: rgba(0,0,0,0.9); color: #fff; z-index: 50;
        display: flex; flex-direction: column;
        justify-content: center; align-items: center;
        backdrop-filter: blur(5px);
        pointer-events: auto; /* 遮罩层需要响应点击 */
    }
    .btn-load {
        margin-top: 20px; padding: 12px 30px;
        background: #e52521; color: white; border: 2px solid white;
        font-size: 18px; cursor: pointer; border-radius: 30px;
        font-weight: bold;
    }
    .btn-load:hover { background: #ff4444; transform: scale(1.05); }
</style>

<div id="mario-wrapper">
    <div id="loading-mask">
        <h1 style="color:#ffce00; margin-bottom:10px;">GESTURE CONTROLLER V2</h1>
        <p style="color:#ccc; font-size:14px;">强力注入模式 - 适配 FullScreenMario</p>
        <button class="btn-load" id="btn-inject-game">启动并聚焦游戏</button>
    </div>

    <div class="overlay-ui">
        <div class="debug-console">
            <div>STATUS: <span id="dbg-status" style="color:white">Waiting...</span></div>
            <div style="margin-top:5px; border-top:1px solid #555; padding-top:5px;">
                KEY SENT: <span id="dbg-key" style="color:yellow">-</span>
            </div>
        </div>
        <div class="cam-box">
            <canvas id="debug-canvas"></canvas>
        </div>
    </div>

    <iframe id="game-iframe" src="about:blank" allow="autoplay; fullscreen; clipboard-read; clipboard-write"></iframe>
    
    <video id="input-video" playsinline></video>
</div>

<script src="js/camera_utils.js"></script>
<script src="js/control_utils.js"></script>
<script src="js/drawing_utils.js"></script>
<script src="js/hands.js"></script>

<script>
(function() {
    // ================= 配置 =================
    // 你的游戏路径，请确保正确
    const GAME_URL = "./modules/FullScreenMario/index.html"; 

    // 动作映射表 (Shotgun Approach: 每个动作触发一组可能的键)
    const ACTION_MAP = {
        'left':  [ { code: 'ArrowLeft', keyCode: 37 }, { code: 'KeyA', keyCode: 65 } ],
        'right': [ { code: 'ArrowRight', keyCode: 39 }, { code: 'KeyD', keyCode: 68 } ],
        // Run/Fire: 同时发送 Shift 和 Ctrl
        'run':   [ { code: 'ShiftLeft', keyCode: 16 }, { code: 'ControlLeft', keyCode: 17 } ],
        // Jump: 同时发送 Up 和 Space
        'jump':  [ { code: 'ArrowUp', keyCode: 38 }, { code: 'Space', keyCode: 32 } ]
    };

    // ================= 状态管理 =================
    const elements = {
        wrapper: document.getElementById('mario-wrapper'),
        iframe: document.getElementById('game-iframe'),
        video: document.getElementById('input-video'),
        canvas: document.getElementById('debug-canvas'),
        ctx: document.getElementById('debug-canvas').getContext('2d'),
        status: document.getElementById('dbg-status'),
        keyLog: document.getElementById('dbg-key')
    };

    const keyState = { left: false, right: false, run: false, jump: false };

    // ================= ★★★ 核弹级按键注入 ★★★ =================
    function simulateKey(windowObj, type, keyConfig) {
        // 创建基础事件
        const eventInit = {
            bubbles: true,
            cancelable: true,
            view: windowObj,
            key: keyConfig.code,
            code: keyConfig.code,
            location: 0,
            repeat: false
        };

        const evt = new KeyboardEvent(type, eventInit);

        // ★★★ 核心黑客技术：强制覆盖 keyCode 和 which ★★★
        // 现代浏览器 new KeyboardEvent 产生的 keyCode 默认为 0，老游戏不认
        // 我们用 Object.defineProperty 强行写入只读属性
        Object.defineProperty(evt, 'keyCode', { get: () => keyConfig.keyCode });
        Object.defineProperty(evt, 'which', { get: () => keyConfig.keyCode });
        Object.defineProperty(evt, 'charCode', { get: () => 0 });

        // ★★★ 核心黑客技术：全覆盖广播 ★★★
        // 游戏可能监听 window, document, body 或 canvas，我们全部发一遍
        const targets = [
            windowObj,
            windowObj.document,
            windowObj.document.body
        ];
        
        // 尝试找到 canvas 并发送
        const canvasList = windowObj.document.getElementsByTagName('canvas');
        if (canvasList.length > 0) targets.push(canvasList[0]);

        targets.forEach(t => {
            if(t) t.dispatchEvent(evt);
        });
    }

    function triggerAction(actionName, isActive) {
        // 状态防抖：如果状态没变，就不发 (除了 Run 这种可能需要一直按着的，但在 keydown 逻辑里只需发一次)
        if (keyState[actionName] === isActive) return;
        keyState[actionName] = isActive;

        const gameWin = elements.iframe.contentWindow;
        if (!gameWin) return;

        // 确保 iframe 拥有焦点，否则事件可能无效
        if(isActive) {
            elements.iframe.focus();
            gameWin.focus();
        }

        const type = isActive ? 'keydown' : 'keyup';
        const keyConfigs = ACTION_MAP[actionName];

        // 视觉反馈
        if (isActive) {
            elements.keyLog.innerText = actionName.toUpperCase();
            elements.keyLog.style.color = '#00ff00';
        } else {
            elements.keyLog.style.color = '#555';
        }

        // 遍历该动作下的所有备选键 (例如 Jump -> 发送 Up 和 Space)
        keyConfigs.forEach(config => {
            simulateKey(gameWin, type, config);
        });
    }

    // ================= 手势识别 =================
    
    function onResults(results) {
        if (!document.getElementById('mario-wrapper')) return;

        const ctx = elements.ctx;
        const w = elements.canvas.width;
        const h = elements.canvas.height;

        ctx.save();
        ctx.clearRect(0, 0, w, h);
        ctx.drawImage(results.image, 0, 0, w, h);

        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
            const lm = results.multiHandLandmarks[0];
            drawConnectors(ctx, lm, HAND_CONNECTIONS, {color: '#00FF00', lineWidth: 2});
            drawLandmarks(ctx, lm, {color: '#FF0000', lineWidth: 1, radius: 2});

            // 1. 移动 (手腕 vs 中指根 X差值)
            const wrist = lm[0];
            const mid = lm[9];
            const tilt = mid.x - wrist.x;
            const THRES = 0.04;

            if (tilt < -THRES) {
                triggerAction('right', true);
                triggerAction('left', false);
            } else if (tilt > THRES) {
                triggerAction('left', true);
                triggerAction('right', false);
            } else {
                triggerAction('left', false);
                triggerAction('right', false);
            }

            // 2. 加速 (握拳检测: 指尖 y > 指根 y)
            // y向下为正，指尖弯曲到底部，y会变大
            const isFist = lm[8].y > lm[5].y && lm[12].y > lm[9].y && lm[16].y > lm[13].y;
            triggerAction('run', isFist);

            // 3. 跳跃 (拇指食指距离)
            const dJump = Math.hypot(lm[4].x - lm[8].x, lm[4].y - lm[8].y);
            triggerAction('jump', dJump < 0.05);

            // 状态文字更新
            elements.status.innerText = "Tracking Active";
            elements.status.style.color = "lime";

        } else {
            // 没手时松开所有键
            triggerAction('left', false);
            triggerAction('right', false);
            triggerAction('run', false);
            triggerAction('jump', false);
            elements.status.innerText = "No Hand Detected";
            elements.status.style.color = "red";
        }
        ctx.restore();
    }

    // ================= 初始化 =================
    
    document.getElementById('btn-inject-game').onclick = () => {
        document.getElementById('loading-mask').style.display = 'none';
        elements.iframe.src = GAME_URL;

        // 监听加载，注入完成后自动点击一下以激活音频
        elements.iframe.onload = () => {
            console.log("Game Loaded. Focusing...");
            elements.iframe.focus();
            elements.iframe.contentWindow.focus();
        };

        const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
        hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 1,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });
        hands.onResults(onResults);

        const cam = new Camera(elements.video, {
            onFrame: async () => { 
                if(!document.getElementById('mario-wrapper')) return;
                await hands.send({image: elements.video}); 
            },
            width: 320, height: 240
        });
        cam.start();
    };

})();
</script>