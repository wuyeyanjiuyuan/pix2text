<style>
    /* === æ¸¸æˆå®¹å™¨ === */
    #drone-container {
        position: relative; width: 100%; height: 600px;
        background: #111; 
        border-radius: 12px; overflow: hidden;
        /* å»é™¤é˜´å½±ï¼Œæ”¹ä¸ºæç»†è¾¹æ¡†èå…¥èƒŒæ™¯ */
        border: 1px solid #333; 
        font-family: 'Courier New', Courier, monospace;
        user-select: none;
    }
    /* æ¸¸æˆç”»å¸ƒ */
    #game-canvas { width: 100%; height: 100%; display: block; position: absolute; z-index: 1; }
    
    /* === UI è¦†ç›–å±‚ === */
    .ui-layer {
        position: absolute; top: 0; left: 0; width: 100%; height: 100%;
        z-index: 10; pointer-events: none; /* é¼ æ ‡ç©¿é€ */
        display: flex; flex-direction: column;
        text-shadow: 2px 2px 0px #000;
    }
    
    /* çŠ¶æ€èƒ¶å›Š (æ˜¾ç¤ºåŠ è½½è¿›åº¦) */
    .status-pill {
        position: absolute; top: 20px; left: 20px;
        display: inline-block; padding: 8px 16px;
        background: rgba(0, 100, 255, 0.3); 
        border: 1px solid rgba(100, 200, 255, 0.5);
        border-radius: 30px; backdrop-filter: blur(5px);
        font-size: 14px; color: #00ffff;
        pointer-events: auto;
    }

    /* èœå•é¡¹ */
    .menu-item {
        background: rgba(0,0,0,0.7); color: #fff;
        padding: 15px 30px; margin: 10px; border: 2px solid #555;
        font-size: 24px; font-weight: bold; width: 300px; text-align: center;
        transform: skewX(-10deg); transition: all 0.2s;
        opacity: 0.8;
    }
    .menu-item.active {
        background: #ffcc00; color: #000; border-color: #fff;
        opacity: 1; transform: skewX(-10deg) scale(1.1);
        box-shadow: 0 0 15px #ffcc00;
    }

    /* ç•Œé¢å®¹å™¨ */
    #screen-start, #screen-shop, #screen-upgrade, #screen-gameover {
        position: absolute; width: 100%; height: 100%;
        background: rgba(0,0,0,0.85);
        display: flex; flex-direction: column;
        align-items: center; justify-content: center;
        transition: opacity 0.3s;
        pointer-events: auto; /* å…è®¸ç‚¹å‡» */
    }
    .hidden { opacity: 0; pointer-events: none !important; display: none !important; }

    h1.game-title {
        font-size: 60px; color: #00ddee; 
        text-transform: uppercase; letter-spacing: 5px; margin-bottom: 50px;
        text-shadow: 4px 4px 0 #ff00de;
    }

    /* åˆ—è¡¨ */
    .grid-panel {
        display: grid; grid-template-columns: 1fr 1fr; gap: 20px;
        max-width: 800px; max-height: 400px; overflow-y: auto; padding: 20px;
    }
    .shop-card {
        background: #222; border: 2px solid #444; padding: 15px;
        display: flex; flex-direction: column; align-items: center;
        color: #ddd; font-size: 14px;
    }
    .shop-card.owned { border-color: #00ff00; color: #88ff88; }
    
    /* HUD */
    #hud-layer {
        position: absolute; top: 0; left: 0; width: 100%; padding: 20px 80px; /* é¿å¼€å·¦ä¸Šè§’çŠ¶æ€æ¡ */
        display: flex; justify-content: space-between;
        font-size: 20px; color: #fff; font-weight: bold;
    }
    #pause-overlay {
        position: absolute; top:0; left:0; width:100%; height:100%;
        background: rgba(0,0,0,0.7); color: yellow;
        display: flex; align-items: center; justify-content: center;
        font-size: 30px; letter-spacing: 2px;
        backdrop-filter: blur(5px);
    }

    /* === æ‘„åƒå¤´å°çª— (ä¿®å¤å±‚çº§) === */
    .cam-box {
        position: absolute; bottom: 20px; right: 20px;
        width: 120px; height: 90px; border-radius: 8px; overflow: hidden;
        border: 2px solid rgba(255,255,255,0.5); 
        z-index: 999; /* â˜… ç¡®ä¿åœ¨æœ€ä¸Šå±‚ */
        background: #000;
    }
    #input-video { display: none; }
    #output-canvas { width: 100%; height: 100%; transform: scaleX(-1); }
</style>

<div id="drone-container">
    <div id="game-canvas"></div>

    <div class="ui-layer">
        <div id="status-text" class="status-pill">æ­£åœ¨åˆå§‹åŒ–ç©ºæˆ˜ç³»ç»Ÿ...</div>

        <div id="screen-start">
            <h1 class="game-title">SKY FORCE</h1>
            <div class="menu-item active" id="btn-start">å¼€å§‹å‡ºå‡»</div>
            <div class="menu-item" id="btn-shop">å†›ç«å•†åº—</div>
            <div class="menu-item" id="btn-upgrade">æœºä½“æ”¹é€ </div>
            <div style="margin-top:40px; color:#aaa; font-size:12px;">
                ğŸ–ï¸ å¼ æ‰‹ä¸Šä¸‹ç§»åŠ¨é€‰æ‹© | âœŠ æ¡æ‹³ç¡®è®¤
            </div>
        </div>

        <div id="screen-shop" class="hidden">
            <h2>å†›ç«å•†åº— (é‡‘å¸: <span class="gold-display">0</span>)</h2>
            <div class="grid-panel" id="shop-list"></div>
            <div class="menu-item active" style="margin-top:auto">è¿”å›ä¸»é¡µ</div>
        </div>

        <div id="screen-upgrade" class="hidden">
            <h2>æœºä½“æ”¹é€ </h2>
            <div class="grid-panel" id="upgrade-list"></div>
            <div class="menu-item active" style="margin-top:auto">è¿”å›ä¸»é¡µ</div>
        </div>

        <div id="screen-hud" class="hidden">
            <div id="hud-layer">
                <div>HP: <span id="hud-hp" style="color:#0f0">100%</span></div>
                <div>SCORE: <span id="hud-score">0</span></div>
                <div>ğŸ’°: <span class="gold-display">0</span></div>
            </div>
            <div id="pause-overlay" class="hidden">âš ï¸ ä¿¡å·ä¸¢å¤± - è¯·å±•ç¤ºæ‰‹æŒ</div>
        </div>

        <div id="screen-gameover" class="hidden">
            <h1 style="color:red; font-size:50px;">MISSION FAILED</h1>
            <div style="font-size:20px; color:#fff; margin:20px;">
                å­˜æ´»: <span id="res-time">0</span>s | é‡‘å¸: <span id="res-gold">0</span>
            </div>
            <div class="menu-item active">è¿”å›åŸºåœ°</div>
        </div>
    </div>

    <div class="cam-box"><canvas id="output-canvas"></canvas></div>
    <video id="input-video" playsinline></video>
</div>

<script src="js/three.min.js"></script>
<script src="js/camera_utils.js"></script>
<script src="js/control_utils.js"></script>
<script src="js/drawing_utils.js"></script>
<script src="js/hands.js"></script>

<script>
console.log(">>> [SkyForce] å¯åŠ¨ä¸­...");

try {
    // ================= 0. å…¨å±€å­˜æ¡£ =================
    const GAME_DATA = {
        gold: 0,
        unlocked: ['skin_default', 'w_normal'], 
        equipped: { skin: 'skin_default', weapon: 'w_normal', armors: [] },
        upgrades: { fireRate: 1, bulletCount: 1 }
    };
    const saveStr = localStorage.getItem('skyforce_save');
    if(saveStr) Object.assign(GAME_DATA, JSON.parse(saveStr));

    function saveGame() {
        localStorage.setItem('skyforce_save', JSON.stringify(GAME_DATA));
        document.querySelectorAll('.gold-display').forEach(e => e.innerText = GAME_DATA.gold);
    }
    saveGame();

    const CONFIG = {
        shop: [
            { id: 'w_laser', name: 'æ¿€å…‰ç‚®', price: 500 },
            { id: 'w_scatter', name: 'æ•£å°„ç‚®', price: 800 },
            { id: 'a_magnet', name: 'ç£åŠ›è£…ç”²', price: 300 },
            { id: 'a_shield', name: 'å¼ºåŠ›æŠ¤ç›¾', price: 400 }
        ],
        upgrades: [
            { id: 'u_speed', name: 'å°„é€Ÿå¼ºåŒ–', basePrice: 100 },
            { id: 'u_count', name: 'å¼¹èˆ±æ‰©å®¹', basePrice: 200 }
        ]
    };

    // ================= 1. å¼•æ“åˆå§‹åŒ– =================
    const container = document.getElementById('drone-container');
    const statusText = document.getElementById('status-text');
    
    if(!container) throw new Error("å®¹å™¨ç¼ºå¤±");
    
    let width = container.clientWidth || 800;
    let height = container.clientHeight || 600;

    const scene = new THREE.Scene();
    const camera = new THREE.OrthographicCamera(-width/2, width/2, height/2, -height/2, 1, 1000);
    camera.position.z = 100;

    const renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
    renderer.setSize(width, height);
    document.getElementById('game-canvas').appendChild(renderer.domElement);

    // æ˜Ÿç©ºèƒŒæ™¯
    function createStarBg() {
        const cvs = document.createElement('canvas');
        cvs.width = 512; cvs.height = 512;
        const ctx = cvs.getContext('2d');
        ctx.fillStyle = '#000011'; ctx.fillRect(0,0,512,512);
        ctx.fillStyle = '#ffffff';
        for(let i=0; i<150; i++) {
            const s = Math.random();
            ctx.globalAlpha = Math.random();
            ctx.fillRect(Math.random()*512, Math.random()*512, s*2, s*2);
        }
        const tex = new THREE.CanvasTexture(cvs);
        tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
        return tex;
    }
    const bgTex = createStarBg();
    const bgMesh = new THREE.Mesh(new THREE.PlaneGeometry(width, height*2), new THREE.MeshBasicMaterial({ map: bgTex }));
    bgMesh.position.z = -10;
    scene.add(bgMesh);

    // ================= 2. çº¹ç†å·¥å‚ (æœ¬åœ°ç”Ÿæˆ) =================
    const TextureFactory = {
        player: (color) => {
            const cvs = document.createElement('canvas'); cvs.width=64; cvs.height=64;
            const ctx = cvs.getContext('2d');
            // æœºç¿¼
            ctx.fillStyle = '#888'; ctx.beginPath(); ctx.moveTo(32,10); ctx.lineTo(60,50); ctx.lineTo(4,50); ctx.fill();
            // æœºèº«
            ctx.fillStyle = color; ctx.beginPath(); ctx.moveTo(32,0); ctx.lineTo(40,55); ctx.lineTo(24,55); ctx.fill();
            // å–·å£
            ctx.fillStyle = '#00ffff'; ctx.beginPath(); ctx.arc(32, 45, 4, 0, Math.PI*2); ctx.fill();
            return new THREE.CanvasTexture(cvs);
        },
        enemy: (type) => {
            const cvs = document.createElement('canvas'); cvs.width=64; cvs.height=64;
            const ctx = cvs.getContext('2d');
            if(type==='basic') {
                ctx.fillStyle = '#ff4444'; // çº¢è‰²æ•Œæœº
                ctx.beginPath(); ctx.moveTo(32,60); ctx.lineTo(60,10); ctx.lineTo(4,10); ctx.fill();
            }
            return new THREE.CanvasTexture(cvs);
        },
        bullet: (isPlayer) => {
            const cvs = document.createElement('canvas'); cvs.width=16; cvs.height=32;
            const ctx = cvs.getContext('2d');
            ctx.fillStyle = isPlayer ? '#ffff00' : '#ff0055';
            // è§å…‰æ„Ÿ
            ctx.shadowBlur = 5; ctx.shadowColor = ctx.fillStyle;
            ctx.fillRect(6,4,4,24);
            return new THREE.CanvasTexture(cvs);
        },
        gold: () => {
            const cvs = document.createElement('canvas'); cvs.width=32; cvs.height=32;
            const ctx = cvs.getContext('2d');
            ctx.fillStyle = '#ffd700'; ctx.beginPath(); ctx.arc(16,16,12,0,Math.PI*2); ctx.fill();
            ctx.strokeStyle='#fff'; ctx.lineWidth=2; ctx.stroke();
            ctx.fillStyle='#000'; ctx.font='bold 16px Arial'; ctx.textAlign='center'; ctx.textBaseline='middle';
            ctx.fillText('$', 16, 17);
            return new THREE.CanvasTexture(cvs);
        }
    };

    class Entity {
        constructor(tex, x, y, w, h) {
            this.mesh = new THREE.Sprite(new THREE.SpriteMaterial({ map: tex }));
            this.mesh.scale.set(w, h, 1);
            this.mesh.position.set(x, y, 0);
            this.width = w; this.height = h;
            this.active = true;
            scene.add(this.mesh);
        }
        remove() {
            if(!this.active) return;
            this.active = false;
            scene.remove(this.mesh);
        }
        update() {}
        checkCollide(other) {
            if(!other.active) return false;
            const dx = Math.abs(this.mesh.position.x - other.mesh.position.x);
            const dy = Math.abs(this.mesh.position.y - other.mesh.position.y);
            return (dx < (this.width + other.width)/2.5) && (dy < (this.height + other.height)/2.5);
        }
    }

    // ================= 3. æ¸¸æˆé€»è¾‘ =================
    const STATE = { MENU: 0, PLAY: 1, PAUSE: 2, GAMEOVER: 3, SHOP: 4, UPGRADE: 5 };
    let currentState = STATE.MENU;
    
    let entities = { bullets: [], enemies: [], loots: [] };
    let player = null;
    let gameTime = 0;
    let goldInGame = 0;
    let frames = 0;

    class Player extends Entity {
        constructor() {
            super(TextureFactory.player('#00ccff'), 0, -200, 60, 60);
            this.hp = 3 + (GAME_DATA.equipped.armors.includes('a_shield') ? 2 : 0);
            this.maxHp = this.hp;
            this.lastShot = 0;
            this.magnet = GAME_DATA.equipped.armors.includes('a_magnet');
        }
        update(inputPos) {
            const targetX = inputPos.x * (width/2 - 40);
            const targetY = inputPos.y * (height/2 - 40);
            this.mesh.position.x += (targetX - this.mesh.position.x) * 0.15;
            this.mesh.position.y += (targetY - this.mesh.position.y) * 0.15;

            // å°„å‡»
            const fireInterval = Math.max(5, 20 - GAME_DATA.upgrades.fireRate * 2);
            if(frames - this.lastShot > fireInterval) {
                this.shoot();
                this.lastShot = frames;
            }
        }
        shoot() {
            const count = GAME_DATA.upgrades.bulletCount;
            const weapon = GAME_DATA.equipped.weapon;
            for(let i=0; i<count; i++) {
                const offset = (i - (count-1)/2) * 15;
                const b = new Entity(TextureFactory.bullet(true), this.mesh.position.x + offset, this.mesh.position.y + 30, 16, 32);
                b.speedY = 15;
                b.speedX = (weapon === 'w_scatter') ? offset * 0.15 : 0;
                b.update = function() {
                    this.mesh.position.y += this.speedY;
                    this.mesh.position.x += this.speedX;
                    if(this.mesh.position.y > height/2 + 50) this.remove();
                };
                entities.bullets.push(b);
            }
        }
        hit() {
            this.hp--;
            document.getElementById('hud-hp').innerText = Math.floor(this.hp/this.maxHp*100) + "%";
            if(this.hp <= 0) gameOver();
        }
    }

    function startGame() {
        [...entities.bullets, ...entities.enemies, ...entities.loots].forEach(e => e.remove());
        entities = { bullets: [], enemies: [], loots: [] };
        if(player) player.remove();

        player = new Player();
        goldInGame = 0;
        gameTime = 0;
        switchScreen('screen-hud');
        currentState = STATE.PLAY;
    }

    function gameOver() {
        currentState = STATE.GAMEOVER;
        GAME_DATA.gold += goldInGame;
        saveGame();
        document.getElementById('res-time').innerText = Math.floor(gameTime);
        document.getElementById('res-gold').innerText = goldInGame;
        switchScreen('screen-gameover');
    }

    // ================= 4. èœå•äº¤äº’ =================
    const screens = ['screen-start', 'screen-shop', 'screen-upgrade', 'screen-gameover', 'screen-hud'];
    let menuIndex = 0;
    let menuItems = [];
    let lastMenuMove = 0;

    function switchScreen(id) {
        screens.forEach(s => document.getElementById(s).classList.add('hidden'));
        const active = document.getElementById(id);
        active.classList.remove('hidden');
        
        if(id !== 'screen-hud') {
            menuItems = Array.from(active.querySelectorAll('.menu-item'));
            menuIndex = 0;
            updateMenuHighlight();
        }
    }

    function updateMenuHighlight() {
        menuItems.forEach((item, idx) => {
            if(idx === menuIndex) item.classList.add('active');
            else item.classList.remove('active');
        });
    }

    function handleMenuInput(handY, isFist) {
        const now = Date.now();
        if (now - lastMenuMove > 400) { 
            if (handY < -0.2) { 
                menuIndex = (menuIndex - 1 + menuItems.length) % menuItems.length;
                lastMenuMove = now;
                updateMenuHighlight();
            } else if (handY > 0.2) { 
                menuIndex = (menuIndex + 1) % menuItems.length;
                lastMenuMove = now;
                updateMenuHighlight();
            }
        }

        if (isFist && now - lastMenuMove > 1000) { 
            lastMenuMove = now;
            const action = menuItems[menuIndex];
            
            if (currentState === STATE.MENU) {
                if (action.id === 'btn-start') startGame();
                else if (action.id === 'btn-shop') { initShop(); currentState = STATE.SHOP; switchScreen('screen-shop'); }
                else if (action.id === 'btn-upgrade') { initUpgrade(); currentState = STATE.UPGRADE; switchScreen('screen-upgrade'); }
            } else if (currentState === STATE.SHOP || currentState === STATE.UPGRADE) {
                if (action.innerText.includes("è¿”å›")) {
                    currentState = STATE.MENU;
                    switchScreen('screen-start');
                } else {
                    buyOrEquip(action.dataset.id);
                }
            } else if (currentState === STATE.GAMEOVER) {
                currentState = STATE.MENU;
                switchScreen('screen-start');
            }
        }
    }

    function initShop() {
        const list = document.getElementById('shop-list');
        list.innerHTML = '';
        CONFIG.shop.forEach(item => {
            const div = document.createElement('div');
            div.className = 'menu-item shop-card';
            if (GAME_DATA.unlocked.includes(item.id)) {
                div.className += ' owned';
                div.innerHTML = `${item.name}<br>âœ… å·²æ‹¥æœ‰`;
            } else {
                div.innerHTML = `${item.name}<br>ğŸ’° ${item.price}`;
            }
            div.dataset.id = item.id;
            div.dataset.price = item.price;
            list.appendChild(div);
        });
        menuItems = Array.from(list.querySelectorAll('.menu-item'));
        menuItems.push(document.querySelector('#screen-shop .menu-item:last-child'));
        updateMenuHighlight();
    }

    function buyOrEquip(id) {
        if(!id) return;
        const shopItem = CONFIG.shop.find(i => i.id === id);
        if (shopItem) {
            if (!GAME_DATA.unlocked.includes(id)) {
                if (GAME_DATA.gold >= shopItem.price) {
                    GAME_DATA.gold -= shopItem.price;
                    GAME_DATA.unlocked.push(id);
                    // è‡ªåŠ¨è£…å¤‡
                    if(shopItem.id.startsWith('w_')) GAME_DATA.equipped.weapon = id;
                    if(shopItem.id.startsWith('a_')) GAME_DATA.equipped.armors.push(id);
                    saveGame();
                    initShop(); 
                }
            } else {
                // å·²æ‹¥æœ‰ï¼Œåˆ‡æ¢è£…å¤‡
                if(shopItem.id.startsWith('w_')) GAME_DATA.equipped.weapon = id;
                alert("è£…å¤‡å·²åˆ‡æ¢: " + shopItem.name);
            }
        }
    }

    // ================= 5. MediaPipe =================
    const videoElement = document.getElementById('input-video');
    const canvasElement = document.getElementById('output-canvas');
    const canvasCtx = canvasElement.getContext('2d');
    
    let handPos = { x: 0, y: 0 };
    let isHandDetected = false;
    let isFist = false;

    function onResults(results) {
        // æ›´æ–°çŠ¶æ€æç¤º
        if(statusText.innerText.includes("åˆå§‹åŒ–")) {
            statusText.innerText = "ç³»ç»Ÿå°±ç»ªï¼šè¯·å±•ç¤ºæ‰‹æŒ";
            statusText.style.color = "#00ff00";
            statusText.style.borderColor = "#00ff00";
        }

        canvasCtx.save();
        canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
        canvasCtx.drawImage(results.image, 0, 0, canvasElement.width, canvasElement.height);

        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
            isHandDetected = true;
            const landmarks = results.multiHandLandmarks[0];
            drawConnectors(canvasCtx, landmarks, HAND_CONNECTIONS, {color: '#00FF00', lineWidth: 2});
            drawLandmarks(canvasCtx, landmarks, {color: '#FF0000', lineWidth: 1, radius: 2});

            const cx = landmarks[9].x; 
            const cy = landmarks[9].y;
            handPos.x = (0.5 - cx) * 2; 
            handPos.y = (0.5 - cy) * 2; 

            // æ¡æ‹³æ£€æµ‹
            const tips = [8, 12, 16, 20];
            let extended = 0;
            tips.forEach(i => {
                if (landmarks[i].y < landmarks[i-2].y) extended++; 
            });
            isFist = (extended < 2); 

            if (currentState === STATE.PLAY) {
                document.getElementById('pause-overlay').classList.add('hidden');
                player.update(handPos);
            } else {
                handleMenuInput(handPos.y, isFist);
            }
        } else {
            isHandDetected = false;
            if (currentState === STATE.PLAY) {
                document.getElementById('pause-overlay').classList.remove('hidden');
            }
        }
        canvasCtx.restore();
    }

    const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
    hands.setOptions({maxNumHands: 1, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5});
    hands.onResults(onResults);

    const cameraUtils = new Camera(videoElement, {
        onFrame: async () => { await hands.send({image: videoElement}); },
        width: 320, height: 240
    });
    cameraUtils.start().catch(err => {
        statusText.innerText = "âŒ æ‘„åƒå¤´å¯åŠ¨å¤±è´¥";
        statusText.style.background = "red";
    });

    // ================= 6. æ¸¸æˆå¾ªç¯ =================
    function animate() {
        requestAnimationFrame(animate);
        
        // èƒŒæ™¯ç§»åŠ¨
        bgTex.offset.y -= 0.002;

        if (currentState === STATE.PLAY && isHandDetected) {
            frames++;
            gameTime += 1/60;

            // åˆ·æ€ª (60å¸§ä¸€æ¬¡)
            if (frames % 60 === 0) {
                const e = new Entity(TextureFactory.enemy('basic'), (Math.random()-0.5)*width*0.8, height/2 + 50, 50, 50);
                e.hp = 2; // ç¨è‚‰ä¸€ç‚¹
                e.update = function() {
                    this.mesh.position.y -= 3;
                    if(this.mesh.position.y < -height/2 - 50) this.remove();
                    if(this.active && this.checkCollide(player)) {
                        this.remove(); player.hit();
                    }
                };
                entities.enemies.push(e);
            }

            // æ›´æ–°å­å¼¹
            entities.bullets.forEach(b => b.update());
            
            // æ›´æ–°æ•Œäºº
            entities.enemies.forEach(e => {
                e.update();
                entities.bullets.forEach(b => {
                    if(b.active && e.active && b.checkCollide(e)) {
                        b.remove(); e.hp--;
                        if(e.hp <= 0) {
                            e.remove();
                            score += 100;
                            document.getElementById('hud-score').innerText = score;
                            // 50% çˆ†ç‡
                            if(Math.random() > 0.5) {
                                const g = new Entity(TextureFactory.gold(), e.mesh.position.x, e.mesh.position.y, 30, 30);
                                g.update = function() {
                                    this.mesh.position.y -= 2;
                                    if(player.magnet) {
                                        this.mesh.position.x += (player.mesh.position.x - this.mesh.position.x)*0.1;
                                        this.mesh.position.y += (player.mesh.position.y - this.mesh.position.y)*0.1;
                                    }
                                    if(this.checkCollide(player)) {
                                        this.remove(); goldInGame += 10;
                                        document.querySelector('#screen-hud .gold-display').innerText = goldInGame;
                                    }
                                };
                                entities.loots.push(g);
                            }
                        }
                    }
                });
            });
            
            // æ›´æ–°æ‰è½ç‰©
            entities.loots.forEach(l => l.update());

            // æ¸…ç†
            entities.bullets = entities.bullets.filter(e => e.active);
            entities.enemies = entities.enemies.filter(e => e.active);
            entities.loots = entities.loots.filter(e => e.active);
        }

        renderer.render(scene, camera);
    }
    animate();

    window.addEventListener('resize', () => {
        if(!container) return;
        width = container.clientWidth;
        height = container.clientHeight;
        camera.left = -width/2; camera.right = width/2;
        camera.top = height/2; camera.bottom = -height/2;
        camera.updateProjectionMatrix();
        renderer.setSize(width, height);
    });

} catch(e) {
    console.error(e);
    document.getElementById('status-text').innerText = "é”™è¯¯: " + e.message;
}
</script>