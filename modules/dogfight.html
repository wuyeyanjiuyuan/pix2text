<style>
    #game-container {
        position: relative; width: 100%; height: 600px;
        background: #000; border-radius: 12px; overflow: hidden;
        border: 2px solid #333;
        font-family: "Segoe UI", sans-serif;
        cursor: none; /* éšè—é¼ æ ‡ï¼Œæ²‰æµ¸å¼ä½“éªŒ */
    }

    /* æ¸¸æˆä¸»ç”»å¸ƒ */
    canvas { display: block; width: 100%; height: 100%; }

    /* UI è¦†ç›–å±‚ */
    .ui-overlay {
        position: absolute; top: 0; left: 0; width: 100%; height: 100%;
        pointer-events: none; display: flex; flex-direction: column;
        justify-content: space-between; padding: 20px; box-sizing: border-box;
    }

    /* çŠ¶æ€æ  */
    .hud-bar {
        display: flex; justify-content: space-between; align-items: center;
        text-shadow: 0 2px 4px rgba(0,0,0,0.8);
    }
    .score-box { font-size: 24px; color: #ffcc00; font-weight: bold; }
    .hp-bar-bg { width: 200px; height: 12px; background: rgba(255,255,255,0.2); border-radius: 6px; overflow: hidden; }
    .hp-bar-fill { width: 100%; height: 100%; background: linear-gradient(90deg, #00ff00, #adff2f); transition: width 0.2s; }

    /* æ¸¸æˆç»“æŸ/å¼€å§‹ å±å¹• */
    .center-screen {
        position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
        text-align: center; color: white; background: rgba(0,0,0,0.85);
        padding: 40px; border-radius: 16px; border: 1px solid #444;
        backdrop-filter: blur(5px); display: none; pointer-events: auto;
    }
    .center-screen.active { display: block; }
    
    .title { font-size: 48px; color: #00ffff; letter-spacing: 4px; margin-bottom: 20px; text-transform: uppercase; }
    .subtitle { font-size: 18px; color: #aaa; margin-bottom: 30px; line-height: 1.6; }
    
    .btn {
        background: #ffcc00; color: #000; border: none; padding: 12px 30px;
        font-size: 18px; font-weight: bold; border-radius: 30px; cursor: pointer;
        transition: transform 0.1s; display: inline-block;
    }
    .btn:hover { transform: scale(1.05); box-shadow: 0 0 15px #ffcc00; }

    /* æ‘„åƒå¤´å°çª— */
    .cam-box {
        position: absolute; bottom: 20px; right: 20px;
        width: 120px; height: 90px; border-radius: 8px; overflow: hidden;
        border: 2px solid rgba(255,255,255,0.3); z-index: 100; background: #000;
        transform: scaleX(-1); /* é•œåƒç¿»è½¬ */
    }
    #input-video { display: none; }
</style>

<div id="game-container">
    <canvas id="main-canvas"></canvas>

    <div class="ui-layer">
        <div class="hud-bar">
            <div class="score-box">SCORE: <span id="ui-score">0</span></div>
            <div>
                <div style="font-size:12px; color:#ccc; margin-bottom:4px;">SHIELD INTEGRITY</div>
                <div class="hp-bar-bg"><div id="ui-hp" class="hp-bar-fill"></div></div>
            </div>
        </div>

        <div id="pause-tip" style="text-align: center; color: #ff3333; font-weight: bold; opacity: 0;">
            âš ï¸ ä¿¡å·ä¸¢å¤± - è¯·æŠŠæ‰‹ç§»å›å±å¹•
        </div>
    </div>

    <div id="start-screen" class="center-screen active">
        <div class="title">GESTURE WAR</div>
        <div class="subtitle">
            ğŸ–ï¸ å¼ å¼€æ‰‹æŒï¼šæ§åˆ¶æˆ˜æœºç§»åŠ¨<br>
            âœŠ æ¡ç´§æ‹³å¤´ï¼šé‡Šæ”¾å…¨å±å¤§æ‹› (éœ€å……èƒ½)<br>
            ğŸš« æ‰‹ç§»å¼€ï¼šè‡ªåŠ¨æš‚åœ
        </div>
        <button class="btn" onclick="game.start()">START MISSION</button>
    </div>

    <div id="gameover-screen" class="center-screen">
        <div class="title" style="color:#ff3333">M.I.A.</div>
        <div class="subtitle">
            æœ€ç»ˆå¾—åˆ†: <span id="final-score" style="color:white; font-size:24px;">0</span><br>
            å‡»å æ•Œæœº: <span id="final-kills">0</span>
        </div>
        <button class="btn" onclick="game.restart()">RETRY</button>
    </div>

    <div class="cam-box"><canvas id="output-canvas"></canvas></div>
    <video id="input-video" playsinline></video>
</div>

<script src="js/camera_utils.js"></script>
<script src="js/control_utils.js"></script>
<script src="js/drawing_utils.js"></script>
<script src="js/hands.js"></script>

<script>
/**
 * çº¯ Canvas 2D æ¸¸æˆå¼•æ“ - ä¸“ä¸ºæ‰‹åŠ¿ä¼˜åŒ–
 * æ— å¤–éƒ¨å›¾ç‰‡ä¾èµ–ï¼Œå…¨éƒ¨ä»£ç ç»˜åˆ¶
 */
const canvas = document.getElementById('main-canvas');
const ctx = canvas.getContext('2d');
const container = document.getElementById('game-container');

// é€‚é…é«˜åˆ†å±
function resize() {
    canvas.width = container.clientWidth;
    canvas.height = container.clientHeight;
}
window.addEventListener('resize', resize);
resize();

// ================= æ¸¸æˆæ ¸å¿ƒç±» =================

class Game {
    constructor() {
        this.state = 'MENU'; // MENU, PLAYING, PAUSED, GAMEOVER
        this.score = 0;
        this.kills = 0;
        this.frames = 0;
        
        this.player = {
            x: canvas.width / 2, y: canvas.height - 100,
            w: 40, h: 50,
            hp: 100, maxHp: 100,
            power: 1, // æ­¦å™¨ç­‰çº§ 1-3
            energy: 0 // å¤§æ‹›èƒ½é‡ 0-100
        };
        
        this.handTarget = { x: canvas.width/2, y: canvas.height - 100 }; // æ‰‹åŠ¿ç›®æ ‡ç‚¹
        this.hasHand = false; // æ˜¯å¦æ£€æµ‹åˆ°æ‰‹

        this.bullets = [];
        this.enemies = [];
        this.particles = []; // çˆ†ç‚¸ç‰¹æ•ˆ
        this.stars = [];     // èƒŒæ™¯æ˜Ÿç©º

        // åˆå§‹åŒ–æ˜Ÿç©º
        for(let i=0; i<100; i++) {
            this.stars.push({
                x: Math.random() * canvas.width,
                y: Math.random() * canvas.height,
                size: Math.random() * 2,
                speed: Math.random() * 3 + 1
            });
        }
    }

    start() {
        this.reset();
        this.state = 'PLAYING';
        document.getElementById('start-screen').classList.remove('active');
        document.getElementById('gameover-screen').classList.remove('active');
        loop();
    }

    restart() {
        this.start();
    }

    reset() {
        this.score = 0;
        this.kills = 0;
        this.player.hp = 100;
        this.player.power = 1;
        this.player.energy = 0;
        this.bullets = [];
        this.enemies = [];
        this.particles = [];
        this.updateUI();
    }

    update() {
        if (this.state !== 'PLAYING') return;

        // 1. ç©å®¶ç§»åŠ¨ (å¹³æ»‘è·Ÿéšç®—æ³•)
        // æ‰‹åœ¨å“ªï¼Œé£æœºå°±å¾€å“ªé£ï¼Œå¸¦ä¸€ç‚¹æƒ¯æ€§å»¶è¿Ÿï¼Œæ‰‹æ„Ÿæ›´å¥½
        if (this.hasHand) {
            const dx = this.handTarget.x - this.player.x;
            const dy = this.handTarget.y - this.player.y;
            this.player.x += dx * 0.15; // 0.15 æ˜¯è·Ÿéšé€Ÿåº¦ç³»æ•°
            this.player.y += dy * 0.15;
        }

        // è¾¹ç•Œé™åˆ¶
        this.player.x = Math.max(20, Math.min(canvas.width - 20, this.player.x));
        this.player.y = Math.max(20, Math.min(canvas.height - 20, this.player.y));

        // 2. è‡ªåŠ¨å°„å‡»
        if (this.frames % 10 === 0) { // å°„é€Ÿ
            this.spawnPlayerBullet();
        }

        // 3. ç”Ÿæˆæ•Œäºº (éš¾åº¦éšåˆ†æ•°å¢åŠ )
        const spawnRate = Math.max(30, 60 - Math.floor(this.score / 500));
        if (this.frames % spawnRate === 0) {
            this.spawnEnemy();
        }

        // 4. æ›´æ–°æ‰€æœ‰å®ä½“
        this.updateBullets();
        this.updateEnemies();
        this.updateParticles();
        this.updateBackground();

        this.frames++;
    }

    draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // èƒŒæ™¯
        this.drawBackground();

        if (this.state === 'PLAYING' || this.state === 'PAUSED') {
            this.drawPlayer();
            this.drawBullets();
            this.drawEnemies();
            this.drawParticles();
        }
    }

    // --- å®ä½“é€»è¾‘ ---

    spawnPlayerBullet() {
        // æ ¹æ® power ç­‰çº§å‘å°„ä¸åŒå­å¼¹
        if (this.player.power === 1) {
            this.bullets.push({ x: this.player.x, y: this.player.y - 20, vx: 0, vy: -15, type: 'hero', color: '#00ffff' });
        } else if (this.player.power >= 2) {
            this.bullets.push({ x: this.player.x - 10, y: this.player.y - 10, vx: 0, vy: -15, type: 'hero', color: '#00ffff' });
            this.bullets.push({ x: this.player.x + 10, y: this.player.y - 10, vx: 0, vy: -15, type: 'hero', color: '#00ffff' });
        }
        // power 3 å¯ä»¥åŠ æ•£å°„ï¼Œè¿™é‡Œç•¥
    }

    spawnEnemy() {
        const type = Math.random();
        const x = Math.random() * (canvas.width - 40) + 20;
        
        if (type < 0.7) {
            // æ™®é€šæ‚å…µ
            this.enemies.push({ 
                x: x, y: -30, w: 30, h: 30, 
                vx: (Math.random()-0.5)*2, vy: 3 + Math.random()*2, 
                hp: 2, maxHp: 2, type: 'scout', color: '#ff4444' 
            });
        } else {
            // é‡å‹æœº
            this.enemies.push({ 
                x: x, y: -50, w: 50, h: 50, 
                vx: 0, vy: 1.5, 
                hp: 10, maxHp: 10, type: 'heavy', color: '#cc00ff' 
            });
        }
    }

    updateBullets() {
        for (let i = this.bullets.length - 1; i >= 0; i--) {
            let b = this.bullets[i];
            b.x += b.vx;
            b.y += b.vy;

            // å‡ºç•Œç§»é™¤
            if (b.y < -20 || b.y > canvas.height + 20) {
                this.bullets.splice(i, 1);
                continue;
            }

            // ç¢°æ’æ£€æµ‹ï¼šç©å®¶å­å¼¹æ‰“æ•Œäºº
            if (b.type === 'hero') {
                for (let j = this.enemies.length - 1; j >= 0; j--) {
                    let e = this.enemies[j];
                    if (this.checkRectCollide(b.x-2, b.y-5, 4, 10, e.x-e.w/2, e.y-e.h/2, e.w, e.h)) {
                        // å‘½ä¸­
                        this.createExplosion(b.x, b.y, 3, '#00ffff');
                        this.bullets.splice(i, 1); // ç§»é™¤å­å¼¹
                        e.hp--;
                        if (e.hp <= 0) {
                            this.killEnemy(e, j);
                        }
                        break; // å­å¼¹æ²¡äº†ï¼Œè·³å‡ºæ•Œäººå¾ªç¯
                    }
                }
            }
        }
    }

    updateEnemies() {
        for (let i = this.enemies.length - 1; i >= 0; i--) {
            let e = this.enemies[i];
            e.x += e.vx;
            e.y += e.vy;

            // æ’ç©å®¶
            if (this.checkRectCollide(e.x-e.w/2, e.y-e.h/2, e.w, e.h, this.player.x-10, this.player.y-10, 20, 30)) {
                this.player.hp -= 20;
                this.updateUI();
                this.createExplosion(this.player.x, this.player.y, 20, '#ff0000');
                this.killEnemy(e, i); // æ•Œäººè‡ªçˆ†
                
                if (this.player.hp <= 0) {
                    this.gameOver();
                }
                continue;
            }

            // å‡ºç•Œ
            if (e.y > canvas.height + 50) {
                this.enemies.splice(i, 1);
            }
        }
    }

    killEnemy(e, index) {
        this.createExplosion(e.x, e.y, e.w/2, e.color);
        this.enemies.splice(index, 1);
        this.score += (e.type === 'heavy' ? 100 : 10);
        this.kills++;
        
        // ç®€å•çš„å‡çº§é€»è¾‘ï¼šæ¯æ€10ä¸ªæ•Œäººå‡çº§ä¸€æ¬¡æ­¦å™¨
        if (this.kills % 10 === 0 && this.player.power < 3) {
            this.player.power++;
            // æ–‡å­—ç‰¹æ•ˆï¼šWeapon Up!
        }
        this.updateUI();
    }

    // --- ç‰¹æ•ˆç³»ç»Ÿ ---
    createExplosion(x, y, size, color) {
        const count = 5 + size/2;
        for(let i=0; i<count; i++) {
            const angle = Math.random() * Math.PI * 2;
            const speed = Math.random() * 3;
            this.particles.push({
                x: x, y: y,
                vx: Math.cos(angle) * speed,
                vy: Math.sin(angle) * speed,
                life: 1.0,
                color: color,
                size: Math.random() * 3 + 1
            });
        }
    }

    updateParticles() {
        for(let i = this.particles.length - 1; i >= 0; i--) {
            let p = this.particles[i];
            p.x += p.vx;
            p.y += p.vy;
            p.life -= 0.05;
            if(p.life <= 0) this.particles.splice(i, 1);
        }
    }

    updateBackground() {
        this.stars.forEach(s => {
            s.y += s.speed;
            if (s.y > canvas.height) s.y = 0;
        });
    }

    // --- ç»˜åˆ¶æ–¹æ³• (Procedural Drawing) ---
    drawPlayer() {
        ctx.save();
        ctx.translate(this.player.x, this.player.y);
        
        // å–·å°„ç«ç„° (åŠ¨æ€)
        ctx.fillStyle = `rgba(0, 255, 255, ${Math.random()*0.5 + 0.5})`;
        ctx.beginPath();
        ctx.moveTo(-5, 20); ctx.lineTo(0, 35 + Math.random()*10); ctx.lineTo(5, 20);
        ctx.fill();

        // é£æœºä¸»ä½“ (ä¸‰è§’å½¢)
        ctx.fillStyle = '#ccc';
        ctx.beginPath();
        ctx.moveTo(0, -25); // å¤´
        ctx.lineTo(20, 20); // å³ç¿¼
        ctx.lineTo(0, 10);  // å°¾
        ctx.lineTo(-20, 20); // å·¦ç¿¼
        ctx.closePath();
        ctx.fill();
        
        // é©¾é©¶èˆ±
        ctx.fillStyle = '#00ffff';
        ctx.beginPath(); ctx.arc(0, -5, 5, 0, Math.PI*2); ctx.fill();
        
        ctx.restore();
    }

    drawEnemies() {
        this.enemies.forEach(e => {
            ctx.save();
            ctx.translate(e.x, e.y);
            ctx.fillStyle = e.color;
            if (e.type === 'scout') {
                // ç®€å•çš„çº¢è‰²Vå‹æˆ˜æœº
                ctx.beginPath();
                ctx.moveTo(0, 15); ctx.lineTo(15, -15); ctx.lineTo(-15, -15);
                ctx.fill();
            } else {
                // é‡å‹æœºï¼šæ–¹å½¢
                ctx.fillRect(-20, -20, 40, 40);
                // æ ¸å¿ƒ
                ctx.fillStyle = '#fff';
                ctx.beginPath(); ctx.arc(0, 0, 10, 0, Math.PI*2); ctx.fill();
            }
            ctx.restore();
        });
    }

    drawBullets() {
        ctx.fillStyle = '#ffaa00';
        this.bullets.forEach(b => {
            ctx.fillStyle = b.color;
            ctx.beginPath();
            ctx.arc(b.x, b.y, 4, 0, Math.PI*2);
            ctx.fill();
        });
    }

    drawParticles() {
        this.particles.forEach(p => {
            ctx.globalAlpha = p.life;
            ctx.fillStyle = p.color;
            ctx.beginPath();
            ctx.arc(p.x, p.y, p.size, 0, Math.PI*2);
            ctx.fill();
        });
        ctx.globalAlpha = 1.0;
    }

    drawBackground() {
        ctx.fillStyle = '#fff';
        this.stars.forEach(s => {
            ctx.globalAlpha = Math.random() * 0.5 + 0.3;
            ctx.fillRect(s.x, s.y, s.size, s.size);
        });
        ctx.globalAlpha = 1.0;
    }

    updateUI() {
        document.getElementById('ui-score').innerText = this.score;
        document.getElementById('ui-hp').style.width = this.player.hp + "%";
    }

    checkRectCollide(x1, y1, w1, h1, x2, y2, w2, h2) {
        return x1 < x2 + w2 && x1 + w1 > x2 && y1 < y2 + h2 && y1 + h1 > y2;
    }

    gameOver() {
        this.state = 'GAMEOVER';
        document.getElementById('final-score').innerText = this.score;
        document.getElementById('final-kills').innerText = this.kills;
        document.getElementById('gameover-screen').classList.add('active');
        document.getElementById('screen-hud').classList.add('hidden'); // éšè—HUD
    }
}

const game = new Game();

// ================= 7. ä¸»å¾ªç¯ =================
function loop() {
    if (game.state === 'PLAYING') {
        game.update();
        game.draw();
        requestAnimationFrame(loop);
    }
}

// ================= 8. MediaPipe æ‰‹åŠ¿è¾“å…¥ =================
const videoElement = document.getElementById('input-video');
const canvasElement = document.getElementById('output-canvas');
const canvasCtx = canvasElement.getContext('2d');

function onResults(results) {
    canvasCtx.save();
    canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
    canvasCtx.drawImage(results.image, 0, 0, canvasElement.width, canvasElement.height);

    if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
        const landmarks = results.multiHandLandmarks[0];
        
        // ç»˜åˆ¶éª¨æ¶
        drawConnectors(canvasCtx, landmarks, HAND_CONNECTIONS, {color: '#00FF00', lineWidth: 2});
        drawLandmarks(canvasCtx, landmarks, {color: '#FF0000', lineWidth: 1, radius: 2});

        // 1. è·å–æ‰‹æŒä¸­å¿ƒä½ç½® (Index 9 æ˜¯ä¸­æŒ‡æ ¹éƒ¨ï¼Œæ¯”è¾ƒç¨³å®š)
        const cx = landmarks[9].x; 
        const cy = landmarks[9].y;

        // 2. æ›´æ–°æ¸¸æˆè¾“å…¥ (åæ ‡æ˜ å°„)
        // MediaPipe x æ˜¯åçš„ (0åœ¨å·¦ï¼Œ1åœ¨å³ï¼Œä½†é•œåƒå0åœ¨å³)ï¼Œæˆ‘ä»¬éœ€è¦æ˜ å°„åˆ° Canvas åæ ‡
        // x: (1 - cx) * canvas.width
        // y: cy * canvas.height
        game.handTarget.x = (1 - cx) * canvas.width;
        game.handTarget.y = cy * canvas.height;
        game.hasHand = true;

        document.getElementById('pause-tip').style.opacity = 0;

        // 3. æ¡æ‹³æ£€æµ‹ (é‡Šæ”¾å¤§æ‹›/æš‚åœ) - æš‚æ—¶é¢„ç•™é€»è¾‘
        // const isFist = ...

    } else {
        // æ²¡æœ‰æ£€æµ‹åˆ°æ‰‹ -> æš‚åœ
        game.hasHand = false;
        if (game.state === 'PLAYING') {
            document.getElementById('pause-tip').style.opacity = 1;
        }
    }
    canvasCtx.restore();
}

const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
hands.setOptions({maxNumHands: 1, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5});
hands.onResults(onResults);

const cameraUtils = new Camera(videoElement, {
    onFrame: async () => { await hands.send({image: videoElement}); },
    width: 320, height: 240
});
cameraUtils.start();

</script>