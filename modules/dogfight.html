<style>
    /* === æ¸¸æˆå®¹å™¨ === */
    #game-container {
        position: relative; width: 100%; height: 600px;
        background: #050510; /* æ·±è“é»‘èƒŒæ™¯ */
        border-radius: 12px; overflow: hidden;
        border: 2px solid #334455;
        font-family: "Segoe UI", sans-serif;
        cursor: none; user-select: none;
    }

    canvas { display: block; width: 100%; height: 100%; }

    /* UI å±‚ */
    .ui-overlay {
        position: absolute; top: 0; left: 0; width: 100%; height: 100%;
        pointer-events: none; display: flex; flex-direction: column;
        padding: 20px; box-sizing: border-box; z-index: 10;
    }

    /* çŠ¶æ€æŒ‡ç¤ºå™¨ */
    .status-pill {
        position: absolute; top: 20px; left: 20px;
        display: inline-block; padding: 6px 12px;
        background: rgba(0, 0, 0, 0.6); 
        border: 1px solid rgba(0, 255, 255, 0.5);
        border-radius: 4px; backdrop-filter: blur(5px);
        font-size: 12px; color: #00ffff;
        pointer-events: auto;
    }

    /* HUD */
    .hud-bar {
        display: flex; justify-content: flex-end; align-items: flex-start;
        text-shadow: 0 0 10px rgba(0,255,255,0.8);
        font-family: 'Courier New', Courier, monospace; gap: 20px;
    }
    .score-box { font-size: 28px; color: #ffcc00; font-weight: bold; }
    .hp-bar-bg { width: 200px; height: 10px; background: #333; border: 1px solid #666; margin-top: 10px; border-radius: 5px; overflow: hidden;}
    .hp-bar-fill { width: 100%; height: 100%; background: linear-gradient(90deg, #00ff88, #00ffff); transition: width 0.1s; }

    /* èœå•å±å¹• */
    .center-screen {
        position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
        text-align: center; color: white; background: rgba(0,0,0,0.85);
        padding: 60px; border-radius: 16px; border: 1px solid #00ffff;
        box-shadow: 0 0 50px rgba(0, 255, 255, 0.15);
        display: none; pointer-events: auto; z-index: 20;
    }
    .center-screen.active { display: block; animation: fadeIn 0.3s; }
    
    .title { 
        font-size: 64px; color: #fff; font-weight: 900; 
        letter-spacing: 6px; margin-bottom: 30px; 
        text-shadow: 0 0 20px #00ffff, 2px 2px 0 #ff0055;
    }
    .btn {
        background: linear-gradient(180deg, #ffcc00, #ffaa00); 
        color: #000; border: none; padding: 15px 50px;
        font-size: 24px; font-weight: bold; border-radius: 50px; cursor: pointer;
        transition: transform 0.1s; display: inline-block;
        box-shadow: 0 0 20px rgba(255, 200, 0, 0.5); margin-top: 30px;
    }
    .btn:active { transform: scale(0.95); }

    /* æš‚åœæç¤º */
    #pause-overlay {
        position: absolute; top:0; left:0; width:100%; height:100%;
        background: rgba(0,0,0,0.6); backdrop-filter: blur(8px);
        display: flex; align-items: center; justify-content: center;
        color: #ff3333; font-size: 24px; font-weight: bold; letter-spacing: 2px;
        z-index: 5; opacity: 0; transition: opacity 0.2s; pointer-events: none;
        text-shadow: 0 0 10px red;
    }
    #pause-overlay.visible { opacity: 1; }

    /* æ‰‹åŠ¿å…‰æ ‡ (èœå•ç”¨) */
    #hand-cursor {
        position: absolute; width: 20px; height: 20px;
        border: 2px solid #00ff00; border-radius: 50%;
        background: rgba(0,255,0,0.2);
        transform: translate(-50%, -50%); pointer-events: none;
        z-index: 30; display: none;
        box-shadow: 0 0 10px #00ff00;
    }

    /* æ‘„åƒå¤´å°çª— */
    .cam-box {
        position: absolute; bottom: 20px; right: 20px;
        width: 140px; height: 105px; 
        border-radius: 8px; overflow: hidden;
        border: 2px solid rgba(255,255,255,0.2); 
        z-index: 999; background: #000;
        transform: scaleX(-1);
    }
    #input-video { position: absolute; opacity: 0; pointer-events: none; z-index: -1; }
    #output-canvas { width: 100%; height: 100%; display: block; }

    @keyframes fadeIn { from { opacity: 0; transform: translate(-50%, -40%); } to { opacity: 1; transform: translate(-50%, -50%); } }
</style>

<div id="game-container">
    <canvas id="main-canvas"></canvas>

    <div class="ui-overlay">
        <div id="status-text" class="status-pill">1. æ­£åœ¨åˆå§‹åŒ–...</div>

        <div class="hud-bar">
            <div class="score-box"><span style="font-size:14px;color:#aaa">SCORE</span> <span id="ui-score">000000</span></div>
            <div style="text-align: right;">
                <div style="font-size:12px; color:#0f0; margin-bottom:2px;">SHIELD</div>
                <div class="hp-bar-bg"><div id="ui-hp" class="hp-bar-fill"></div></div>
            </div>
        </div>
    </div>

    <div id="pause-overlay">âš ï¸ ä¿¡å·ä¸¢å¤± - è¯·æŠŠæ‰‹ç§»å›å±å¹•</div>

    <div id="hand-cursor"></div>

    <div id="start-screen" class="center-screen active">
        <div class="title">NEO WAR</div>
        <div style="color:#ddd; font-size:16px; line-height:1.8; text-shadow: 0 0 5px rgba(0,0,0,0.5);">
            ğŸ–ï¸ <b style="color:#fff">å¼ å¼€æ‰‹æŒ</b> ç§»åŠ¨æˆ˜æœº<br>
            âœŠ <b style="color:#fff">æ¡ç´§æ‹³å¤´</b> ç‚¹å‡»æŒ‰é’®<br>
            <span style="color:#888; font-size:12px;">(è¯·ç¡®ä¿æ‘„åƒå¤´å·²å…è®¸ä½¿ç”¨)</span>
        </div>
        <button class="btn" id="start-btn" onclick="window.game.start()">START GAME</button>
    </div>

    <div id="gameover-screen" class="center-screen">
        <div class="title" style="color:#ff3333; text-shadow:0 0 20px red;">DEFEATED</div>
        <div style="font-size:18px; color:#fff; margin-bottom:20px;">
            FINAL SCORE: <span id="final-score" style="color:#ffcc00; font-size:32px;">0</span><br>
            KILLS: <span id="final-kills">0</span>
        </div>
        <button class="btn" onclick="window.game.restart()">RETRY</button>
    </div>

    <div class="cam-box"><canvas id="output-canvas"></canvas></div>
    <video id="input-video" playsinline autoplay muted></video>
</div>

<script src="js/camera_utils.js"></script>
<script src="js/control_utils.js"></script>
<script src="js/drawing_utils.js"></script>
<script src="js/hands.js"></script>

<script>
/**
 * Neo War Engine (Neon Edition)
 * ä¿®å¤ï¼šæŒ‰é’®ç‚¹å‡»ã€ç”»é¢è´¨æ„Ÿã€æ‘„åƒå¤´å¯åŠ¨
 */
const canvas = document.getElementById('main-canvas');
const ctx = canvas.getContext('2d');
const container = document.getElementById('game-container');
const statusText = document.getElementById('status-text');
const handCursor = document.getElementById('hand-cursor');

function resize() {
    canvas.width = container.clientWidth;
    canvas.height = container.clientHeight;
}
window.addEventListener('resize', resize);
resize();

// ================= 1. éœ“è™¹èµ„æºå·¥å‚ (å¸¦å‘å…‰) =================
const AssetFactory = {
    // ç©å®¶æˆ˜æœº (è“è‰²éœ“è™¹)
    player: () => {
        const cvs = document.createElement('canvas'); cvs.width=64; cvs.height=64;
        const c = cvs.getContext('2d');
        // å‘å…‰è®¾å®š
        c.shadowBlur = 15; c.shadowColor = '#00aaff';
        c.fillStyle = '#00aaff'; 
        c.beginPath(); c.moveTo(32,0); c.lineTo(60,50); c.lineTo(32,40); c.lineTo(4,50); c.fill();
        c.shadowBlur = 0; // æ ¸å¿ƒä¸å‘å…‰ï¼Œä¿æŒé”åˆ©
        c.fillStyle = '#fff'; c.fillRect(30, 20, 4, 10); // é©¾é©¶èˆ±
        return cvs;
    },
    // æ•Œäººï¼šçº¢è‰²ä¸‰è§’
    enemy_speeder: () => {
        const cvs = document.createElement('canvas'); cvs.width=40; cvs.height=40;
        const c = cvs.getContext('2d');
        c.shadowBlur = 10; c.shadowColor = '#ff3333';
        c.fillStyle = '#ff3333';
        c.beginPath(); c.moveTo(20, 40); c.lineTo(40, 0); c.lineTo(20, 10); c.lineTo(0, 0); c.fill();
        return cvs;
    },
    // æ•Œäººï¼šæ©™è‰²å°„æ‰‹
    enemy_shooter: () => {
        const cvs = document.createElement('canvas'); cvs.width=50; cvs.height=50;
        const c = cvs.getContext('2d');
        c.shadowBlur = 10; c.shadowColor = '#ffaa00';
        c.fillStyle = '#ffaa00';
        c.fillRect(15, 0, 20, 30); 
        c.fillRect(5, 10, 40, 10); 
        return cvs;
    },
    enemy_carrier: () => {
        const cvs = document.createElement('canvas'); cvs.width=80; cvs.height=80;
        const c = cvs.getContext('2d');
        c.shadowBlur = 15; c.shadowColor = '#aa00ff';
        c.fillStyle = '#aa00ff'; c.fillRect(20, 5, 40, 70); 
        c.fillStyle = '#cc55ff'; c.fillRect(5, 20, 15, 40); c.fillRect(60, 20, 15, 40); 
        return cvs;
    }
};

const Assets = {
    player: AssetFactory.player(),
    speeder: AssetFactory.enemy_speeder(),
    shooter: AssetFactory.enemy_shooter(),
    carrier: AssetFactory.enemy_carrier()
};

// ================= 2. æ¸¸æˆæ ¸å¿ƒç±» =================

class Game {
    constructor() {
        this.state = 'MENU'; 
        this.score = 0;
        this.kills = 0;
        this.frames = 0;
        
        this.player = {
            x: canvas.width / 2, y: canvas.height - 100,
            w: 50, h: 50,
            hp: 100, maxHp: 100,
            speed: 0.2 // æ‰‹åŠ¿è·Ÿéšé€Ÿåº¦
        };
        
        this.handTarget = { x: canvas.width/2, y: canvas.height - 100 };
        this.hasHand = false;
        this.isFist = false;

        this.bullets = []; 
        this.ebullets = []; 
        this.enemies = [];
        this.particles = []; 
        this.stars = [];     

        // å¤šå±‚æ˜Ÿç©º (åˆ¶é€ çºµæ·±æ„Ÿ)
        for(let i=0; i<60; i++) this.stars.push({ x:Math.random()*canvas.width, y:Math.random()*canvas.height, size:Math.random()*2, speed:Math.random()*2+0.5, color:'#666' });
        for(let i=0; i<30; i++) this.stars.push({ x:Math.random()*canvas.width, y:Math.random()*canvas.height, size:Math.random()*3+1, speed:Math.random()*4+2, color:'#fff' });
    }

    start() {
        this.reset();
        this.state = 'PLAYING';
        document.getElementById('start-screen').classList.remove('active');
        document.getElementById('gameover-screen').classList.remove('active');
        handCursor.style.display = 'none'; // æ¸¸æˆå¼€å§‹éšè—é¼ æ ‡
        loop();
    }

    restart() { this.start(); }

    reset() {
        this.score = 0;
        this.kills = 0;
        this.player.hp = 100;
        this.player.x = canvas.width / 2;
        this.player.y = canvas.height - 100;
        this.bullets = [];
        this.ebullets = [];
        this.enemies = [];
        this.particles = [];
        this.updateUI();
    }

    update() {
        // èœå•çŠ¶æ€ä¸‹çš„æ‰‹åŠ¿ç‚¹å‡»é€»è¾‘
        if (this.state === 'MENU' || this.state === 'GAMEOVER') {
            if (this.hasHand) {
                handCursor.style.display = 'block';
                handCursor.style.left = this.handTarget.x + 'px';
                handCursor.style.top = this.handTarget.y + 'px';
                
                // æ¡æ‹³æ¨¡æ‹Ÿç‚¹å‡»
                if (this.isFist) {
                    handCursor.style.backgroundColor = 'rgba(255,0,0,0.5)';
                    // æ£€æµ‹æ˜¯å¦åœ¨æŒ‰é’®ä¸Š
                    const btn = document.querySelector('.center-screen.active .btn');
                    if (btn) {
                        const rect = btn.getBoundingClientRect();
                        const containerRect = container.getBoundingClientRect();
                        // è½¬æ¢åæ ‡
                        const handX = this.handTarget.x + containerRect.left;
                        const handY = this.handTarget.y + containerRect.top;
                        
                        if(handX > rect.left && handX < rect.right && handY > rect.top && handY < rect.bottom) {
                            btn.click();
                        }
                    }
                } else {
                    handCursor.style.backgroundColor = 'rgba(0,255,0,0.2)';
                }
            } else {
                handCursor.style.display = 'none';
            }
            return;
        }

        // æ¸¸æˆçŠ¶æ€é€»è¾‘
        if (!this.hasHand) {
            document.getElementById('pause-overlay').classList.add('visible');
            return; 
        } else {
            document.getElementById('pause-overlay').classList.remove('visible');
        }

        // ç©å®¶ç§»åŠ¨ (å¸¦é˜»å°¼)
        const dx = this.handTarget.x - this.player.x;
        const dy = this.handTarget.y - this.player.y;
        this.player.x += dx * this.player.speed;
        this.player.y += dy * this.player.speed;
        
        // è¾¹ç•Œ
        this.player.x = Math.max(30, Math.min(canvas.width - 30, this.player.x));
        this.player.y = Math.max(30, Math.min(canvas.height - 30, this.player.y));

        // ç©å®¶å°¾ç„°ç²’å­
        if(this.frames % 3 === 0) {
            this.particles.push({
                x: this.player.x, y: this.player.y + 25,
                vx: (Math.random()-0.5), vy: Math.random()*2+2,
                life: 1, color: '#00aaff', size: Math.random()*3+2, decay: 0.05
            });
        }

        // å°„å‡»
        if (this.frames % 8 === 0) {
            // ä¸»ç‚®
            this.bullets.push({ x: this.player.x, y: this.player.y - 30, vx: 0, vy: -15, w: 4, h: 20, color: '#ffff00' });
            // åƒšæœº
            this.bullets.push({ x: this.player.x - 20, y: this.player.y, vx: -1, vy: -12, w: 3, h: 10, color: '#00ffff' });
            this.bullets.push({ x: this.player.x + 20, y: this.player.y, vx: 1, vy: -12, w: 3, h: 10, color: '#00ffff' });
        }

        // ç”Ÿæˆæ•Œäºº
        if (this.frames % 60 === 0) this.spawnEnemy();

        this.updateEntities();
        this.frames++;
    }

    spawnEnemy() {
        const rand = Math.random();
        const x = Math.random() * (canvas.width - 60) + 30;
        
        if (rand < 0.5) {
            this.enemies.push({ 
                type: 'speeder', x: x, y: -40, w: 40, h: 40, 
                hp: 3, img: Assets.speeder, vx: 0, vy: 5, t: 0 
            });
        } else if (rand < 0.8) {
            this.enemies.push({ 
                type: 'shooter', x: x, y: -50, w: 50, h: 50, 
                hp: 6, img: Assets.shooter, vx: 0, vy: 2, lastShot: this.frames
            });
        } else {
            this.enemies.push({ 
                type: 'carrier', x: x, y: -80, w: 80, h: 80, 
                hp: 20, img: Assets.carrier, vx: 0, vy: 1 
            });
        }
    }

    updateEntities() {
        // å­å¼¹
        this.bullets.forEach(b => { b.x+=b.vx; b.y+=b.vy; });
        this.bullets = this.bullets.filter(b => b.y > -50);

        // æ•Œæ–¹å­å¼¹
        this.ebullets.forEach(b => { b.x+=b.vx; b.y+=b.vy; });
        this.ebullets = this.ebullets.filter(b => b.y < canvas.height+50);
        
        // ç©å®¶å­å¼¹æ‰“æ•Œäºº
        this.bullets.forEach((b, bi) => {
            for (let j = this.enemies.length - 1; j >= 0; j--) {
                let e = this.enemies[j];
                if (b.active !== false && this.checkCollide(b, e)) {
                    b.active = false; // æ ‡è®°åˆ é™¤
                    e.hp--;
                    this.createExplosion(b.x, b.y, 3, '#00ffff', 3); // å°ç«èŠ±
                    if (e.hp <= 0) {
                        this.killEnemy(e, j);
                    }
                }
            }
        });
        this.bullets = this.bullets.filter(b => b.active !== false);

        // æ•Œæ–¹å­å¼¹æ‰“ç©å®¶
        this.ebullets.forEach((b, i) => {
            if (b.active !== false && this.checkCollide(b, this.player)) {
                b.active = false;
                this.playerDamage(10);
            }
        });
        this.ebullets = this.ebullets.filter(b => b.active !== false);

        // æ•Œäººé€»è¾‘
        this.enemies.forEach((e, i) => {
            if (e.type === 'speeder') { e.t += 0.1; e.x += Math.sin(e.t) * 4; e.y += e.vy; } 
            else { e.y += e.vy; }

            // å°„å‡»
            if (e.type === 'shooter' && (this.frames - e.lastShot > 100)) {
                const angle = Math.atan2(this.player.y - e.y, this.player.x - e.x);
                this.ebullets.push({
                    x: e.x, y: e.y+20, w:8, h:8, color: '#ff3333',
                    vx: Math.cos(angle)*5, vy: Math.sin(angle)*5
                });
                e.lastShot = this.frames;
            }

            // æ’å‡»
            if (this.checkCollide(e, this.player)) {
                this.createExplosion(e.x, e.y, 20, '#ff0000', 10);
                this.enemies.splice(i, 1);
                this.playerDamage(20);
            } else if (e.y > canvas.height + 50) {
                this.enemies.splice(i, 1);
            }
        });

        // ç²’å­æ›´æ–°
        this.particles.forEach(p => { 
            p.x+=p.vx; p.y+=p.vy; 
            p.life-=p.decay || 0.03; 
        });
        this.particles = this.particles.filter(p => p.life > 0);

        // æ˜Ÿç©º
        this.stars.forEach(s => { s.y += s.speed; if(s.y > canvas.height) s.y=0; });

        // æ­»äº¡
        if (this.player.hp <= 0) {
            this.state = 'GAMEOVER';
            document.getElementById('final-score').innerText = this.score;
            document.getElementById('final-kills').innerText = this.kills;
            document.getElementById('gameover-screen').classList.add('active');
        }
    }

    playerDamage(dmg) {
        this.player.hp -= dmg;
        this.createExplosion(this.player.x, this.player.y, 10, '#ffaa00', 15);
        canvas.style.transform = `translate(${Math.random()*10-5}px, ${Math.random()*10-5}px)`;
        setTimeout(() => canvas.style.transform = 'none', 50);
        this.updateUI();
    }

    killEnemy(e, index) {
        this.createExplosion(e.x, e.y, e.w, '#ffaa00', 10);
        this.enemies.splice(index, 1);
        this.score += (e.type==='carrier' ? 500 : 100);
        this.kills++;
        this.updateUI();
    }

    checkCollide(a, b) {
        return Math.abs(a.x - b.x) < (a.w + b.w)/2.5 && 
               Math.abs(a.y - b.y) < (a.h + b.h)/2.5;
    }

    createExplosion(x, y, size, color, count) {
        for(let i=0; i<count; i++) {
            this.particles.push({
                x, y, 
                vx: (Math.random()-0.5)*8, vy: (Math.random()-0.5)*8,
                life: 1, color: color, size: Math.random()*(size/2), decay: 0.02 + Math.random()*0.03
            });
        }
    }

    updateUI() {
        document.getElementById('ui-score').innerText = this.score.toString().padStart(6, '0');
        document.getElementById('ui-hp').style.width = Math.max(0, this.player.hp) + "%";
    }

    draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        // æ˜Ÿç©º
        this.stars.forEach(s => { 
            ctx.fillStyle = s.color;
            ctx.globalAlpha = Math.random() * 0.5 + 0.3; 
            ctx.beginPath(); ctx.arc(s.x, s.y, s.size, 0, Math.PI*2); ctx.fill();
        });
        ctx.globalAlpha = 1;

        if (this.state === 'PLAYING') {
            // ç²’å­ (å‘å…‰)
            ctx.shadowBlur = 10;
            this.particles.forEach(p => {
                ctx.globalAlpha = p.life;
                ctx.fillStyle = p.color;
                ctx.shadowColor = p.color;
                ctx.beginPath(); ctx.arc(p.x, p.y, p.size, 0, Math.PI*2); ctx.fill();
            });
            ctx.shadowBlur = 0;
            ctx.globalAlpha = 1;

            // ç»˜åˆ¶å®ä½“
            ctx.drawImage(Assets.player, this.player.x-32, this.player.y-32);
            
            // å­å¼¹å‘å…‰
            ctx.shadowBlur = 10;
            this.bullets.forEach(b => { ctx.shadowColor = b.color; ctx.fillStyle = b.color; ctx.fillRect(b.x-b.w/2, b.y-b.h/2, b.w, b.h); });
            this.ebullets.forEach(b => { ctx.shadowColor = b.color; ctx.fillStyle = b.color; ctx.beginPath(); ctx.arc(b.x, b.y, 4, 0, Math.PI*2); ctx.fill(); });
            ctx.shadowBlur = 0;

            this.enemies.forEach(e => {
                ctx.drawImage(e.img, e.x-e.w/2, e.y-e.h/2);
                if(e.maxHp > 5) {
                    ctx.fillStyle = 'red'; ctx.fillRect(e.x - 20, e.y - e.h/2 - 10, 40, 4);
                    ctx.fillStyle = '#0f0'; ctx.fillRect(e.x - 20, e.y - e.h/2 - 10, 40 * (e.hp/e.maxHp), 4);
                }
            });
        }
    }
}

// â˜…â˜…â˜… æ ¸å¿ƒä¿®å¤ï¼šæ˜¾å¼æŒ‚è½½ game å¯¹è±¡åˆ° window â˜…â˜…â˜…
window.game = new Game();

function loop() {
    window.game.update();
    window.game.draw();
    if(window.game.state === 'PLAYING') requestAnimationFrame(loop);
}

// ================= 3. MediaPipe æ‰‹åŠ¿è¾“å…¥ =================
const videoElement = document.getElementById('input-video');
const canvasElement = document.getElementById('output-canvas');
const canvasCtx = canvasElement.getContext('2d');

function onResults(results) {
    if(statusText.innerText.includes("åˆå§‹åŒ–")) {
        statusText.innerText = "3. å¼•æ“å°±ç»ªï¼šè¯·å±•ç¤ºæ‰‹æŒ";
        statusText.style.color = "#00ff00";
        statusText.style.borderColor = "#00ff00";
    }

    canvasCtx.save();
    canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
    canvasCtx.drawImage(results.image, 0, 0, canvasElement.width, canvasElement.height);

    if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
        const landmarks = results.multiHandLandmarks[0];
        
        drawConnectors(canvasCtx, landmarks, HAND_CONNECTIONS, {color: '#00FF00', lineWidth: 2});
        drawLandmarks(canvasCtx, landmarks, {color: '#FF0000', lineWidth: 1, radius: 2});

        const cx = landmarks[9].x; 
        const cy = landmarks[9].y;
        
        // æ›´æ–°æ‰‹åŠ¿ç›®æ ‡
        window.game.handTarget.x = (1 - cx) * canvas.width;
        window.game.handTarget.y = cy * canvas.height;
        window.game.hasHand = true;

        // æ¡æ‹³æ£€æµ‹
        const tips = [8, 12, 16, 20];
        let extended = 0;
        tips.forEach(i => { if (landmarks[i].y < landmarks[i-2].y) extended++; });
        window.game.isFist = (extended < 2);

    } else {
        window.game.hasHand = false;
    }
    canvasCtx.restore();
}

// æ­¥éª¤1
statusText.innerText = "1. æ­£åœ¨åŠ è½½ AI æ¨¡å‹...";
const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
hands.setOptions({maxNumHands: 1, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5});
hands.onResults(onResults);

// æ­¥éª¤2
statusText.innerText = "2. æ­£åœ¨å¯åŠ¨æ‘„åƒå¤´...";
const cameraUtils = new Camera(videoElement, {
    onFrame: async () => { await hands.send({image: videoElement}); },
    width: 320, height: 240
});
cameraUtils.start().catch(err => {
    statusText.innerText = "âŒ æ‘„åƒå¤´å¤±è´¥: " + err;
    statusText.style.background = "red";
});

</script>