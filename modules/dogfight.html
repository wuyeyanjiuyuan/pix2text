<style>
    /* === æ¸¸æˆå®¹å™¨ === */
    #game-container {
        position: relative; width: 100%; height: 600px;
        background: #000; border-radius: 12px; overflow: hidden;
        border: 2px solid #333;
        font-family: "Segoe UI", sans-serif;
        cursor: none; user-select: none;
    }

    canvas { display: block; width: 100%; height: 100%; }

    /* UI å±‚ */
    .ui-overlay {
        position: absolute; top: 0; left: 0; width: 100%; height: 100%;
        pointer-events: none; display: flex; flex-direction: column;
        padding: 20px; box-sizing: border-box; z-index: 10;
    }

    /* HUD */
    .hud-bar {
        display: flex; justify-content: space-between; align-items: flex-start;
        text-shadow: 0 2px 4px rgba(0,0,0,0.8);
        font-family: 'Courier New', Courier, monospace;
    }
    .score-box { font-size: 28px; color: #ffcc00; font-weight: bold; }
    .hp-group { display: flex; flex-direction: column; align-items: flex-end; }
    .hp-label { color: #00ff00; font-size: 14px; margin-bottom: 4px; font-weight: bold;}
    .hp-bar-bg { width: 200px; height: 16px; background: rgba(50,50,50,0.8); border: 1px solid #666; }
    .hp-bar-fill { width: 100%; height: 100%; background: linear-gradient(90deg, #00ff00, #adff2f); transition: width 0.1s; }

    /* èœå•å±å¹• */
    .center-screen {
        position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
        text-align: center; color: white; background: rgba(0,0,0,0.9);
        padding: 50px; border-radius: 8px; border: 2px solid #00ffff;
        box-shadow: 0 0 30px rgba(0, 255, 255, 0.2);
        display: none; pointer-events: auto; z-index: 20;
    }
    .center-screen.active { display: block; animation: fadeIn 0.3s; }
    
    .title { 
        font-size: 56px; color: #00ffff; font-weight: 900; 
        text-shadow: 4px 4px 0px #ff0055; margin-bottom: 30px;
        font-family: 'Impact', sans-serif; letter-spacing: 2px;
    }
    .btn {
        background: linear-gradient(180deg, #ffcc00, #ffaa00); 
        color: #000; border: none; padding: 15px 40px;
        font-size: 20px; font-weight: bold; border-radius: 4px; cursor: pointer;
        transition: transform 0.1s; display: inline-block;
        box-shadow: 0 4px 0 #b37700;
    }
    .btn:active { transform: translateY(4px); box-shadow: none; }

    /* æš‚åœæç¤º */
    #pause-overlay {
        position: absolute; top:0; left:0; width:100%; height:100%;
        background: rgba(0,0,0,0.6); backdrop-filter: blur(4px);
        display: flex; align-items: center; justify-content: center;
        color: #ff3333; font-size: 24px; font-weight: bold; letter-spacing: 2px;
        z-index: 5; opacity: 0; transition: opacity 0.2s; pointer-events: none;
    }
    #pause-overlay.visible { opacity: 1; }

    /* â˜…â˜…â˜… æ‘„åƒå¤´å°çª— (ä¿®å¤ç‰ˆ) â˜…â˜…â˜… */
    .cam-box {
        position: absolute; bottom: 20px; right: 20px;
        width: 160px; height: 120px; 
        border-radius: 8px; overflow: hidden;
        border: 2px solid #00ff00; 
        z-index: 9999; /* ç¡®ä¿æœ€é«˜å±‚çº§ */
        background: #000;
        box-shadow: 0 0 15px rgba(0, 255, 0, 0.3);
        transform: scaleX(-1); /* é•œåƒç¿»è½¬ */
    }
    
    /* â˜… å…³é”®ä¿®å¤ï¼šä¸è¦ç”¨ display: noneï¼Œè€Œæ˜¯é€æ˜ â˜… */
    #input-video { 
        position: absolute; width: 1px; height: 1px; 
        opacity: 0; pointer-events: none; 
    }
    #output-canvas { width: 100%; height: 100%; display: block; }

    @keyframes fadeIn { from { opacity: 0; transform: translate(-50%, -40%); } to { opacity: 1; transform: translate(-50%, -50%); } }
</style>

<div id="game-container">
    <canvas id="main-canvas"></canvas>

    <div class="ui-overlay">
        <div class="hud-bar">
            <div class="score-box"><span style="font-size:14px;color:#aaa">SCORE</span> <span id="ui-score">000000</span></div>
            <div class="hp-group">
                <div class="hp-label">SHIELD</div>
                <div class="hp-bar-bg"><div id="ui-hp" class="hp-bar-fill"></div></div>
            </div>
        </div>
    </div>

    <div id="pause-overlay">âš ï¸ ä¿¡å·ä¸¢å¤± - è¯·æŠŠæ‰‹ç§»å›å±å¹•</div>

    <div id="start-screen" class="center-screen active">
        <div class="title">NEO RAIDEN</div>
        <div style="color:#ccc; margin-bottom:30px; font-size:16px; line-height:1.8;">
            ğŸ–ï¸ <span style="color:#fff">å¼ å¼€æ‰‹æŒ</span> ç§»åŠ¨æˆ˜æœº<br>
            âš ï¸ èº²é¿ <span style="color:#ff3333">çº¢è‰²å¼¹å¹•</span><br>
            ğŸš€ å‡»è½æ•Œæœºè·å–é«˜åˆ†
        </div>
        <button class="btn" onclick="game.start()">LAUNCH</button>
    </div>

    <div id="gameover-screen" class="center-screen">
        <div class="title" style="color:#ff3333; text-shadow:none;">DEFEATED</div>
        <div style="font-size:18px; color:#fff; margin-bottom:30px;">
            FINAL SCORE: <span id="final-score" style="color:#ffcc00; font-size:32px;">0</span><br>
            KILLS: <span id="final-kills">0</span>
        </div>
        <button class="btn" onclick="game.restart()">REBOOT SYSTEM</button>
    </div>

    <div class="cam-box"><canvas id="output-canvas"></canvas></div>
    <video id="input-video" playsinline></video>
</div>

<script src="js/control_utils.js"></script>
<script src="js/drawing_utils.js"></script>
<script src="js/hands.js"></script>

<script>
/**
 * Neo Raiden Engine
 */
const canvas = document.getElementById('main-canvas');
const ctx = canvas.getContext('2d');
const container = document.getElementById('game-container');

function resize() {
    canvas.width = container.clientWidth;
    canvas.height = container.clientHeight;
}
window.addEventListener('resize', resize);
resize();

// ================= 1. åƒç´ çº¹ç†å·¥å‚ =================
const AssetFactory = {
    player: () => {
        const cvs = document.createElement('canvas'); cvs.width=64; cvs.height=64;
        const c = cvs.getContext('2d');
        c.fillStyle = '#ccc'; c.beginPath(); c.moveTo(32,10); c.lineTo(62,55); c.lineTo(2,55); c.fill();
        c.fillStyle = '#00aaff'; c.fillRect(28, 5, 8, 50);
        c.fillStyle = '#fff'; c.fillRect(30, 20, 4, 10);
        c.fillStyle = '#ffaa00'; c.fillRect(29, 55, 6, 5);
        return cvs;
    },
    enemy_speeder: () => {
        const cvs = document.createElement('canvas'); cvs.width=40; cvs.height=40;
        const c = cvs.getContext('2d');
        c.fillStyle = '#33ff33';
        c.beginPath(); c.moveTo(20, 38); c.lineTo(38, 2); c.lineTo(20, 10); c.lineTo(2, 2); c.fill();
        return cvs;
    },
    enemy_shooter: () => {
        const cvs = document.createElement('canvas'); cvs.width=50; cvs.height=50;
        const c = cvs.getContext('2d');
        c.fillStyle = '#ff8800';
        c.fillRect(15, 0, 20, 45); 
        c.fillRect(2, 10, 46, 15); 
        c.fillStyle = '#550000'; c.fillRect(22, 35, 6, 6); 
        return cvs;
    },
    enemy_carrier: () => {
        const cvs = document.createElement('canvas'); cvs.width=80; cvs.height=80;
        const c = cvs.getContext('2d');
        c.fillStyle = '#aa00ff';
        c.fillRect(20, 5, 40, 70); 
        c.fillStyle = '#7700cc';
        c.fillRect(5, 20, 15, 40); c.fillRect(60, 20, 15, 40); 
        c.fillStyle = '#ff0055'; c.beginPath(); c.arc(40, 40, 10, 0, Math.PI*2); c.fill(); 
        return cvs;
    }
};

const Assets = {
    player: AssetFactory.player(),
    speeder: AssetFactory.enemy_speeder(),
    shooter: AssetFactory.enemy_shooter(),
    carrier: AssetFactory.enemy_carrier()
};

// ================= 2. æ¸¸æˆæ ¸å¿ƒç±» =================

class Game {
    constructor() {
        this.state = 'MENU'; 
        this.score = 0;
        this.kills = 0;
        this.frames = 0;
        
        this.player = {
            x: canvas.width / 2, y: canvas.height - 100,
            w: 50, h: 50,
            hp: 100, maxHp: 100,
            speed: 0.15 
        };
        
        this.handTarget = { x: canvas.width/2, y: canvas.height - 100 };
        this.hasHand = false;

        this.bullets = []; 
        this.ebullets = []; 
        this.enemies = [];
        this.particles = []; 
        this.stars = [];     

        for(let i=0; i<80; i++) {
            this.stars.push({
                x: Math.random() * canvas.width,
                y: Math.random() * canvas.height,
                size: Math.random() * 2 + 0.5,
                speed: Math.random() * 3 + 0.5
            });
        }
    }

    start() {
        this.reset();
        this.state = 'PLAYING';
        document.getElementById('start-screen').classList.remove('active');
        document.getElementById('gameover-screen').classList.remove('active');
        gameLoop();
    }

    restart() { this.start(); }

    reset() {
        this.score = 0;
        this.kills = 0;
        this.player.hp = 100;
        this.player.x = canvas.width / 2;
        this.player.y = canvas.height - 100;
        this.bullets = [];
        this.ebullets = [];
        this.enemies = [];
        this.particles = [];
        this.updateUI();
    }

    update() {
        if (!this.hasHand && this.state === 'PLAYING') {
            document.getElementById('pause-overlay').classList.add('visible');
            return; 
        } else {
            document.getElementById('pause-overlay').classList.remove('visible');
        }

        if (this.state !== 'PLAYING') return;

        // ç©å®¶ç§»åŠ¨
        const dx = this.handTarget.x - this.player.x;
        const dy = this.handTarget.y - this.player.y;
        this.player.x += dx * this.player.speed;
        this.player.y += dy * this.player.speed;
        
        this.player.x = Math.max(25, Math.min(canvas.width - 25, this.player.x));
        this.player.y = Math.max(25, Math.min(canvas.height - 25, this.player.y));

        // å°„å‡»
        if (this.frames % 8 === 0) {
            this.bullets.push({ x: this.player.x, y: this.player.y - 30, vx: 0, vy: -12, w: 6, h: 20 });
            this.bullets.push({ x: this.player.x - 15, y: this.player.y - 10, vx: -1, vy: -12, w: 4, h: 15 });
            this.bullets.push({ x: this.player.x + 15, y: this.player.y - 10, vx: 1, vy: -12, w: 4, h: 15 });
        }

        // ç”Ÿæˆæ•Œäºº
        if (this.frames % 50 === 0) this.spawnEnemy();

        this.updateEntities();
        this.frames++;
    }

    spawnEnemy() {
        const rand = Math.random();
        const x = Math.random() * (canvas.width - 60) + 30;
        
        if (rand < 0.5) {
            this.enemies.push({ 
                type: 'speeder', x: x, y: -40, w: 40, h: 40, 
                hp: 3, maxHp: 3, img: Assets.speeder,
                vx: 0, vy: 5, t: 0 
            });
        } else if (rand < 0.8) {
            this.enemies.push({ 
                type: 'shooter', x: x, y: -50, w: 50, h: 50, 
                hp: 6, maxHp: 6, img: Assets.shooter,
                vx: 0, vy: 2, lastShot: this.frames
            });
        } else {
            this.enemies.push({ 
                type: 'carrier', x: x, y: -80, w: 80, h: 80, 
                hp: 25, maxHp: 25, img: Assets.carrier,
                vx: 0, vy: 0.8 
            });
        }
    }

    updateEntities() {
        // ç©å®¶å­å¼¹
        for (let i = this.bullets.length - 1; i >= 0; i--) {
            let b = this.bullets[i];
            b.x += b.vx; b.y += b.vy;
            if (b.y < -20) { this.bullets.splice(i, 1); continue; }

            for (let j = this.enemies.length - 1; j >= 0; j--) {
                let e = this.enemies[j];
                if (this.checkCollide(b, e)) {
                    this.createExplosion(b.x, b.y, 3, '#00ffff');
                    this.bullets.splice(i, 1);
                    e.hp--;
                    if (e.hp <= 0) this.killEnemy(e, j);
                    break;
                }
            }
        }

        // æ•Œäººå­å¼¹
        for (let i = this.ebullets.length - 1; i >= 0; i--) {
            let b = this.ebullets[i];
            b.x += b.vx; b.y += b.vy;
            if (b.y > canvas.height + 20) { this.ebullets.splice(i, 1); continue; }
            if (this.checkCollide(b, this.player)) {
                this.createExplosion(b.x, b.y, 5, '#ff0000');
                this.ebullets.splice(i, 1);
                this.playerDamage(10);
            }
        }

        // æ•Œäºº
        for (let i = this.enemies.length - 1; i >= 0; i--) {
            let e = this.enemies[i];
            if (e.type === 'speeder') { e.t += 0.1; e.x += Math.sin(e.t) * 4; e.y += e.vy; } 
            else { e.y += e.vy; }

            if (e.type === 'shooter' && (this.frames - e.lastShot > 120)) {
                const angle = Math.atan2(this.player.y - e.y, this.player.x - e.x);
                this.ebullets.push({
                    x: e.x, y: e.y + 20,
                    vx: Math.cos(angle) * 4, vy: Math.sin(angle) * 4,
                    w: 8, h: 8, color: '#ff3333'
                });
                e.lastShot = this.frames;
            }

            if (this.checkCollide(e, this.player)) {
                this.createExplosion(e.x, e.y, 20, '#ff0000');
                this.enemies.splice(i, 1);
                this.playerDamage(20);
                continue;
            }
            if (e.y > canvas.height + 50) this.enemies.splice(i, 1);
        }

        this.updateParticles();
        this.stars.forEach(s => { s.y += s.speed; if (s.y > canvas.height) s.y = 0; });
    }

    playerDamage(dmg) {
        this.player.hp -= dmg;
        this.createExplosion(this.player.x, this.player.y, 10, '#ffaa00');
        canvas.style.transform = `translate(${Math.random()*10-5}px, ${Math.random()*10-5}px)`;
        setTimeout(() => canvas.style.transform = 'none', 50);
        this.updateUI();
        if (this.player.hp <= 0) {
            this.state = 'GAMEOVER';
            document.getElementById('final-score').innerText = this.score;
            document.getElementById('final-kills').innerText = this.kills;
            document.getElementById('gameover-screen').classList.add('active');
        }
    }

    killEnemy(e, index) {
        this.createExplosion(e.x, e.y, e.w, '#ffaa00');
        this.enemies.splice(index, 1);
        this.score += (e.type==='carrier' ? 500 : 100);
        this.kills++;
        this.updateUI();
    }

    checkCollide(a, b) {
        return Math.abs(a.x - b.x) < (a.w + b.w)/2.5 && 
               Math.abs(a.y - b.y) < (a.h + b.h)/2.5;
    }

    createExplosion(x, y, size, color) {
        const count = 5 + size/3;
        for(let i=0; i<count; i++) {
            this.particles.push({
                x: x, y: y,
                vx: (Math.random()-0.5)*10, vy: (Math.random()-0.5)*10,
                life: 1.0, color: color, size: Math.random()*4+2
            });
        }
    }

    updateParticles() {
        for(let i = this.particles.length - 1; i >= 0; i--) {
            let p = this.particles[i];
            p.x += p.vx; p.y += p.vy;
            p.life -= 0.05;
            if(p.life <= 0) this.particles.splice(i, 1);
        }
    }

    updateUI() {
        document.getElementById('ui-score').innerText = this.score.toString().padStart(6, '0');
        document.getElementById('ui-hp').style.width = Math.max(0, this.player.hp) + "%";
    }

    draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        // Background
        ctx.fillStyle = '#fff';
        this.stars.forEach(s => {
            ctx.globalAlpha = Math.random() * 0.5 + 0.2;
            ctx.fillRect(s.x, s.y, s.size, s.size);
        });
        ctx.globalAlpha = 1;

        if (this.state === 'PLAYING' || this.state === 'PAUSED') {
            ctx.drawImage(Assets.player, this.player.x - 32, this.player.y - 32);
            
            this.bullets.forEach(b => { ctx.fillStyle = '#00ffff'; ctx.fillRect(b.x - b.w/2, b.y - b.h/2, b.w, b.h); });
            this.ebullets.forEach(b => { ctx.fillStyle = b.color; ctx.beginPath(); ctx.arc(b.x, b.y, 4, 0, Math.PI*2); ctx.fill(); });
            
            this.enemies.forEach(e => {
                ctx.drawImage(e.img, e.x - e.w/2, e.y - e.h/2, e.w, e.h);
                if(e.maxHp > 5) {
                    ctx.fillStyle = 'red'; ctx.fillRect(e.x - 20, e.y - e.h/2 - 10, 40, 4);
                    ctx.fillStyle = '#0f0'; ctx.fillRect(e.x - 20, e.y - e.h/2 - 10, 40 * (e.hp/e.maxHp), 4);
                }
            });

            this.particles.forEach(p => {
                ctx.globalAlpha = p.life; ctx.fillStyle = p.color;
                ctx.beginPath(); ctx.arc(p.x, p.y, p.size, 0, Math.PI*2); ctx.fill();
            });
            ctx.globalAlpha = 1;
        }
    }
}

const game = new Game();

function gameLoop() {
    game.update();
    game.draw();
    if(game.state === 'PLAYING') requestAnimationFrame(gameLoop);
}

// ================= 3. â˜… åŸç”Ÿæ‘„åƒå¤´å¯åŠ¨é€»è¾‘ (ä¿®å¤é»‘å±) â˜… =================
const videoElement = document.getElementById('input-video');
const canvasElement = document.getElementById('output-canvas');
const canvasCtx = canvasElement.getContext('2d');

async function startCamera() {
    try {
        const stream = await navigator.mediaDevices.getUserMedia({ 
            video: { width: 320, height: 240 } 
        });
        videoElement.srcObject = stream;
        videoElement.onloadedmetadata = () => {
            videoElement.play();
            processVideo();
        };
    } catch (err) {
        console.error("Camera Error:", err);
        alert("æ‘„åƒå¤´å¯åŠ¨å¤±è´¥ï¼Œè¯·æ£€æŸ¥æƒé™");
    }
}

async function processVideo() {
    await hands.send({image: videoElement});
    requestAnimationFrame(processVideo);
}

function onResults(results) {
    // ç»˜åˆ¶å°çª—é¢„è§ˆ
    canvasCtx.save();
    canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
    canvasCtx.drawImage(results.image, 0, 0, canvasElement.width, canvasElement.height);
    
    if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
        const landmarks = results.multiHandLandmarks[0];
        
        // ç»˜åˆ¶éª¨æ¶
        drawConnectors(canvasCtx, landmarks, HAND_CONNECTIONS, {color: '#00FF00', lineWidth: 2});
        drawLandmarks(canvasCtx, landmarks, {color: '#FF0000', lineWidth: 1, radius: 2});

        // æ ¸å¿ƒï¼šæ§åˆ¶æ˜ å°„
        const cx = landmarks[9].x; 
        const cy = landmarks[9].y;
        
        game.handTarget.x = (1 - cx) * canvas.width;
        game.handTarget.y = cy * canvas.height;
        game.hasHand = true;
    } else {
        game.hasHand = false;
    }
    canvasCtx.restore();
}

const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
hands.setOptions({maxNumHands: 1, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5});
hands.onResults(onResults);

// å¯åŠ¨ï¼
startCamera();

</script>