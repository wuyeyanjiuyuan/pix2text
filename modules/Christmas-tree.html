<style>
    /* å®¹å™¨æ ·å¼ */
    #tree-container {
        position: relative; width: 100%; height: 600px;
        background: radial-gradient(circle at center, #1a1a2e 0%, #000000 100%); /* æ›´æœ‰æ·±åº¦çš„èƒŒæ™¯ */
        border-radius: 12px; overflow: hidden;
        box-shadow: 0 10px 40px rgba(0,0,0,0.6);
    }
    
    #tree-canvas { 
        width: 100%; height: 100%; display: block; 
        position: absolute; top: 0; left: 0; z-index: 1;
    }
    
    .ui-layer {
        position: absolute; top: 20px; left: 20px; z-index: 10;
        pointer-events: none; 
    }
    
    .status-pill {
        display: inline-block; padding: 8px 16px;
        background: rgba(20, 50, 20, 0.85); 
        border: 1px solid rgba(100, 255, 100, 0.4);
        border-radius: 30px; backdrop-filter: blur(8px);
        font-family: 'Segoe UI', sans-serif; font-size: 14px; 
        color: #50ff50; text-shadow: 0 0 10px rgba(0,255,0,0.5);
        box-shadow: 0 4px 15px rgba(0,0,0,0.4);
        margin-bottom: 12px; transition: all 0.3s;
    }
    
    .upload-btn {
        pointer-events: auto; cursor: pointer;
        display: inline-flex; align-items: center; gap: 8px;
        padding: 10px 20px; 
        background: linear-gradient(135deg, #d32f2f, #b71c1c);
        border: 1px solid rgba(255, 200, 200, 0.3); 
        color: white; font-weight: bold;
        border-radius: 25px; font-size: 14px; 
        box-shadow: 0 4px 12px rgba(255, 0, 0, 0.3);
        transition: transform 0.2s;
    }
    .upload-btn:hover { transform: translateY(-2px); filter: brightness(1.2); }
    #file-input { display: none; }

    .cam-box {
        position: absolute; bottom: 20px; right: 20px;
        width: 120px; height: 90px; border-radius: 8px; overflow: hidden;
        border: 2px solid rgba(255,255,255,0.3); z-index: 10; background: #000;
    }
    #input-video { position: absolute; opacity: 0; pointer-events: none; }
    #output-canvas { width: 100%; height: 100%; transform: scaleX(-1); }
</style>

<div id="tree-container">
    <div class="ui-layer">
        <div id="status-text" class="status-pill">æ­£åœ¨è£…é¥°åœ£è¯æ ‘...</div>
        <br>
        <label class="upload-btn">
            ğŸ“· ä¸Šä¼ ç…§ç‰‡ (åŸç”»è´¨)
            <input type="file" id="file-input" accept="image/*" multiple>
        </label>
        <div style="margin-top:12px; font-size:12px; color:rgba(255,255,255,0.6); line-height:1.6;">
            âœŠ æ¡æ‹³ï¼šèšåˆåœ£è¯æ ‘<br>
            ğŸ‘Œ æåˆï¼šæŠ“å–æœ€è¿‘ç…§ç‰‡
        </div>
    </div>

    <div class="cam-box"><canvas id="output-canvas"></canvas></div>
    <video id="input-video" playsinline></video>
    <div id="tree-canvas"></div>
</div>

<script src="js/three.min.js"></script>
<script src="js/tween.umd.js"></script>
<script src="js/camera_utils.js"></script>
<script src="js/control_utils.js"></script>
<script src="js/drawing_utils.js"></script>
<script src="js/hands.js"></script>

<script>
    console.log(">>> [ChristmasTree] è±ªåç‰ˆå¯åŠ¨");

    try {
        const container = document.getElementById('tree-canvas');
        const statusText = document.getElementById('status-text');
        
        if (!container) throw new Error("å®¹å™¨æœªæ‰¾åˆ°");

        let width = container.clientWidth || 800;
        let height = container.clientHeight || 600;

        // ================= 1. åœºæ™¯åˆå§‹åŒ– =================
        const scene = new THREE.Scene();
        // ææ·¡çš„é›¾æ°”ï¼Œå¢åŠ ç©ºé—´çºµæ·±æ„Ÿ
        scene.fog = new THREE.FogExp2(0x050505, 0.0003); 

        const camera = new THREE.PerspectiveCamera(60, width / height, 1, 5000);
        camera.position.set(0, 50, 900); 

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(width, height);
        renderer.setPixelRatio(window.devicePixelRatio); // é«˜æ¸…å±æ”¯æŒ
        container.appendChild(renderer.domElement);

        // ================= 2. æè´¨ä¸çº¹ç† =================
        
        // 2.1 é‡‘è‰²é—ªå…‰ç²’å­ (Sparkle)
        function createSparkTexture() {
            const cvs = document.createElement('canvas');
            cvs.width = 64; cvs.height = 64;
            const ctx = cvs.getContext('2d');
            const gradient = ctx.createRadialGradient(32, 32, 0, 32, 32, 32);
            // å†…æ ¸ç™½ -> ä¸­å±‚é‡‘ -> å¤–å±‚é€
            gradient.addColorStop(0, 'rgba(255, 255, 255, 1)');
            gradient.addColorStop(0.2, 'rgba(255, 240, 150, 0.9)'); 
            gradient.addColorStop(0.5, 'rgba(255, 200, 50, 0.2)'); 
            gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 64, 64);
            return new THREE.CanvasTexture(cvs);
        }

        // 2.2 èŠ‚æ—¥ Emoji
        function createEmojiTexture(emoji) {
            const cvs = document.createElement('canvas');
            cvs.width = 128; cvs.height = 128;
            const ctx = cvs.getContext('2d');
            ctx.font = '100px serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillStyle = "#ffffff";
            ctx.fillText(emoji, 64, 64);
            return new THREE.CanvasTexture(cvs);
        }

        const sparkTex = createSparkTexture();
        const textures = [
            createEmojiTexture('ğŸ'), createEmojiTexture('ğŸ””'), 
            createEmojiTexture('ğŸ„'), createEmojiTexture('â„ï¸'), 
            createEmojiTexture('â­'), createEmojiTexture('ğŸª')
        ];

        // ================= 3. å‡ ä½•ä½“ï¼šäº”è§’æ˜Ÿæ ‘é¡¶ =================
        
        // ä½¿ç”¨ Shape ç»˜åˆ¶äº”è§’æ˜Ÿ
        function createStarGeometry(radius, thickness) {
            const shape = new THREE.Shape();
            const points = 5;
            for (let i = 0; i < points * 2; i++) {
                const l = i % 2 == 1 ? radius * 0.5 : radius;
                const a = i / points * Math.PI;
                // æ—‹è½¬ä¸€ä¸‹è§’åº¦è®©å°–è§’æœä¸Š
                const angle = a + Math.PI / 2;
                const x = Math.cos(angle) * l;
                const y = Math.sin(angle) * l;
                if (i === 0) shape.moveTo(x, y);
                else shape.lineTo(x, y);
            }
            shape.closePath();
            
            const extrudeSettings = { depth: thickness, bevelEnabled: true, bevelThickness: 2, bevelSize: 1, bevelSegments: 2 };
            return new THREE.ExtrudeGeometry(shape, extrudeSettings);
        }

        const topStar = new THREE.Mesh(
            createStarGeometry(30, 8),
            new THREE.MeshBasicMaterial({ color: 0xffff00 }) // è‡ªå‘å…‰é‡‘é»„
        );
        topStar.position.set(0, 350, 0); // æ ‘é¡¶ä½ç½®
        topStar.visible = false;
        scene.add(topStar);

        // ================= 4. ç²’å­ç³»ç»Ÿæ ¸å¿ƒ =================
        
        const PARTICLE_COUNT = 1000;
        const particles = [];
        const photoParticles = []; 
        const particleGroup = new THREE.Group();
        scene.add(particleGroup);

        // 4.1 åˆå§‹åŒ–æ™®é€šç²’å­
        for (let i = 0; i < PARTICLE_COUNT; i++) {
            // 30% æ¦‚ç‡ç”Ÿæˆé‡‘è‰²å…‰ç‚¹ï¼Œ70% ç”Ÿæˆè£…é¥°ç‰©
            const isSpark = Math.random() < 0.3;
            const tex = isSpark ? sparkTex : textures[Math.floor(Math.random() * textures.length)];
            
            const material = new THREE.SpriteMaterial({ 
                map: tex, 
                color: isSpark ? 0xffdd44 : 0xffffff, // å…‰ç‚¹ç»™ç‚¹é‡‘è‰² tint
                transparent: true,
                opacity: isSpark ? Math.random() * 0.5 + 0.5 : 0.9,
                blending: THREE.AdditiveBlending, // å‘å…‰æ··åˆ
                depthWrite: false
            });
            
            createParticle(material, false, isSpark);
        }

        function createParticle(material, isPhoto, isSpark) {
            const sprite = new THREE.Sprite(material);
            
            // --- A. æ ‘å½¢æ€ (èºæ—‹åœ†é”¥) ---
            const treeHeight = 600;
            const treeRadius = 300;
            const y = (Math.random() - 0.5) * treeHeight; 
            const relY = (y + treeHeight/2) / treeHeight; // 0~1 (åº•~é¡¶)
            // åº•éƒ¨å®½é¡¶éƒ¨å°–ï¼ŒåŠ ç‚¹éšæœºåç§»è®©æ ‘çœ‹èµ·æ¥è“¬æ¾
            const r = treeRadius * Math.pow((1 - relY), 0.8) * (0.8 + Math.random()*0.4); 
            const angle = Math.random() * Math.PI * 2 * 10;
            
            const treePos = new THREE.Vector3(
                Math.cos(angle) * r,
                y,
                Math.sin(angle) * r
            );

            // --- B. æ•£å¼€å½¢æ€ (çƒå½¢ç¯ç»•) ---
            // ä½¿ç”¨çƒé¢åæ ‡éšæœºåˆ†å¸ƒï¼Œä¸å†æ˜¯æ–¹ç›’å­
            const spreadR = 600 + Math.random() * 600; // åŠå¾„ 600~1200
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.acos(2 * Math.random() - 1);
            
            const spreadPos = new THREE.Vector3(
                spreadR * Math.sin(phi) * Math.cos(theta),
                spreadR * Math.sin(phi) * Math.sin(theta),
                spreadR * Math.cos(phi)
            );

            // åˆå§‹è®¾ä¸ºæ•£å¼€
            sprite.position.copy(spreadPos);
            
            // åŸºç¡€å¤§å°
            let baseScale = isSpark ? (Math.random() * 10 + 5) : (Math.random() * 20 + 15);
            if (isPhoto) baseScale = material.userData.aspect ? 50 : 50; // ç…§ç‰‡é»˜è®¤åŸºå‡†50
            
            // å¦‚æœæ˜¯ç…§ç‰‡ï¼Œæ ¹æ®æ¯”ä¾‹è°ƒæ•´ Scale
            if (isPhoto && material.userData.aspect) {
                // ä¿æŒé¢ç§¯å¤§è‡´ç›¸ç­‰ï¼Œé˜²æ­¢é•¿æ¡å›¾å¤ªå°
                sprite.scale.set(baseScale * material.userData.aspect, baseScale, 1);
            } else {
                sprite.scale.set(baseScale, baseScale, 1);
            }

            // æ•°æ®ç»‘å®š
            sprite.userData = {
                treePos: treePos,
                spreadPos: spreadPos,
                baseScale: baseScale, // åŸºç¡€é«˜åº¦
                aspect: material.userData.aspect || 1, // å®½é«˜æ¯”
                isPhoto: isPhoto,
                isSpark: isSpark,
                randomPhase: Math.random() * Math.PI * 2 // é—ªçƒç›¸ä½
            };

            particleGroup.add(sprite);
            particles.push(sprite);
            if (isPhoto) photoParticles.push(sprite);
        }

        // ================= 5. ç…§ç‰‡å¤„ç† (é«˜æ¸… & åŸæ¯”ä¾‹) =================
        const fileInput = document.getElementById('file-input');
        
        fileInput.addEventListener('change', function(e) {
            if (this.files.length > 0) {
                statusText.innerText = `å¤„ç† ${this.files.length} å¼ ç…§ç‰‡...`;
                
                Array.from(this.files).forEach((file, index) => {
                    const reader = new FileReader();
                    reader.onload = function(event) {
                        const img = new Image();
                        img.src = event.target.result;
                        img.onload = () => {
                            // è®¡ç®—å®½é«˜æ¯”
                            const aspect = img.width / img.height;
                            
                            const tex = new THREE.TextureLoader().load(img.src);
                            // ä¼˜åŒ–çº¹ç†è®¾ç½®ï¼Œé˜²æ­¢æ¨¡ç³Š
                            tex.minFilter = THREE.LinearFilter; 
                            
                            // å­˜å…¥ user data ä¼ ç»™æè´¨
                            const matUserData = { aspect: aspect };
                            replaceParticleWithPhoto(tex, matUserData);
                        }
                    };
                    reader.readAsDataURL(file);
                });
                
                setTimeout(() => statusText.innerText = "ç…§ç‰‡å·²æ‚¬æŒ‚ï¼æåˆæ‰‹æŒ‡æŸ¥çœ‹", 1500);
            }
        });

        function replaceParticleWithPhoto(texture, matUserData) {
            // ç…§ç‰‡æè´¨ï¼šä¸å‘å…‰ï¼Œä¿æŒåŸè‰²
            const material = new THREE.SpriteMaterial({ 
                map: texture, 
                color: 0xffffff,
                transparent: true,
                userData: matUserData // ä¼ é€’å®½é«˜æ¯”
            });
            
            // æ›¿æ¢é€»è¾‘
            let idx = Math.floor(Math.random() * particles.length);
            // å°½é‡ä¸æ›¿æ¢å·²æœ‰çš„ç…§ç‰‡å’Œå…‰ç‚¹
            let safety = 0;
            while((particles[idx].userData.isPhoto || particles[idx].userData.isSpark) && safety < 50) {
                idx = Math.floor(Math.random() * particles.length);
                safety++;
            }
            const oldSprite = particles[idx];
            
            createParticle(material, true, false);
            const newSprite = particles[particles.length - 1]; 
            
            newSprite.position.copy(oldSprite.position);
            newSprite.scale.set(0, 0, 1);
            
            particleGroup.remove(oldSprite);
            particles.splice(idx, 1);
            
            // å¼¹çª—åŠ¨ç”»
            const targetH = newSprite.userData.baseScale;
            const targetW = targetH * newSprite.userData.aspect;
            
            new TWEEN.Tween(newSprite.scale)
                .to({ x: targetW, y: targetH }, 800)
                .easing(TWEEN.Easing.Elastic.Out)
                .start();
        }

        // ================= 6. äº¤äº’çŠ¶æ€æ§åˆ¶ (æ™ºèƒ½æŠ“å–) =================
        let currentState = 'spread'; 
        let isPinching = false;
        let activePhoto = null; 

        function toTreeState() {
            if (currentState === 'tree') return;
            currentState = 'tree';
            statusText.innerText = "ğŸ„ åœ£è¯æ ‘å·²èšåˆ";
            topStar.visible = true;

            particles.forEach(p => {
                if (p === activePhoto) return; 
                new TWEEN.Tween(p.position)
                    .to(p.userData.treePos, 1500)
                    .easing(TWEEN.Easing.Exponential.InOut)
                    .start();
            });
        }

        function toSpreadState() {
            if (currentState === 'spread') return;
            currentState = 'spread';
            statusText.innerText = "âœ¨ çƒå½¢ç¯ç»•æ¨¡å¼";
            topStar.visible = false;

            particles.forEach(p => {
                if (p === activePhoto) return;
                new TWEEN.Tween(p.position)
                    .to(p.userData.spreadPos, 2000)
                    .easing(TWEEN.Easing.Cubic.Out)
                    .start();
            });
        }

        // â˜…â˜…â˜… æ ¸å¿ƒï¼šæŠ“å–æœ€è¿‘ç…§ç‰‡ & å±…ä¸­å±•ç¤º â˜…â˜…â˜…
        function grabPhoto() {
            if (isPinching || photoParticles.length === 0) return;
            
            // 1. å¯»æ‰¾ç¦»æ‘„åƒæœºæœ€è¿‘çš„ç…§ç‰‡
            let closestDist = Infinity;
            let closestPhoto = null;
            
            const worldPos = new THREE.Vector3();
            
            photoParticles.forEach(p => {
                // è·å–ä¸–ç•Œåæ ‡ (å› ä¸º Group åœ¨æ—‹è½¬ï¼Œlocalåæ ‡ä¸å‡†)
                p.getWorldPosition(worldPos);
                const d = camera.position.distanceTo(worldPos);
                if(d < closestDist) {
                    closestDist = d;
                    closestPhoto = p;
                }
            });
            
            if(!closestPhoto) return;
            
            isPinching = true;
            activePhoto = closestPhoto;
            
            // 2. â˜… ç©ºé—´å‰¥ç¦» â˜…
            // æŠŠå®ƒä»æ—‹è½¬çš„ particleGroup æ‹¿å‡ºæ¥ï¼Œç›´æ¥æŒ‚åˆ° Scene
            // è¿™æ ·å®ƒå°±ä¸ä¼šè·Ÿç€æ ‘è½¬äº†ï¼Œå¯ä»¥ç¨³ç¨³åœ°åœåœ¨ä¸­é—´
            scene.attach(activePhoto);

            // 3. é£åˆ°é•œå¤´æ­£å‰æ–¹ (Z=600)
            new TWEEN.Tween(activePhoto.position)
                .to({ x: 0, y: 50, z: 600 }, 600)
                .easing(TWEEN.Easing.Back.Out)
                .start();

            // 4. æ”¾å¤§ (æŒ‰æ¯”ä¾‹)
            const targetH = 300; // æ”¾å¤§åçš„é«˜åº¦
            const targetW = targetH * activePhoto.userData.aspect;
            
            new TWEEN.Tween(activePhoto.scale)
                .to({ x: targetW, y: targetH }, 600)
                .easing(TWEEN.Easing.Back.Out)
                .start();
                
            statusText.innerText = "ğŸ–¼ï¸ å›å¿†æ—¶åˆ» (å±…ä¸­å±•ç¤º)";
        }

        function releasePhoto() {
            if (!isPinching || !activePhoto) return;
            isPinching = false;
            
            // 1. æ”¾å› Group
            // å…ˆè®¡ç®—ç›®æ ‡ä½ç½®çš„ä¸–ç•Œåæ ‡ï¼Œå†è½¬å›å±€éƒ¨åæ ‡ï¼Œå¤ªéº»çƒ¦
            // ç›´æ¥ attach å›å»ï¼ŒThree.js ä¼šè‡ªåŠ¨è®¡ç®—å˜æ¢çŸ©é˜µä¿æŒä½ç½®ä¸å˜
            particleGroup.attach(activePhoto);

            // 2. é£å›åŸä½
            const target = currentState === 'tree' ? activePhoto.userData.treePos : activePhoto.userData.spreadPos;
            
            // æ¢å¤åŸå§‹å¤§å°
            const baseH = activePhoto.userData.baseScale;
            const baseW = baseH * activePhoto.userData.aspect;

            new TWEEN.Tween(activePhoto.position).to(target, 800).easing(TWEEN.Easing.Exponential.Out).start();
            new TWEEN.Tween(activePhoto.scale).to({x: baseW, y: baseH}, 800).easing(TWEEN.Easing.Exponential.Out).start();
            
            activePhoto = null;
            statusText.innerText = currentState === 'tree' ? "ğŸ„ åœ£è¯æ ‘" : "âœ¨ æ˜Ÿå…‰";
        }

        // ================= 7. MediaPipe æ‰‹åŠ¿ =================
        const videoElement = document.getElementById('input-video');
        const canvasElement = document.getElementById('output-canvas');
        const canvasCtx = canvasElement.getContext('2d');

        function onResults(results) {
            if(statusText.innerText.includes("åˆå§‹åŒ–")) {
                 statusText.innerText = "å¼•æ“å°±ç»ªï¼Œè¯·ä¸Šä¼ ç…§ç‰‡";
            }
            
            canvasCtx.save();
            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
            canvasCtx.drawImage(results.image, 0, 0, canvasElement.width, canvasElement.height);

            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const landmarks = results.multiHandLandmarks[0];
                drawConnectors(canvasCtx, landmarks, HAND_CONNECTIONS, {color: '#00FF00', lineWidth: 2});
                drawLandmarks(canvasCtx, landmarks, {color: '#FF0000', lineWidth: 1, radius: 2});

                const wrist = landmarks[0];
                const middleTip = landmarks[12];
                const palmDist = Math.sqrt(Math.pow(middleTip.x - wrist.x, 2) + Math.pow(middleTip.y - wrist.y, 2));

                const thumbTip = landmarks[4];
                const indexTip = landmarks[8];
                const pinchDist = Math.sqrt(Math.pow(thumbTip.x - indexTip.x, 2) + Math.pow(thumbTip.y - indexTip.y, 2));

                // æåˆ
                if (pinchDist < 0.05) { 
                    grabPhoto();
                } else {
                    releasePhoto();
                }

                // æ¡æ‹³/å¼ å¼€
                if (!isPinching) {
                    if (palmDist < 0.25) toTreeState(); 
                    else if (palmDist > 0.35) toSpreadState(); 
                }
            }
            canvasCtx.restore();
        }

        const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
        hands.setOptions({maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5});
        hands.onResults(onResults);

        const cameraUtils = new Camera(videoElement, {
            onFrame: async () => { await hands.send({image: videoElement}); },
            width: 320, height: 240
        });
        cameraUtils.start();

        // ================= 8. æ¸²æŸ“å¾ªç¯ =================
        function animate(time) {
            requestAnimationFrame(animate);
            TWEEN.update(time); 

            // æ•´ä½“æ—‹è½¬é€»è¾‘
            if (currentState === 'tree' && !isPinching) {
                // æ ‘å½¢æ€ï¼šç»•Yè½´å•å‘æ—‹è½¬
                particleGroup.rotation.y += 0.005;
                topStar.rotation.y -= 0.02;
            } else if (currentState === 'spread') {
                // æ•£å¼€å½¢æ€ï¼šåƒæ˜Ÿç³»ä¸€æ ·ä¸‰è½´ç¼“æ…¢æ—‹è½¬ï¼Œæ›´æœ‰çƒä½“æ„Ÿ
                particleGroup.rotation.y += 0.001;
                particleGroup.rotation.x = Math.sin(time * 0.0005) * 0.2; // å¾®å¾®ä¸Šä¸‹å€¾æ–œ
            }

            // â˜… é‡‘è‰²å…‰ç‚¹é—ªçƒåŠ¨ç”» â˜…
            const t = time * 0.003;
            particles.forEach(p => {
                if(p.userData.isSpark) {
                    // åˆ©ç”¨ç›¸ä½å·®ï¼Œè®©é—ªçƒä¸åŒæ­¥
                    const alpha = Math.sin(t + p.userData.randomPhase); 
                    // æ˜ å°„åˆ° 0.2 ~ 1.0 çš„é€æ˜åº¦
                    p.material.opacity = 0.6 + alpha * 0.4;
                    // å¾®å¾®ç¼©æ”¾
                    const s = p.userData.baseScale * (0.8 + alpha * 0.3);
                    p.scale.set(s, s, 1);
                }
            });

            renderer.render(scene, camera);
        }
        animate();

        window.addEventListener('resize', () => {
            if(!container) return;
            width = container.clientWidth;
            height = container.clientHeight;
            camera.aspect = width / height;
            camera.updateProjectionMatrix();
            renderer.setSize(width, height);
        });

    } catch (e) {
        console.error(e);
        document.getElementById('status-text').innerText = "âŒ é”™è¯¯: " + e.message;
        document.getElementById('status-text').style.backgroundColor = "red";
    }
</script>