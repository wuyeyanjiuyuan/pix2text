<style>
    /* å®¹å™¨æ ·å¼ */
    #tree-container {
        position: relative; width: 100%; height: 600px;
        /* èƒŒæ™¯æ”¹ä¸ºçº¯é»‘ï¼Œè®©é‡‘è‰²ç²’å­æ›´äº® */
        background: #000000; 
        border-radius: 12px; overflow: hidden;
        box-shadow: 0 10px 40px rgba(0,0,0,0.8);
    }
    
    #tree-canvas { 
        width: 100%; height: 100%; display: block; 
        position: absolute; top: 0; left: 0; z-index: 1;
    }
    
    /* UI å±‚ */
    .ui-layer {
        position: absolute; top: 20px; left: 20px; z-index: 10;
        pointer-events: none; 
    }
    
    .status-pill {
        display: inline-block; padding: 8px 16px;
        background: rgba(255, 215, 0, 0.15); /* é‡‘è‰²åº• */
        border: 1px solid rgba(255, 215, 0, 0.4);
        border-radius: 30px; backdrop-filter: blur(8px);
        font-family: 'Segoe UI', sans-serif; font-size: 14px; 
        color: #ffdd44; text-shadow: 0 0 8px rgba(255, 200, 0, 0.6);
        box-shadow: 0 4px 15px rgba(0,0,0,0.4);
        margin-bottom: 12px; transition: all 0.3s;
    }
    
    .upload-btn {
        pointer-events: auto; cursor: pointer;
        display: inline-flex; align-items: center; gap: 8px;
        padding: 10px 20px; 
        background: linear-gradient(135deg, #d32f2f, #8e0000);
        border: 1px solid rgba(255, 100, 100, 0.3); 
        color: white; font-weight: bold;
        border-radius: 25px; font-size: 14px; 
        box-shadow: 0 4px 12px rgba(200, 0, 0, 0.4);
        transition: transform 0.2s;
    }
    .upload-btn:hover { transform: translateY(-2px); filter: brightness(1.2); }
    #file-input { display: none; }

    .cam-box {
        position: absolute; bottom: 20px; right: 20px;
        width: 120px; height: 90px; border-radius: 8px; overflow: hidden;
        border: 2px solid rgba(255,255,255,0.3); z-index: 10; background: #000;
    }
    #input-video { position: absolute; opacity: 0; pointer-events: none; }
    #output-canvas { width: 100%; height: 100%; transform: scaleX(-1); }
</style>

<div id="tree-container">
    <div class="ui-layer">
        <div id="status-text" class="status-pill">æ­£åœ¨ä»æ˜Ÿå°˜ä¸­æ„å»º...</div>
        <br>
        <label class="upload-btn">
            ğŸ“· æŒ‚ä¸Šç…§ç‰‡
            <input type="file" id="file-input" accept="image/*" multiple>
        </label>
        <div style="margin-top:12px; font-size:12px; color:rgba(255,255,255,0.6); line-height:1.6;">
            âœŠ æ¡æ‹³ï¼šèšåˆåœ£è¯æ ‘<br>
            ğŸ‘Œ æåˆï¼šæŠ“å–ç…§ç‰‡
        </div>
    </div>

    <div class="cam-box"><canvas id="output-canvas"></canvas></div>
    <video id="input-video" playsinline></video>
    <div id="tree-canvas"></div>
</div>

<script src="js/three.min.js"></script>
<script src="js/tween.umd.js"></script>
<script src="js/camera_utils.js"></script>
<script src="js/control_utils.js"></script>
<script src="js/drawing_utils.js"></script>
<script src="js/hands.js"></script>

<script>
    console.log(">>> [ChristmasTree] æå…‰ç‰ˆå¯åŠ¨");

    try {
        const container = document.getElementById('tree-canvas');
        const statusText = document.getElementById('status-text');
        
        if (!container) throw new Error("å®¹å™¨æœªæ‰¾åˆ°");

        let width = container.clientWidth || 800;
        let height = container.clientHeight || 600;

        // ================= 1. åœºæ™¯åˆå§‹åŒ– =================
        const scene = new THREE.Scene();
        // çº¯é»‘èƒŒæ™¯ + ææ·¡çš„é‡‘è‰²é›¾æ°”ï¼Œå¢åŠ é«˜çº§æ„Ÿ
        scene.fog = new THREE.FogExp2(0x000000, 0.001); 

        const camera = new THREE.PerspectiveCamera(60, width / height, 1, 5000);
        camera.position.set(0, 0, 800); // å±…ä¸­å¹³è§†

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(width, height);
        renderer.setPixelRatio(window.devicePixelRatio);
        container.appendChild(renderer.domElement);

        // â˜… ç¯å…‰ç³»ç»Ÿï¼šè®©å‡ ä½•ä½“æœ‰ç«‹ä½“æ„Ÿ
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.2);
        scene.add(ambientLight);
        
        const pointLight = new THREE.PointLight(0xffaa00, 2, 1000); // æ ¸å¿ƒé‡‘å…‰
        pointLight.position.set(0, 0, 0);
        scene.add(pointLight);

        // ================= 2. å‡ ä½•ä½“æè´¨åº“ =================
        
        // æˆ‘ä»¬ä½¿ç”¨ MeshStandardMaterial å¹¶å¼€å¯ emissive (è‡ªå‘å…‰)
        // è¿™æ ·å³ä½¿æ²¡æœ‰å…‰ç…§ï¼Œå®ƒä»¬ä¹Ÿä¼šäº®ï¼Œè€Œä¸”ä¼šæœ‰â€œå…‰æ™•â€çš„æ„Ÿè§‰
        function createGlowingMaterial(color) {
            return new THREE.MeshStandardMaterial({
                color: color,
                emissive: color,     // è‡ªå‘å…‰é¢œè‰²
                emissiveIntensity: 0.8, // å‘å…‰å¼ºåº¦
                roughness: 0.2,
                metalness: 0.8
            });
        }

        const matGold = createGlowingMaterial(0xffaa00);  // é‡‘è‰²
        const matRed = createGlowingMaterial(0xff0033);   // çº¢è‰²
        const matWhite = createGlowingMaterial(0xffffff); // äº®ç™½
        const matGreen = createGlowingMaterial(0x00aa44); // å¢¨ç»¿

        // å‡ ä½•å½¢çŠ¶ï¼šå…«é¢ä½“(åƒé’»çŸ³)ã€æ–¹å—ã€å››é¢ä½“
        const geoDiamond = new THREE.OctahedronGeometry(1, 0); 
        const geoBox = new THREE.BoxGeometry(1, 1, 1);
        const geoTetra = new THREE.TetrahedronGeometry(1);

        // ================= 3. ç²’å­ç³»ç»Ÿæ„å»º =================
        
        const PARTICLE_COUNT = 700; 
        const DUST_COUNT = 400; // è¾…åŠ©æ˜Ÿå°˜æ•°é‡
        
        const TREE_HEIGHT = 500; // ç¨å¾®æ”¹å°ä¸€ç‚¹ï¼Œæ›´ç²¾è‡´
        const TREE_BASE_RADIUS = 250;

        const particleGroup = new THREE.Group();
        const dustGroup = new THREE.Group(); // è¾…åŠ©ç²’å­ç»„
        scene.add(particleGroup);
        scene.add(dustGroup);

        const particles = [];
        const photoParticles = [];
        const dustParticles = [];

        // 3.1 ä¸»ç²’å­ç”Ÿæˆ (æ ‘/çƒ)
        for (let i = 0; i < PARTICLE_COUNT; i++) {
            // éšæœºé€‰æ‹©å½¢çŠ¶å’Œé¢œè‰²
            let geo = Math.random() > 0.5 ? geoDiamond : geoBox;
            let mat;
            const r = Math.random();
            if (r > 0.6) mat = matGold;      // 40% é‡‘è‰²
            else if (r > 0.8) mat = matRed;  // 20% çº¢è‰²
            else if (r > 0.95) mat = matWhite;// 5% ç™½è‰²é«˜å…‰
            else mat = matGreen;             // 35% ç»¿è‰²åº•

            const mesh = new THREE.Mesh(geo, mat);
            createParticle(mesh, false);
        }

        // 3.2 è¾…åŠ©æ˜Ÿå°˜ç”Ÿæˆ (æ°¸è¿œæ¼‚æµ®åœ¨å‘¨å›´çš„å°ç‚¹)
        // è¿™äº›ç²’å­åªè´Ÿè´£è¥é€ æ°›å›´ï¼Œä¸å‚ä¸èšåˆ
        for (let i = 0; i < DUST_COUNT; i++) {
            const mesh = new THREE.Mesh(geoTetra, matGold);
            // éšæœºåˆ†å¸ƒåœ¨çƒä½“å¤–éƒ¨
            const dist = 400 + Math.random() * 400;
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.acos(2 * Math.random() - 1);
            
            mesh.position.set(
                dist * Math.sin(phi) * Math.cos(theta),
                dist * Math.sin(phi) * Math.sin(theta),
                dist * Math.cos(phi)
            );
            
            // å¾ˆå°
            const s = Math.random() * 3 + 1;
            mesh.scale.set(s, s, s);
            
            // éšæœºç›¸ä½ï¼Œç”¨äºé—ªçƒåŠ¨ç”»
            mesh.userData = {
                phase: Math.random() * Math.PI * 2,
                speed: Math.random() * 0.02 + 0.01
            };
            
            dustGroup.add(mesh);
            dustParticles.push(mesh);
        }

        // æ ‘é¡¶å¤§æ˜Ÿæ˜Ÿ
        const topStar = new THREE.Mesh(
            new THREE.OctahedronGeometry(20, 0),
            new THREE.MeshBasicMaterial({ color: 0xffff88 }) 
        );
        topStar.position.set(0, TREE_HEIGHT/2 + 20, 0);
        topStar.visible = false; 
        scene.add(topStar);

        // --- æ ¸å¿ƒç²’å­ç”Ÿæˆé€»è¾‘ ---
        function createParticle(mesh, isPhoto) {
            // 1. è®¡ç®—ã€æ ‘å½¢æ€ã€‘åæ ‡ (ä¸¥æ ¼å±…ä¸­)
            // y ä» -250 åˆ° 250
            const y = (Math.random() - 0.5) * TREE_HEIGHT; 
            const relY = (y + TREE_HEIGHT/2) / TREE_HEIGHT; // 0~1
            // èºæ—‹å‚æ•°
            const radius = TREE_BASE_RADIUS * Math.pow((1 - relY), 0.7) * (0.8 + Math.random()*0.4); 
            const angle = Math.random() * Math.PI * 2 * 10;
            
            const treePos = new THREE.Vector3(
                Math.cos(angle) * radius,
                y, // è¿™æ · y å°±æ˜¯ä»¥ 0 ä¸ºä¸­å¿ƒä¸Šä¸‹åˆ†å¸ƒçš„
                Math.sin(angle) * radius
            );

            // 2. è®¡ç®—ã€çƒå½¢æ€ã€‘åæ ‡ (ç´§å‡‘å°çƒ)
            // ä½ çš„éœ€æ±‚ï¼šæ¯”å±å¹•å°ï¼Œèƒ½çœ‹å‡ºæ¥æ˜¯çƒ
            const sphereR = 350; // åŠå¾„ 350ï¼Œåœ¨ Z=800 çš„ç›¸æœºé‡Œçœ‹èµ·æ¥å¾ˆèˆ’æœ
            // å‡åŒ€çƒé¢åˆ†å¸ƒç®—æ³•
            const u = Math.random();
            const v = Math.random();
            const theta = 2 * Math.PI * u;
            const phi = Math.acos(2 * v - 1);
            
            const spreadPos = new THREE.Vector3(
                sphereR * Math.sin(phi) * Math.cos(theta),
                sphereR * Math.sin(phi) * Math.sin(theta),
                sphereR * Math.cos(phi)
            );

            // åˆå§‹è®¾ä¸ºæ•£å¼€
            mesh.position.copy(spreadPos);
            
            // å¤§å°
            let baseScale = isPhoto ? 40 : (Math.random() * 10 + 5);
            // ç…§ç‰‡ä¿æŒæ¯”ä¾‹
            if (isPhoto && mesh.userData.aspect) {
                mesh.scale.set(baseScale * mesh.userData.aspect, baseScale, 1);
            } else {
                mesh.scale.set(baseScale, baseScale, baseScale);
            }
            
            // éšæœºæ—‹è½¬
            mesh.rotation.set(Math.random()*3, Math.random()*3, Math.random()*3);

            // æ•°æ®ç»‘å®š
            mesh.userData.treePos = treePos;
            mesh.userData.spreadPos = spreadPos;
            mesh.userData.baseScale = baseScale;
            mesh.userData.isPhoto = isPhoto;
            mesh.userData.aspect = mesh.userData.aspect || 1;
            // â˜… é—ªçƒå‚æ•°ï¼šphase(ç›¸ä½), speed(é—ªçƒé€Ÿåº¦)
            mesh.userData.blinkPhase = Math.random() * Math.PI * 2;
            mesh.userData.blinkSpeed = Math.random() * 2 + 1; // 1~3å€é€Ÿ

            particleGroup.add(mesh);
            particles.push(mesh);
            if (isPhoto) photoParticles.push(mesh);
        }

        // ================= 4. ç…§ç‰‡ä¸Šä¼  (é«˜æ¸… & åŸæ¯”ä¾‹) =================
        const fileInput = document.getElementById('file-input');
        
        fileInput.addEventListener('change', function(e) {
            if (this.files.length > 0) {
                statusText.innerText = `åŠ è½½ ${this.files.length} å¼ ç…§ç‰‡...`;
                
                Array.from(this.files).forEach((file) => {
                    const reader = new FileReader();
                    reader.onload = function(event) {
                        const img = new Image();
                        img.src = event.target.result;
                        img.onload = () => {
                            const aspect = img.width / img.height;
                            const tex = new THREE.TextureLoader().load(img.src);
                            tex.minFilter = THREE.LinearFilter; 
                            
                            // ç”¨ MeshBasicMaterial ä¿è¯ç…§ç‰‡ä¸è¢«å…‰ç…§æŸ“é»‘
                            const mat = new THREE.MeshBasicMaterial({ 
                                map: tex, 
                                side: THREE.DoubleSide
                            });
                            
                            // ç…§ç‰‡ç”¨ PlaneGeometry (æ‰å¹³çš„)
                            const geo = new THREE.PlaneGeometry(1, 1);
                            const mesh = new THREE.Mesh(geo, mat);
                            mesh.userData.aspect = aspect; // å­˜æ¯”ä¾‹
                            
                            replaceParticleWithPhoto(mesh);
                        }
                    };
                    reader.readAsDataURL(file);
                });
                
                setTimeout(() => statusText.innerText = "ç…§ç‰‡å·²æŒ‚è½½ï¼æåˆæ‰‹æŒ‡æŸ¥çœ‹", 1500);
            }
        });

        function replaceParticleWithPhoto(newMesh) {
            // æ‰¾ä¸€ä¸ªéç…§ç‰‡çš„æ™®é€šç²’å­æ›¿æ¢æ‰
            let idx = Math.floor(Math.random() * particles.length);
            let safety = 0;
            while(particles[idx].userData.isPhoto && safety < 100) {
                idx = Math.floor(Math.random() * particles.length);
                safety++;
            }
            const oldMesh = particles[idx];
            
            // æ”¾å…¥ç³»ç»Ÿ
            createParticle(newMesh, true);
            const addedMesh = particles[particles.length - 1];
            
            // ç»§æ‰¿ä½ç½®å¹¶åšåŠ¨ç”»
            addedMesh.position.copy(oldMesh.position);
            addedMesh.scale.set(0,0,0);
            
            particleGroup.remove(oldMesh);
            particles.splice(idx, 1);
            
            // å¼¹å‡ºåŠ¨ç”»
            const h = addedMesh.userData.baseScale;
            const w = h * addedMesh.userData.aspect;
            new TWEEN.Tween(addedMesh.scale).to({x:w, y:h, z:1}, 600).easing(TWEEN.Easing.Elastic.Out).start();
        }

        // ================= 5. äº¤äº’çŠ¶æ€æ§åˆ¶ (æ™ºèƒ½æŠ“å–) =================
        let currentState = 'spread'; 
        let isPinching = false;
        let activePhoto = null; 

        function toTreeState() {
            if (currentState === 'tree') return;
            currentState = 'tree';
            statusText.innerText = "ğŸ„ åœ£è¯æ ‘å·²èšåˆ";
            statusText.style.color = "#ffff00";
            topStar.visible = true;

            particles.forEach(p => {
                if (p === activePhoto) return; 
                new TWEEN.Tween(p.position)
                    .to(p.userData.treePos, 1500)
                    .easing(TWEEN.Easing.Exponential.InOut)
                    .start();
            });
        }

        function toSpreadState() {
            if (currentState === 'spread') return;
            currentState = 'spread';
            statusText.innerText = "âœ¨ æ˜Ÿå°˜çƒä½“æ¨¡å¼";
            statusText.style.color = "#50ff50";
            topStar.visible = false;

            particles.forEach(p => {
                if (p === activePhoto) return;
                new TWEEN.Tween(p.position)
                    .to(p.userData.spreadPos, 2000)
                    .easing(TWEEN.Easing.Cubic.Out)
                    .start();
            });
        }

        // æ™ºèƒ½æŠ“å–ï¼šæŠ“å–ç¦»é•œå¤´æœ€è¿‘çš„
        function grabPhoto() {
            if (isPinching || photoParticles.length === 0) return;
            
            let closestDist = Infinity;
            let closestPhoto = null;
            const worldPos = new THREE.Vector3();
            
            photoParticles.forEach(p => {
                p.getWorldPosition(worldPos);
                const d = camera.position.distanceTo(worldPos);
                if(d < closestDist) {
                    closestDist = d;
                    closestPhoto = p;
                }
            });
            
            if(!closestPhoto) return;
            
            isPinching = true;
            activePhoto = closestPhoto;
            
            // å‰¥ç¦»çˆ¶çº§ï¼ŒæŒ‚åˆ° Sceneï¼Œä¿è¯ç»å¯¹å±…ä¸­ï¼Œä¸éšæ ‘æ—‹è½¬
            scene.attach(activePhoto);

            // é£åˆ°æ­£å‰æ–¹
            new TWEEN.Tween(activePhoto.position)
                .to({ x: 0, y: 0, z: 600 }, 600)
                .easing(TWEEN.Easing.Back.Out)
                .start();

            // æ—‹è½¬å½’é›¶ (æ­£å¯¹å±å¹•)
            new TWEEN.Tween(activePhoto.rotation)
                .to({ x: 0, y: 0, z: 0 }, 600)
                .start();

            // æ”¾å¤§
            const targetH = 300; 
            const targetW = targetH * activePhoto.userData.aspect;
            new TWEEN.Tween(activePhoto.scale)
                .to({ x: targetW, y: targetH, z: 1 }, 600)
                .easing(TWEEN.Easing.Back.Out)
                .start();
                
            statusText.innerText = "ğŸ–¼ï¸ å›å¿†æ—¶åˆ»";
        }

        function releasePhoto() {
            if (!isPinching || !activePhoto) return;
            isPinching = false;
            
            // æ”¾å› Group
            particleGroup.attach(activePhoto);

            const target = currentState === 'tree' ? activePhoto.userData.treePos : activePhoto.userData.spreadPos;
            const h = activePhoto.userData.baseScale;
            const w = h * activePhoto.userData.aspect;

            new TWEEN.Tween(activePhoto.position).to(target, 800).easing(TWEEN.Easing.Exponential.Out).start();
            new TWEEN.Tween(activePhoto.scale).to({x: w, y: h, z: 1}, 800).easing(TWEEN.Easing.Exponential.Out).start();
            
            activePhoto = null;
            statusText.innerText = currentState === 'tree' ? "ğŸ„ åœ£è¯æ ‘" : "âœ¨ æ˜Ÿå°˜";
        }

        // ================= 6. MediaPipe æ‰‹åŠ¿ =================
        const videoElement = document.getElementById('input-video');
        const canvasElement = document.getElementById('output-canvas');
        const canvasCtx = canvasElement.getContext('2d');

        function onResults(results) {
            if(statusText.innerText.includes("åˆå§‹åŒ–")) {
                 statusText.innerText = "å¼•æ“å°±ç»ªï¼Œè¯·ä¸Šä¼ ç…§ç‰‡";
            }
            
            canvasCtx.save();
            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
            canvasCtx.drawImage(results.image, 0, 0, canvasElement.width, canvasElement.height);

            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const landmarks = results.multiHandLandmarks[0];
                drawConnectors(canvasCtx, landmarks, HAND_CONNECTIONS, {color: '#00FF00', lineWidth: 2});
                drawLandmarks(canvasCtx, landmarks, {color: '#FF0000', lineWidth: 1, radius: 2});

                const wrist = landmarks[0];
                const middleTip = landmarks[12];
                const palmDist = Math.sqrt(Math.pow(middleTip.x - wrist.x, 2) + Math.pow(middleTip.y - wrist.y, 2));

                const thumbTip = landmarks[4];
                const indexTip = landmarks[8];
                const pinchDist = Math.sqrt(Math.pow(thumbTip.x - indexTip.x, 2) + Math.pow(thumbTip.y - indexTip.y, 2));

                if (pinchDist < 0.05) grabPhoto();
                else releasePhoto();

                if (!isPinching) {
                    if (palmDist < 0.25) toTreeState(); 
                    else if (palmDist > 0.35) toSpreadState(); 
                }
            }
            canvasCtx.restore();
        }

        const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
        hands.setOptions({maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5});
        hands.onResults(onResults);

        const cameraUtils = new Camera(videoElement, {
            onFrame: async () => { await hands.send({image: videoElement}); },
            width: 320, height: 240
        });
        cameraUtils.start();

        // ================= 7. æ¸²æŸ“å¾ªç¯ (æ ¸å¿ƒåŠ¨ç”») =================
        function animate(time) {
            requestAnimationFrame(animate);
            TWEEN.update(time); 

            // A. æ•´ä½“æ—‹è½¬é€»è¾‘
            if (currentState === 'tree' && !isPinching) {
                particleGroup.rotation.y += 0.005; // æ ‘è‡ªè½¬
                topStar.rotation.y -= 0.02;
            } else if (currentState === 'spread') {
                particleGroup.rotation.y += 0.001;
                particleGroup.rotation.x = Math.sin(time * 0.0005) * 0.1; // å¾®å¾®æ™ƒåŠ¨
            }
            
            // è¾…åŠ©æ˜Ÿå°˜åå‘æ…¢è½¬
            dustGroup.rotation.y -= 0.0005;

            // B. â˜…â˜…â˜… ç²’å­é—ªçƒä¸è‡ªè½¬ (Twinkle) â˜…â˜…â˜…
            // éå†æ‰€æœ‰ç²’å­ï¼Œè®©å®ƒä»¬â€œå‘¼å¸â€
            particles.forEach(p => {
                if (!p.userData.isPhoto) { // ç…§ç‰‡ä¸é—ª
                    // è®¡ç®—é—ªçƒå› å­ (Sine Wave)
                    const pulse = Math.sin(time * 0.003 * p.userData.blinkSpeed + p.userData.blinkPhase);
                    
                    // æ”¹å˜å‘å…‰å¼ºåº¦ (0.5 ~ 1.5)
                    // æ³¨æ„ï¼šMeshStandardMaterial çš„ emissiveIntensity å±æ€§
                    if (p.material.emissiveIntensity !== undefined) {
                        p.material.emissiveIntensity = 0.8 + pulse * 0.4;
                    }
                    
                    // æ”¹å˜å¤§å° (0.8 ~ 1.2 å€) - äº§ç”Ÿè·³åŠ¨æ„Ÿ
                    const s = p.userData.baseScale * (1 + pulse * 0.2);
                    p.scale.set(s, s, s);
                    
                    // è‡ªèº«æ—‹è½¬
                    p.rotation.x += 0.01;
                    p.rotation.y += 0.01;
                }
            });

            renderer.render(scene, camera);
        }
        animate();

        window.addEventListener('resize', () => {
            if(!container) return;
            width = container.clientWidth;
            height = container.clientHeight;
            camera.aspect = width / height;
            camera.updateProjectionMatrix();
            renderer.setSize(width, height);
        });

    } catch (e) {
        console.error(e);
        document.getElementById('status-text').innerText = "âŒ é”™è¯¯: " + e.message;
        document.getElementById('status-text').style.backgroundColor = "red";
    }
</script>