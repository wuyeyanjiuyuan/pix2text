<style>
    #tree-container {
        position: relative; width: 100%; height: 600px;
        background: #000; border-radius: 12px; overflow: hidden;
        box-shadow: 0 10px 30px rgba(0,0,0,0.2);
    }
    #three-canvas { width: 100%; height: 100%; display: block; }
    
    /* UI å±‚ */
    .ui-layer {
        position: absolute; top: 20px; left: 20px; z-index: 10;
        pointer-events: none; /* è®©é¼ æ ‡ç©¿é€ï¼Œä¸å½±å“æ‹–æ‹½ */
    }
    .status-pill {
        display: inline-block; padding: 8px 16px;
        background: rgba(20, 40, 20, 0.8); border: 1px solid rgba(100, 255, 100, 0.3);
        border-radius: 30px; backdrop-filter: blur(5px);
        font-family: 'Segoe UI', sans-serif; font-size: 14px; color: #50ff50;
        box-shadow: 0 4px 15px rgba(0,0,0,0.3);
        margin-bottom: 10px; transition: all 0.3s;
    }
    
    /* æ‘„åƒå¤´é¢„è§ˆ */
    .cam-box {
        position: absolute; bottom: 20px; right: 20px;
        width: 120px; height: 90px; border-radius: 8px; overflow: hidden;
        border: 2px solid rgba(255,255,255,0.2); z-index: 10; background: #000;
    }
    #input-video { position: absolute; opacity: 0; pointer-events: none; }
    #output-canvas { width: 100%; height: 100%; transform: scaleX(-1); }

    /* ç…§ç‰‡ä¸Šä¼ æŒ‰é’® */
    .upload-btn {
        pointer-events: auto; cursor: pointer;
        display: inline-flex; align-items: center; gap: 8px;
        padding: 8px 16px; background: rgba(255, 255, 255, 0.15);
        border: 1px solid rgba(255, 255, 255, 0.3); color: white;
        border-radius: 20px; font-size: 13px; transition: 0.2s;
    }
    .upload-btn:hover { background: rgba(255, 255, 255, 0.3); }
    #file-input { display: none; }
</style>

<div id="tree-container">
    <div class="ui-layer">
        <div id="status-text" class="status-pill">æ­£åœ¨è£…é¥°åœ£è¯æ ‘...</div>
        <br>
        <label class="upload-btn">
            ğŸ“· æ·»åŠ ç…§ç‰‡
            <input type="file" id="file-input" accept="image/*" multiple>
        </label>
        <div style="margin-top:10px; font-size:12px; color:rgba(255,255,255,0.6);">
            âœŠ æ¡æ‹³ï¼šèšåˆåœ£è¯æ ‘ | ğŸ‘Œ æåˆï¼šæŠ“å–ç…§ç‰‡æ”¾å¤§
        </div>
    </div>

    <div class="cam-box"><canvas id="output-canvas"></canvas></div>
    <video id="input-video" playsinline></video>
    <div id="three-canvas"></div>
</div>

<script src="js/three.min.js"></script>
<script src="js/tween.umd.js"></script> <script src="js/camera_utils.js"></script>
<script src="js/control_utils.js"></script>
<script src="js/drawing_utils.js"></script>
<script src="js/hands.js"></script>

<script>
    const container = document.getElementById('tree-canvas');
    const statusText = document.getElementById('status-text');
    let width = container.clientWidth;
    let height = container.clientHeight;

    // ================= 1. åˆå§‹åŒ–åœºæ™¯ =================
    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x000000, 0.0008); // é»‘è‰²è¿·é›¾èƒŒæ™¯

    const camera = new THREE.PerspectiveCamera(60, width / height, 1, 5000);
    camera.position.set(0, 100, 800);

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(width, height);
    renderer.setPixelRatio(window.devicePixelRatio);
    container.appendChild(renderer.domElement);

    // ç¯å…‰
    const ambientLight = new THREE.AmbientLight(0x404040);
    scene.add(ambientLight);
    const pointLight = new THREE.PointLight(0xffffff, 1, 1000);
    pointLight.position.set(0, 200, 200);
    scene.add(pointLight);

    // ================= 2. ç²’å­ç³»ç»Ÿæ ¸å¿ƒé€»è¾‘ =================
    
    // ç²’å­é…ç½®
    const PARTICLE_COUNT = 800; // ç²’å­æ€»æ•°
    const TREE_HEIGHT = 600;
    const TREE_BASE_RADIUS = 300;
    
    // æè´¨æ± ï¼šç”Ÿæˆ Emoji è´´å›¾
    function createEmojiTexture(emoji) {
        const cvs = document.createElement('canvas');
        cvs.width = 64; cvs.height = 64;
        const ctx = cvs.getContext('2d');
        ctx.font = '48px serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(emoji, 32, 32);
        return new THREE.CanvasTexture(cvs);
    }
    
    const textures = [
        createEmojiTexture('ğŸ'), createEmojiTexture('ğŸ””'), 
        createEmojiTexture('ğŸ„'), createEmojiTexture('ğŸ…'),
        createEmojiTexture('â„ï¸'), createEmojiTexture('â­'),
        new THREE.TextureLoader().load('https://raw.githubusercontent.com/mrdoob/three.js/master/examples/textures/sprites/spark1.png') // æ™®é€šå…‰ç‚¹
    ];

    // å­˜å‚¨æ‰€æœ‰ç²’å­å¯¹è±¡
    const particles = [];
    const photoParticles = []; // ä¸“é—¨å­˜ç…§ç‰‡ç²’å­
    const particleGroup = new THREE.Group();
    scene.add(particleGroup);

    // æ ‘é¡¶ä¹‹æ˜Ÿ (å•ç‹¬åˆ›å»º)
    const topStarGeo = new THREE.SphereGeometry(20, 16, 16);
    const topStarMat = new THREE.MeshBasicMaterial({ color: 0xffff00 });
    const topStar = new THREE.Mesh(topStarGeo, topStarMat);
    topStar.position.set(0, TREE_HEIGHT/2 + 20, 0);
    topStar.visible = false; // åˆå§‹éšè—ï¼Œæ¡æ‹³æ—¶æ˜¾ç¤º
    scene.add(topStar);
    // æ˜Ÿæ˜Ÿå‘å…‰
    const starLight = new THREE.PointLight(0xffff00, 2, 300);
    topStar.add(starLight);

    // åˆå§‹åŒ–ç²’å­
    function initParticles() {
        for (let i = 0; i < PARTICLE_COUNT; i++) {
            // éšæœºåˆ†é…ä¸€ä¸ªæè´¨
            const tex = textures[Math.floor(Math.random() * textures.length)];
            const material = new THREE.SpriteMaterial({ 
                map: tex, 
                color: 0xffffff,
                transparent: true,
                opacity: 0.9
            });
            const sprite = new THREE.Sprite(material);
            
            // 1. è®¡ç®—ã€æ ‘å½¢æ€ã€‘çš„ç›®æ ‡ä½ç½® (èºæ—‹ä¸Šå‡)
            const y = (Math.random() - 0.5) * TREE_HEIGHT; // -300 ~ 300
            const relY = (y + TREE_HEIGHT/2) / TREE_HEIGHT; // 0 ~ 1 (ä»åº•åˆ°é¡¶)
            const radius = TREE_BASE_RADIUS * (1 - relY); // åº•éƒ¨å®½ï¼Œé¡¶éƒ¨å°–
            const angle = Math.random() * Math.PI * 2 * 5; // èºæ—‹åœˆæ•°
            
            const targetX = Math.cos(angle) * radius;
            const targetY = y;
            const targetZ = Math.sin(angle) * radius;

            // 2. è®¡ç®—ã€æ•£å¼€å½¢æ€ã€‘çš„ä½ç½® (å…¨å±éšæœº)
            const spreadX = (Math.random() - 0.5) * 2000;
            const spreadY = (Math.random() - 0.5) * 1200;
            const spreadZ = (Math.random() - 0.5) * 1000;

            // åˆå§‹ä½ç½®è®¾ä¸ºæ•£å¼€
            sprite.position.set(spreadX, spreadY, spreadZ);
            
            // ç¼©æ”¾å¤§å°
            const scale = Math.random() * 20 + 15;
            sprite.scale.set(scale, scale, 1);

            // å­˜å…¥è‡ªå®šä¹‰æ•°æ®ï¼Œæ–¹ä¾¿åŠ¨ç”»è°ƒç”¨
            sprite.userData = {
                treePos: new THREE.Vector3(targetX, targetY, targetZ),
                spreadPos: new THREE.Vector3(spreadX, spreadY, spreadZ),
                baseScale: scale,
                isPhoto: false
            };

            particleGroup.add(sprite);
            particles.push(sprite);
        }
    }
    initParticles();

    // ================= 3. ç…§ç‰‡ä¸Šä¼ ä¸å¤„ç† =================
    const fileInput = document.getElementById('file-input');
    
    fileInput.addEventListener('change', function(e) {
        if (this.files.length > 0) {
            Array.from(this.files).forEach(file => {
                const reader = new FileReader();
                reader.onload = function(event) {
                    const img = new Image();
                    img.src = event.target.result;
                    const tex = new THREE.TextureLoader().load(img.src);
                    addPhotoParticle(tex);
                };
                reader.readAsDataURL(file);
            });
            statusText.innerText = `å·²æ·»åŠ  ${this.files.length} å¼ ç…§ç‰‡`;
        }
    });

    function addPhotoParticle(texture) {
        // åˆ›å»ºç…§ç‰‡ç²’å­
        const material = new THREE.SpriteMaterial({ map: texture, color: 0xffffff });
        const sprite = new THREE.Sprite(material);
        
        // éšæœºæ›¿æ¢æ‰ä¸€ä¸ªç°æœ‰çš„æ™®é€šç²’å­ï¼ˆä¿æŒæ€»æ•°ä¸å˜ï¼Œä¼˜åŒ–æ€§èƒ½ï¼‰
        // æˆ–è€…ç›´æ¥åŠ è¿›å»ä¹Ÿå¯ä»¥
        const replaceIdx = Math.floor(Math.random() * particles.length);
        const oldSprite = particles[replaceIdx];
        
        // ç»§æ‰¿æ—§ç²’å­çš„ä½ç½®æ•°æ®
        sprite.userData = oldSprite.userData;
        sprite.userData.isPhoto = true; // æ ‡è®°ä¸ºç…§ç‰‡
        sprite.userData.baseScale = 40; // ç…§ç‰‡ç¨å¾®å¤§ä¸€ç‚¹
        sprite.position.copy(oldSprite.position);
        sprite.scale.set(0, 0, 1); // åˆå§‹ä¸º0ï¼Œåšä¸€ä¸ªå¼¹å‡ºåŠ¨ç”»

        particleGroup.remove(oldSprite);
        particles[replaceIdx] = sprite; // æ›¿æ¢æ•°ç»„å¼•ç”¨
        particleGroup.add(sprite);
        
        // å¼¹å‡ºåŠ¨ç”»
        new TWEEN.Tween(sprite.scale)
            .to({ x: 40, y: 40 }, 500)
            .easing(TWEEN.Easing.Back.Out)
            .start();
            
        photoParticles.push(sprite);
    }

    // ================= 4. çŠ¶æ€æ§åˆ¶ä¸æ‰‹åŠ¿é€»è¾‘ =================
    
    let currentState = 'spread'; // 'spread' (å¼ å¼€) | 'tree' (æ¡æ‹³) | 'pinch' (æåˆæŸ¥çœ‹)
    let isPinching = false;
    let activePhoto = null; // å½“å‰æ­£åœ¨æŸ¥çœ‹çš„ç…§ç‰‡

    // åˆ‡æ¢åˆ°ã€åœ£è¯æ ‘å½¢æ€ã€‘
    function toTreeState() {
        if (currentState === 'tree') return;
        currentState = 'tree';
        statusText.innerText = "ğŸ„ åœ£è¯æ ‘æ¨¡å¼ (æ—‹è½¬ä¸­)";
        topStar.visible = true;

        particles.forEach(p => {
            if (p === activePhoto) return; // æ­£åœ¨æŸ¥çœ‹çš„ç…§ç‰‡ä¸å½’ä½
            new TWEEN.Tween(p.position)
                .to({ x: p.userData.treePos.x, y: p.userData.treePos.y, z: p.userData.treePos.z }, 1500)
                .easing(TWEEN.Easing.Exponential.InOut)
                .start();
        });
    }

    // åˆ‡æ¢åˆ°ã€æ•£å¼€å½¢æ€ã€‘
    function toSpreadState() {
        if (currentState === 'spread') return;
        currentState = 'spread';
        statusText.innerText = "âœ¨ è‡ªç”±ç²’å­æ¨¡å¼";
        topStar.visible = false;

        particles.forEach(p => {
            if (p === activePhoto) return;
            new TWEEN.Tween(p.position)
                .to({ x: p.userData.spreadPos.x, y: p.userData.spreadPos.y, z: p.userData.spreadPos.z }, 2000)
                .easing(TWEEN.Easing.Cubic.Out)
                .start();
        });
    }

    // è§¦å‘ã€æŠ“å–ç…§ç‰‡ã€‘åŠ¨ä½œ
    function grabPhoto() {
        if (isPinching || photoParticles.length === 0) return;
        isPinching = true;
        
        // éšæœºé€‰ä¸€å¼ ç…§ç‰‡
        activePhoto = photoParticles[Math.floor(Math.random() * photoParticles.length)];
        
        // æŠŠå®ƒç§»åˆ°ç›¸æœºæ­£å‰æ–¹ï¼Œå¹¶æ”¾å¤§
        // ç›¸æœºåœ¨ (0, 100, 800)ï¼Œæˆ‘ä»¬æ”¾åˆ° (0, 100, 600)
        new TWEEN.Tween(activePhoto.position)
            .to({ x: 0, y: 100, z: 600 }, 800)
            .easing(TWEEN.Easing.Elastic.Out)
            .start();

        new TWEEN.Tween(activePhoto.scale)
            .to({ x: 300, y: 300 }, 800) // æ”¾å¤§
            .easing(TWEEN.Easing.Elastic.Out)
            .start();
            
        // ç»™å®ƒåŠ ä¸ªå…‰æ™•ç¯ (å¯é€‰é«˜é˜¶æ•ˆæœï¼Œæš‚æ—¶ç”¨é¢œè‰²äº®åº¦ä»£æ›¿)
        activePhoto.material.color.setHex(0xffaaaa); // ç¨å¾®å˜çº¢æç¤ºè¢«é€‰ä¸­
        statusText.innerText = "ğŸ–¼ï¸ æ­£åœ¨æŸ¥çœ‹ç…§ç‰‡";
    }

    // é‡Šæ”¾ã€æŠ“å–ç…§ç‰‡ã€‘
    function releasePhoto() {
        if (!isPinching || !activePhoto) return;
        isPinching = false;
        
        // æ¢å¤é¢œè‰²
        activePhoto.material.color.setHex(0xffffff);

        // é£å›å®ƒåº”è¯¥åœ¨çš„ä½ç½® (æ ¹æ®å½“å‰æ˜¯æ ‘è¿˜æ˜¯æ•£å¼€)
        const target = currentState === 'tree' ? activePhoto.userData.treePos : activePhoto.userData.spreadPos;
        const scale = activePhoto.userData.baseScale;

        new TWEEN.Tween(activePhoto.position).to(target, 1000).easing(TWEEN.Easing.Back.Out).start();
        new TWEEN.Tween(activePhoto.scale).to({x: scale, y: scale}, 1000).easing(TWEEN.Easing.Back.Out).start();
        
        activePhoto = null;
        statusText.innerText = currentState === 'tree' ? "ğŸ„ åœ£è¯æ ‘æ¨¡å¼" : "âœ¨ è‡ªç”±ç²’å­æ¨¡å¼";
    }


    // ================= 5. MediaPipe æ‰‹åŠ¿è¯†åˆ« =================
    const videoElement = document.getElementById('input-video');
    const canvasElement = document.getElementById('output-canvas');
    const canvasCtx = canvasElement.getContext('2d');

    function onResults(results) {
        canvasCtx.save();
        canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
        canvasCtx.drawImage(results.image, 0, 0, canvasElement.width, canvasElement.height);

        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
            const landmarks = results.multiHandLandmarks[0];
            drawConnectors(canvasCtx, landmarks, HAND_CONNECTIONS, {color: '#00FF00', lineWidth: 2});
            drawLandmarks(canvasCtx, landmarks, {color: '#FF0000', lineWidth: 1, radius: 2});

            // 1. è®¡ç®—æ‰‹æŒå¼ å¼€ç¨‹åº¦ (æ§åˆ¶èšæ‹¢/æ•£å¼€)
            const wrist = landmarks[0];
            const middleTip = landmarks[12];
            const palmDist = Math.sqrt(Math.pow(middleTip.x - wrist.x, 2) + Math.pow(middleTip.y - wrist.y, 2));

            // 2. è®¡ç®—æåˆç¨‹åº¦ (æ‹‡æŒ‡4 å’Œ é£ŸæŒ‡8 çš„è·ç¦»)
            const thumbTip = landmarks[4];
            const indexTip = landmarks[8];
            const pinchDist = Math.sqrt(Math.pow(thumbTip.x - indexTip.x, 2) + Math.pow(thumbTip.y - indexTip.y, 2));

            // --- é€»è¾‘åˆ¤æ–­ ---
            
            // æåˆåˆ¤æ–­ (ä¼˜å…ˆçº§æœ€é«˜)
            if (pinchDist < 0.05) { 
                grabPhoto();
            } else {
                releasePhoto();
            }

            // æ¡æ‹³/å¼ å¼€åˆ¤æ–­ (åªæœ‰æ²¡æåˆæ—¶æ‰ç”Ÿæ•ˆ)
            if (!isPinching) {
                if (palmDist < 0.25) {
                    toTreeState(); // æ¡æ‹³ -> å˜æ ‘
                } else if (palmDist > 0.35) {
                    toSpreadState(); // å¼ å¼€ -> æ•£å¼€
                }
            }

        }
        canvasCtx.restore();
    }

    const hands = new Hands({locateFile: (file) => {
        // ä½¿ç”¨æœ¬åœ°æˆ–CDN
        // return `js/${file}`; 
        return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
    }});
    
    hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
    hands.onResults(onResults);

    const cameraUtils = new Camera(videoElement, {
        onFrame: async () => { await hands.send({image: videoElement}); },
        width: 320, height: 240
    });
    cameraUtils.start();


    // ================= 6. æ¸²æŸ“å¾ªç¯ =================
    function animate(time) {
        requestAnimationFrame(animate);
        TWEEN.update(time); // æ›´æ–°åŠ¨ç”»åº“

        // æ—‹è½¬é€»è¾‘ï¼šå¦‚æœæ˜¯æ ‘æ¨¡å¼ï¼Œä¸”æ²¡æœ‰åœ¨çœ‹ç…§ç‰‡ï¼Œå°±æ—‹è½¬
        if (currentState === 'tree' && !isPinching) {
            particleGroup.rotation.y += 0.005;
            topStar.rotation.y -= 0.02;
        } else if (currentState === 'spread') {
            // æ•£å¼€æ—¶ç¼“æ…¢é£˜åŠ¨
            particleGroup.rotation.y += 0.001;
        }

        // è®©æ‰€æœ‰ç²’å­æ°¸è¿œé¢å‘ç›¸æœº (Billboarding) - Three.js Spriteé»˜è®¤å°±æ˜¯ï¼Œä½†Groupæ—‹è½¬äº†éœ€è¦æ³¨æ„
        // è¿™é‡Œå› ä¸ºæ˜¯Groupæ—‹è½¬ï¼ŒSpriteæœ¬èº«æ˜¯æ°¸è¿œæœå‘ç›¸æœºçš„ï¼Œæ‰€ä»¥ä¸ç”¨é¢å¤–æ“ä½œã€‚

        renderer.render(scene, camera);
    }
    animate();

    // è‡ªé€‚åº”çª—å£
    window.addEventListener('resize', () => {
        if(!container) return;
        width = container.clientWidth;
        height = container.clientHeight;
        camera.aspect = width / height;
        camera.updateProjectionMatrix();
        renderer.setSize(width, height);
    });

</script>