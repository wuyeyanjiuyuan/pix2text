<style>
    /* å®¹å™¨æ ·å¼ */
    #tree-container {
        position: relative; width: 100%; height: 600px;
        background: #050505; /* ææ·±ç°èƒŒæ™¯ï¼Œè¡¬æ‰˜å‘å…‰ç²’å­ */
        border-radius: 12px; overflow: hidden;
        box-shadow: 0 10px 30px rgba(0,0,0,0.5);
    }
    
    /* ç”»å¸ƒå±‚ */
    #tree-canvas { 
        width: 100%; height: 100%; display: block; 
        position: absolute; top: 0; left: 0; z-index: 1;
    }
    
    /* UI å±‚ */
    .ui-layer {
        position: absolute; top: 20px; left: 20px; z-index: 10;
        pointer-events: none; /* è®©é¼ æ ‡ç©¿é€ */
    }
    
    /* çŠ¶æ€æ¡ */
    .status-pill {
        display: inline-block; padding: 8px 16px;
        background: rgba(20, 50, 20, 0.8); 
        border: 1px solid rgba(100, 255, 100, 0.4);
        border-radius: 30px; backdrop-filter: blur(8px);
        font-family: 'Segoe UI', sans-serif; font-size: 14px; 
        color: #50ff50; text-shadow: 0 0 10px rgba(0,255,0,0.5);
        box-shadow: 0 4px 15px rgba(0,0,0,0.4);
        margin-bottom: 12px; transition: all 0.3s;
    }
    
    /* ä¸Šä¼ æŒ‰é’® (å¯ç‚¹å‡») */
    .upload-btn {
        pointer-events: auto; cursor: pointer;
        display: inline-flex; align-items: center; gap: 8px;
        padding: 10px 20px; 
        background: linear-gradient(135deg, #d32f2f, #b71c1c);
        border: 1px solid rgba(255, 200, 200, 0.3); 
        color: white; font-weight: bold;
        border-radius: 25px; font-size: 14px; 
        box-shadow: 0 4px 12px rgba(255, 0, 0, 0.3);
        transition: transform 0.2s, box-shadow 0.2s;
    }
    .upload-btn:hover { 
        transform: translateY(-2px);
        box-shadow: 0 6px 16px rgba(255, 50, 50, 0.6);
        background: linear-gradient(135deg, #e53935, #c62828);
    }
    .upload-btn:active { transform: translateY(0); }
    #file-input { display: none; }

    /* æ‘„åƒå¤´å°çª— */
    .cam-box {
        position: absolute; bottom: 20px; right: 20px;
        width: 120px; height: 90px; border-radius: 8px; overflow: hidden;
        border: 2px solid rgba(255,255,255,0.3); z-index: 10; background: #000;
    }
    #input-video { position: absolute; opacity: 0; pointer-events: none; }
    #output-canvas { width: 100%; height: 100%; transform: scaleX(-1); }
</style>

<div id="tree-container">
    <div class="ui-layer">
        <div id="status-text" class="status-pill">æ­£åœ¨è£…é¥°åœ£è¯æ ‘...</div>
        <br>
        <label class="upload-btn">
            ğŸ“· ä¸Šä¼ ç…§ç‰‡ (æ”¯æŒå¤šé€‰)
            <input type="file" id="file-input" accept="image/*" multiple>
        </label>
        
        <div style="margin-top:12px; font-size:12px; color:rgba(255,255,255,0.7); line-height:1.6;">
            âœŠ æ¡æ‹³ï¼šèšåˆåœ£è¯æ ‘<br>
            ğŸ‘Œ æåˆï¼šæŸ¥çœ‹ç…§ç‰‡å›å¿†
        </div>
    </div>

    <div class="cam-box"><canvas id="output-canvas"></canvas></div>
    <video id="input-video" playsinline></video>
    
    <div id="tree-canvas"></div>
</div>

<script src="js/three.min.js"></script>
<script src="js/tween.umd.js"></script>
<script src="js/camera_utils.js"></script>
<script src="js/control_utils.js"></script>
<script src="js/drawing_utils.js"></script>
<script src="js/hands.js"></script>

<script>
    console.log(">>> [ChristmasTree] æ¨¡å—å¯åŠ¨");

    try {
        const container = document.getElementById('tree-canvas');
        const statusText = document.getElementById('status-text');
        
        if (!container) throw new Error("å®¹å™¨æœªæ‰¾åˆ°");

        let width = container.clientWidth || 800;
        let height = container.clientHeight || 600;

        // ================= 1. åˆå§‹åŒ–åœºæ™¯ =================
        const scene = new THREE.Scene();
        // ç¨å¾®åŠ ä¸€ç‚¹ç‚¹é›¾ï¼Œå¢åŠ æ™¯æ·±æ„Ÿï¼Œä½†ä¸è¦å¤ªæµ“
        scene.fog = new THREE.FogExp2(0x050505, 0.0005); 

        const camera = new THREE.PerspectiveCamera(60, width / height, 1, 5000);
        camera.position.set(0, 100, 900); // è§†è§’æ‹‰è¿œ

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(width, height);
        renderer.setPixelRatio(window.devicePixelRatio);
        
        // æ¸…ç†å¹¶æŒ‚è½½
        while(container.firstChild) { container.removeChild(container.firstChild); }
        container.appendChild(renderer.domElement);

        // ================= 2. çº¹ç†ç”Ÿæˆå™¨ (Canvas) =================
        
        // 2.1 é‡‘è‰²å…‰ç‚¹ (æ ¸å¿ƒæè´¨)
        function createSparkTexture() {
            const cvs = document.createElement('canvas');
            cvs.width = 64; cvs.height = 64;
            const ctx = cvs.getContext('2d');
            const gradient = ctx.createRadialGradient(32, 32, 0, 32, 32, 32);
            gradient.addColorStop(0, 'rgba(255, 255, 255, 1)');   // ä¸­å¿ƒç™½
            gradient.addColorStop(0.2, 'rgba(255, 220, 100, 0.8)'); // ä¸­é—´é‡‘
            gradient.addColorStop(0.5, 'rgba(255, 150, 50, 0.2)');  // è¾¹ç¼˜æ©™
            gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 64, 64);
            return new THREE.CanvasTexture(cvs);
        }

        // 2.2 Emoji è´´å›¾
        function createEmojiTexture(emoji) {
            const cvs = document.createElement('canvas');
            cvs.width = 128; cvs.height = 128;
            const ctx = cvs.getContext('2d');
            ctx.font = '90px serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(emoji, 64, 64);
            return new THREE.CanvasTexture(cvs);
        }

        const textures = [
            createSparkTexture(), createSparkTexture(), createSparkTexture(), // å¤šæ”¾ç‚¹å…‰ç‚¹
            createEmojiTexture('ğŸ'), createEmojiTexture('ğŸ””'), 
            createEmojiTexture('ğŸ„'), createEmojiTexture('â„ï¸'), 
            createEmojiTexture('â­')
        ];

        // ================= 3. ç²’å­ç³»ç»Ÿæ„å»º =================
        
        const PARTICLE_COUNT = 800; 
        const TREE_HEIGHT = 650;
        const TREE_BASE_RADIUS = 320;

        const particles = [];
        const photoParticles = []; // ä¸“é—¨å­˜ç…§ç‰‡
        const particleGroup = new THREE.Group();
        scene.add(particleGroup);

        // æ ‘é¡¶å¤§æ˜Ÿæ˜Ÿ (è‡ªå‘å…‰ Mesh)
        const topStar = new THREE.Mesh(
            new THREE.OctahedronGeometry(25, 0),
            new THREE.MeshBasicMaterial({ color: 0xffff88 }) 
        );
        topStar.position.set(0, TREE_HEIGHT/2 + 30, 0);
        topStar.visible = false; // åˆå§‹éšè—
        scene.add(topStar);

        // åˆå§‹åŒ–æ‰€æœ‰ç²’å­
        for (let i = 0; i < PARTICLE_COUNT; i++) {
            const tex = textures[Math.floor(Math.random() * textures.length)];
            
            // â˜… å…³é”®ï¼šä½¿ç”¨ SpriteMaterial å¹¶å¼€å¯ AdditiveBlending
            // è¿™æ ·ç²’å­ä¼šå‘å…‰ï¼Œä¸”ä¸ä¼šå˜æˆé»‘å—
            const material = new THREE.SpriteMaterial({ 
                map: tex, 
                color: 0xffffff, // çº¯ç™½åº•è‰²ï¼Œæ˜¾ç¤ºçº¹ç†åŸè‰²
                transparent: true,
                opacity: 0.9,
                blending: THREE.AdditiveBlending, // å‘å…‰æ··åˆ
                depthWrite: false // ä¸é®æŒ¡åæ–¹
            });
            
            createParticle(material, false);
        }

        function createParticle(material, isPhoto) {
            const sprite = new THREE.Sprite(material);
            
            // --- è®¡ç®— æ ‘å½¢æ€ ç›®æ ‡ä½ç½® ---
            const y = (Math.random() - 0.5) * TREE_HEIGHT; 
            const relY = (y + TREE_HEIGHT/2) / TREE_HEIGHT; // 0~1
            // èºæ—‹å½¢çŠ¶ï¼šåº•éƒ¨å®½ï¼Œé¡¶éƒ¨å°–
            const radius = TREE_BASE_RADIUS * Math.pow((1 - relY), 0.8) + 10; 
            const angle = Math.random() * Math.PI * 2 * 12; // 12åœˆèºæ—‹
            
            const treeX = Math.cos(angle) * radius;
            const treeY = y;
            const treeZ = Math.sin(angle) * radius;

            // --- è®¡ç®— æ•£å¼€å½¢æ€ ç›®æ ‡ä½ç½® ---
            const spreadX = (Math.random() - 0.5) * 1800;
            const spreadY = (Math.random() - 0.5) * 1200;
            const spreadZ = (Math.random() - 0.5) * 800;

            // åˆå§‹è®¾ä¸ºæ•£å¼€
            sprite.position.set(spreadX, spreadY, spreadZ);
            
            // å¤§å°ï¼šç…§ç‰‡è¦å¤§ï¼Œå…‰ç‚¹è¦å°
            let baseScale = Math.random() * 20 + 10;
            if (isPhoto) baseScale = 50;
            
            sprite.scale.set(baseScale, baseScale, 1);

            // æ•°æ®ç»‘å®š
            sprite.userData = {
                treePos: new THREE.Vector3(treeX, treeY, treeZ),
                spreadPos: new THREE.Vector3(spreadX, spreadY, spreadZ),
                baseScale: baseScale,
                isPhoto: isPhoto
            };

            particleGroup.add(sprite);
            particles.push(sprite);
            if (isPhoto) photoParticles.push(sprite);
        }

        // ================= 4. ç…§ç‰‡ä¸Šä¼ å¤„ç† =================
        const fileInput = document.getElementById('file-input');
        
        fileInput.addEventListener('change', function(e) {
            if (this.files.length > 0) {
                statusText.innerText = `å¤„ç† ${this.files.length} å¼ ç…§ç‰‡...`;
                
                Array.from(this.files).forEach((file, index) => {
                    const reader = new FileReader();
                    reader.onload = function(event) {
                        const img = new Image();
                        img.src = event.target.result;
                        
                        const tex = new THREE.TextureLoader().load(img.src, () => {
                            // çº¹ç†åŠ è½½åï¼Œæ›¿æ¢ä¸€ä¸ªæ™®é€šç²’å­
                            replaceParticleWithPhoto(tex);
                        });
                    };
                    reader.readAsDataURL(file);
                });
                
                setTimeout(() => statusText.innerText = "ç…§ç‰‡å·²æŒ‚è½½ï¼è¯·æåˆæŸ¥çœ‹", 1500);
            }
        });

        function replaceParticleWithPhoto(texture) {
            // ç…§ç‰‡æè´¨ï¼šä¸ä½¿ç”¨ AdditiveBlendingï¼Œå¦åˆ™ç…§ç‰‡ä¼šå¤ªäº®çœ‹ä¸æ¸…
            const material = new THREE.SpriteMaterial({ 
                map: texture, 
                color: 0xffffff,
                transparent: true 
            });
            
            // æ‰¾ä¸€ä¸ªéç…§ç‰‡çš„ç²’å­åˆ æ‰
            let idx = Math.floor(Math.random() * particles.length);
            while(particles[idx].userData.isPhoto) {
                idx = Math.floor(Math.random() * particles.length);
            }
            const oldSprite = particles[idx];
            
            // åˆ›å»ºæ–°ç…§ç‰‡ç²’å­
            createParticle(material, true);
            const newSprite = particles[particles.length - 1]; // åˆšåˆšpushè¿›å»çš„é‚£ä¸ª
            
            // ç»§æ‰¿ä½ç½®
            newSprite.position.copy(oldSprite.position);
            newSprite.scale.set(0, 0, 1); // åˆå§‹ç¼©å°
            
            // åˆ é™¤æ—§çš„
            particleGroup.remove(oldSprite);
            particles.splice(idx, 1); // ä»æ•°ç»„ç§»é™¤æ—§çš„
            
            // å¼¹çª—åŠ¨ç”»
            new TWEEN.Tween(newSprite.scale)
                .to({ x: 50, y: 50 }, 800)
                .easing(TWEEN.Easing.Elastic.Out)
                .start();
        }

        // ================= 5. äº¤äº’çŠ¶æ€æ§åˆ¶ =================
        let currentState = 'spread'; 
        let isPinching = false;
        let activePhoto = null; 

        function toTreeState() {
            if (currentState === 'tree') return;
            currentState = 'tree';
            statusText.innerText = "ğŸ„ åœ£è¯æ ‘å·²èšåˆ";
            statusText.style.color = "#ffff00";
            topStar.visible = true;

            particles.forEach(p => {
                if (p === activePhoto) return; 
                new TWEEN.Tween(p.position)
                    .to(p.userData.treePos, 1500)
                    .easing(TWEEN.Easing.Exponential.InOut)
                    .start();
            });
        }

        function toSpreadState() {
            if (currentState === 'spread') return;
            currentState = 'spread';
            statusText.innerText = "âœ¨ è‡ªç”±ç²’å­æ¨¡å¼";
            statusText.style.color = "#50ff50";
            topStar.visible = false;

            particles.forEach(p => {
                if (p === activePhoto) return;
                new TWEEN.Tween(p.position)
                    .to(p.userData.spreadPos, 2000)
                    .easing(TWEEN.Easing.Cubic.Out)
                    .start();
            });
        }

        function grabPhoto() {
            if (isPinching || photoParticles.length === 0) return;
            isPinching = true;
            
            // éšæœºé€‰ä¸€å¼ å·²ä¸Šä¼ çš„ç…§ç‰‡
            activePhoto = photoParticles[Math.floor(Math.random() * photoParticles.length)];
            
            // é£åˆ°é•œå¤´å‰
            new TWEEN.Tween(activePhoto.position)
                .to({ x: 0, y: 50, z: 600 }, 800) // Z=600 ç¦»ç›¸æœºå¾ˆè¿‘
                .easing(TWEEN.Easing.Back.Out)
                .start();

            // æ”¾å¤§
            new TWEEN.Tween(activePhoto.scale)
                .to({ x: 300, y: 300 }, 800) 
                .easing(TWEEN.Easing.Back.Out)
                .start();
                
            statusText.innerText = "ğŸ–¼ï¸ å›å¿†æ—¶åˆ»";
        }

        function releasePhoto() {
            if (!isPinching || !activePhoto) return;
            isPinching = false;
            
            const target = currentState === 'tree' ? activePhoto.userData.treePos : activePhoto.userData.spreadPos;
            const scale = activePhoto.userData.baseScale;

            new TWEEN.Tween(activePhoto.position).to(target, 1000).easing(TWEEN.Easing.Back.Out).start();
            new TWEEN.Tween(activePhoto.scale).to({x: scale, y: scale}, 1000).easing(TWEEN.Easing.Back.Out).start();
            
            activePhoto = null;
            statusText.innerText = currentState === 'tree' ? "ğŸ„ åœ£è¯æ ‘å·²èšåˆ" : "âœ¨ è‡ªç”±ç²’å­æ¨¡å¼";
        }

        // ================= 6. MediaPipe æ‰‹åŠ¿ =================
        const videoElement = document.getElementById('input-video');
        const canvasElement = document.getElementById('output-canvas');
        const canvasCtx = canvasElement.getContext('2d');

        function onResults(results) {
            if(statusText.innerText.includes("åˆå§‹åŒ–")) {
                 statusText.innerText = "å¼•æ“å°±ç»ªï¼Œè¯·ä¸Šä¼ ç…§ç‰‡";
            }
            
            canvasCtx.save();
            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
            canvasCtx.drawImage(results.image, 0, 0, canvasElement.width, canvasElement.height);

            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const landmarks = results.multiHandLandmarks[0];
                drawConnectors(canvasCtx, landmarks, HAND_CONNECTIONS, {color: '#00FF00', lineWidth: 2});
                drawLandmarks(canvasCtx, landmarks, {color: '#FF0000', lineWidth: 1, radius: 2});

                const wrist = landmarks[0];
                const middleTip = landmarks[12];
                const palmDist = Math.sqrt(Math.pow(middleTip.x - wrist.x, 2) + Math.pow(middleTip.y - wrist.y, 2));

                const thumbTip = landmarks[4];
                const indexTip = landmarks[8];
                const pinchDist = Math.sqrt(Math.pow(thumbTip.x - indexTip.x, 2) + Math.pow(thumbTip.y - indexTip.y, 2));

                if (pinchDist < 0.05) { 
                    grabPhoto();
                } else {
                    releasePhoto();
                }

                if (!isPinching) {
                    if (palmDist < 0.25) toTreeState(); 
                    else if (palmDist > 0.35) toSpreadState(); 
                }
            }
            canvasCtx.restore();
        }

        const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
        hands.setOptions({maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5});
        hands.onResults(onResults);

        const cameraUtils = new Camera(videoElement, {
            onFrame: async () => { await hands.send({image: videoElement}); },
            width: 320, height: 240
        });
        cameraUtils.start();

        // ================= 7. æ¸²æŸ“å¾ªç¯ =================
        function animate(time) {
            requestAnimationFrame(animate);
            TWEEN.update(time); 

            if (currentState === 'tree' && !isPinching) {
                particleGroup.rotation.y += 0.005;
                topStar.rotation.y -= 0.02;
            } else if (currentState === 'spread') {
                particleGroup.rotation.y += 0.001;
            }

            renderer.render(scene, camera);
        }
        animate();

        window.addEventListener('resize', () => {
            if(!container) return;
            width = container.clientWidth;
            height = container.clientHeight;
            camera.aspect = width / height;
            camera.updateProjectionMatrix();
            renderer.setSize(width, height);
        });

    } catch (e) {
        console.error(e);
        document.getElementById('status-text').innerText = "âŒ é”™è¯¯: " + e.message;
        document.getElementById('status-text').style.backgroundColor = "red";
    }
</script>