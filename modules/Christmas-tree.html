<style>
    /* å®¹å™¨æ ·å¼ */
    #tree-container {
        position: relative; width: 100%; height: 600px;
        background: #050505; /* çº¯é»‘èƒŒæ™¯ï¼Œè®©é—ªå…‰æœ€äº® */
        border-radius: 12px; overflow: hidden;
        box-shadow: 0 10px 40px rgba(0,0,0,0.8);
    }
    
    #tree-canvas { 
        width: 100%; height: 100%; display: block; 
        position: absolute; top: 0; left: 0; z-index: 1;
    }
    
    /* UI å±‚ */
    .ui-layer {
        position: absolute; top: 20px; left: 20px; z-index: 10;
        pointer-events: none; 
    }
    
    .status-pill {
        display: inline-block; padding: 8px 16px;
        background: rgba(255, 215, 0, 0.15); 
        border: 1px solid rgba(255, 215, 0, 0.4);
        border-radius: 30px; backdrop-filter: blur(8px);
        font-family: 'Segoe UI', sans-serif; font-size: 14px; 
        color: #ffdd44; text-shadow: 0 0 8px rgba(255, 200, 0, 0.6);
        box-shadow: 0 4px 15px rgba(0,0,0,0.4);
        margin-bottom: 12px; transition: all 0.3s;
    }
    
    .upload-btn {
        pointer-events: auto; cursor: pointer;
        display: inline-flex; align-items: center; gap: 8px;
        padding: 10px 20px; 
        background: linear-gradient(135deg, #d32f2f, #8e0000);
        border: 1px solid rgba(255, 100, 100, 0.3); 
        color: white; font-weight: bold;
        border-radius: 25px; font-size: 14px; 
        box-shadow: 0 4px 12px rgba(200, 0, 0, 0.4);
        transition: transform 0.2s;
    }
    .upload-btn:hover { transform: translateY(-2px); filter: brightness(1.2); }
    #file-input { display: none; }

    .cam-box {
        position: absolute; bottom: 20px; right: 20px;
        width: 120px; height: 90px; border-radius: 8px; overflow: hidden;
        border: 2px solid rgba(255,255,255,0.3); z-index: 10; background: #000;
    }
    #input-video { position: absolute; opacity: 0; pointer-events: none; }
    #output-canvas { width: 100%; height: 100%; transform: scaleX(-1); }
</style>

<div id="tree-container">
    <div class="ui-layer">
        <div id="status-text" class="status-pill">æ­£åœ¨è£…é¥°åœ£è¯æ ‘...</div>
        <br>
        <label class="upload-btn">
            ğŸ“· æŒ‚ä¸Šç…§ç‰‡
            <input type="file" id="file-input" accept="image/*" multiple>
        </label>
        <div style="margin-top:12px; font-size:12px; color:rgba(255,255,255,0.6); line-height:1.6;">
            âœŠ æ¡æ‹³ï¼šèšåˆåœ£è¯æ ‘<br>
            ğŸ‘Œ æåˆï¼šæŠ“å–ç…§ç‰‡
        </div>
    </div>

    <div class="cam-box"><canvas id="output-canvas"></canvas></div>
    <video id="input-video" playsinline></video>
    <div id="tree-canvas"></div>
</div>

<script src="js/three.min.js"></script>
<script src="js/tween.umd.js"></script>
<script src="js/camera_utils.js"></script>
<script src="js/control_utils.js"></script>
<script src="js/drawing_utils.js"></script>
<script src="js/hands.js"></script>

<script>
    console.log(">>> [ChristmasTree] é—ªè€€ç‰ˆå¯åŠ¨");

    try {
        const container = document.getElementById('tree-canvas');
        const statusText = document.getElementById('status-text');
        
        if (!container) throw new Error("å®¹å™¨æœªæ‰¾åˆ°");

        let width = container.clientWidth || 800;
        let height = container.clientHeight || 600;

        // ================= 1. åœºæ™¯åˆå§‹åŒ– =================
        const scene = new THREE.Scene();
        // ç¨å¾®åŠ ä¸€ç‚¹é›¾ï¼Œè®©è¿œå¤„çš„ç²’å­æš—ä¸‹å»ï¼Œå¢åŠ å±‚æ¬¡ï¼Œä½†ä¸è¦å¤ªæµ“é˜²æ­¢å˜é»‘
        scene.fog = new THREE.FogExp2(0x000000, 0.0006); 

        const camera = new THREE.PerspectiveCamera(60, width / height, 1, 5000);
        camera.position.set(0, 0, 800); 

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(width, height);
        renderer.setPixelRatio(window.devicePixelRatio);
        container.appendChild(renderer.domElement);

        // ================= 2. çº¹ç†ç”Ÿæˆ (å›å½’ Canvas Sprite) =================
        
        // 2.1 é«˜æ¸… Emoji è´´å›¾
        function createEmojiTexture(emoji) {
            const size = 128; // é«˜æ¸…
            const cvs = document.createElement('canvas');
            cvs.width = size; cvs.height = size;
            const ctx = cvs.getContext('2d');
            ctx.font = '90px serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillStyle = "#ffffff"; // çº¯ç™½ï¼Œç¡®ä¿æ˜¾ç¤ºåŸè‰²
            ctx.fillText(emoji, size/2, size/2);
            return new THREE.CanvasTexture(cvs);
        }

        // 2.2 åŸºç¡€å…‰ç‚¹ (ç”¨äºèƒŒæ™¯æ˜Ÿå°˜)
        function createDotTexture() {
            const cvs = document.createElement('canvas');
            cvs.width = 32; cvs.height = 32;
            const ctx = cvs.getContext('2d');
            ctx.beginPath();
            ctx.arc(16, 16, 10, 0, Math.PI * 2);
            ctx.fillStyle = "rgba(255,255,255,0.8)";
            ctx.fill();
            return new THREE.CanvasTexture(cvs);
        }

        // 2.3 â˜…â˜…â˜… æ ¸å¿ƒç‰¹æ•ˆï¼šé«˜äº®é—ªå…‰å¼¹çº¹ç† â˜…â˜…â˜…
        function createFlashTexture() {
            const size = 128;
            const cvs = document.createElement('canvas');
            cvs.width = size; cvs.height = size;
            const ctx = cvs.getContext('2d');
            
            // æ”¾å°„çŠ¶æ¸å˜ï¼šä¸­å¿ƒæäº®ç™½ -> å¤–åœˆé‡‘é»„ -> è¾¹ç¼˜é€æ˜
            const grad = ctx.createRadialGradient(size/2, size/2, 0, size/2, size/2, size/2);
            grad.addColorStop(0, 'rgba(255, 255, 255, 1)');
            grad.addColorStop(0.2, 'rgba(255, 255, 200, 1)');
            grad.addColorStop(0.4, 'rgba(255, 215, 0, 0.8)'); // é‡‘è‰²
            grad.addColorStop(1, 'rgba(255, 215, 0, 0)');
            
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, size, size);
            return new THREE.CanvasTexture(cvs);
        }

        const textures = [
            createEmojiTexture('ğŸ'), createEmojiTexture('ğŸ””'), 
            createEmojiTexture('ğŸ„'), createEmojiTexture('â„ï¸'), 
            createEmojiTexture('â­'), createEmojiTexture('ğŸª'),
            createEmojiTexture('ğŸ€')
        ];
        
        const dotTex = createDotTexture();
        const flashTex = createFlashTexture();

        // ================= 3. ç²’å­ç³»ç»Ÿæ„å»º =================
        
        const PARTICLE_COUNT = 700; 
        const DUST_COUNT = 400; // å¤–éƒ¨æ˜Ÿå°˜
        
        const TREE_HEIGHT = 550;
        const TREE_BASE_RADIUS = 280;

        const particleGroup = new THREE.Group(); // ä¸»æ ‘/çƒ
        const dustGroup = new THREE.Group();     // å¤–éƒ¨æ˜Ÿå°˜
        const flashGroup = new THREE.Group();    // â˜… é—ªå…‰ç‰¹æ•ˆå±‚
        
        scene.add(particleGroup);
        scene.add(dustGroup);
        scene.add(flashGroup); // æ”¾åœ¨æœ€ä¸Šå±‚

        const particles = [];
        const photoParticles = [];
        
        // 3.1 ä¸»ç²’å­ç”Ÿæˆ (Emoji + ç…§ç‰‡ä½)
        for (let i = 0; i < PARTICLE_COUNT; i++) {
            const tex = textures[Math.floor(Math.random() * textures.length)];
            const material = new THREE.SpriteMaterial({ 
                map: tex, 
                color: 0xffffff,
                transparent: true,
                opacity: 0.9,
                depthTest: true, // å¼€å¯æ·±åº¦æµ‹è¯•ï¼Œæœ‰å‰åé®æŒ¡å…³ç³»
                depthWrite: false // ä¸å†™å…¥æ·±åº¦ï¼Œé˜²æ­¢é€æ˜è´´å›¾äº’ç›¸è£å‰ª
            });
            createParticle(material, false);
        }

        // 3.2 å¤–éƒ¨æ˜Ÿå°˜ (è¥é€ çƒå½¢æ°›å›´)
        for (let i = 0; i < DUST_COUNT; i++) {
            const material = new THREE.SpriteMaterial({
                map: dotTex,
                color: 0xffdd44, // é‡‘è‰²å°˜åŸƒ
                transparent: true,
                opacity: 0.6,
                blending: THREE.AdditiveBlending // å‘å…‰å åŠ 
            });
            const sprite = new THREE.Sprite(material);
            
            // çƒé¢éšæœºåˆ†å¸ƒ (åŠå¾„ 400~800)
            const r = 400 + Math.random() * 400;
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.acos(2 * Math.random() - 1);
            
            sprite.position.set(
                r * Math.sin(phi) * Math.cos(theta),
                r * Math.sin(phi) * Math.sin(theta),
                r * Math.cos(phi)
            );
            
            const s = Math.random() * 3 + 2;
            sprite.scale.set(s, s, 1);
            dustGroup.add(sprite);
        }

        // 3.3 â˜…â˜…â˜… é—ªå…‰æ±  (Flash Pool) â˜…â˜…â˜…
        // é¢„åˆ›å»º 20 ä¸ªä¸å¯è§çš„é—ªå…‰ç²¾çµï¼Œå¾ªç¯ä½¿ç”¨
        const flashPool = [];
        for(let i=0; i<20; i++) {
            const mat = new THREE.SpriteMaterial({
                map: flashTex,
                color: 0xffffff,
                transparent: true,
                opacity: 0,
                blending: THREE.AdditiveBlending // å¿…é¡»åŠ æ³•æ··åˆï¼Œäº§ç”Ÿçˆ†é—ªæ„Ÿ
            });
            const sprite = new THREE.Sprite(mat);
            sprite.visible = false;
            flashGroup.add(sprite);
            flashPool.push(sprite);
        }

        // æ ‘é¡¶å¤§æ˜Ÿæ˜Ÿ (è¿™æ¬¡ç”¨å› Spriteï¼Œä¿è¯å‘å…‰ä¸é»‘)
        const topStarMat = new THREE.SpriteMaterial({
            map: createEmojiTexture('â­'),
            color: 0xffff88,
            blending: THREE.AdditiveBlending
        });
        const topStar = new THREE.Sprite(topStarMat);
        topStar.scale.set(80, 80, 1);
        topStar.position.set(0, TREE_HEIGHT/2 + 40, 0);
        topStar.visible = false;
        scene.add(topStar);

        // --- ç²’å­åˆ›å»ºé€»è¾‘ ---
        function createParticle(material, isPhoto) {
            const sprite = new THREE.Sprite(material);
            
            // æ ‘å½¢æ€
            const y = (Math.random() - 0.5) * TREE_HEIGHT; 
            const relY = (y + TREE_HEIGHT/2) / TREE_HEIGHT; 
            const radius = TREE_BASE_RADIUS * Math.pow((1 - relY), 0.7) * (0.8 + Math.random()*0.4); 
            const angle = Math.random() * Math.PI * 2 * 12;
            
            const treePos = new THREE.Vector3(
                Math.cos(angle) * radius,
                y,
                Math.sin(angle) * radius
            );

            // çƒå½¢æ€ (ç´§å‡‘å°çƒ)
            const sphereR = 320; // å±å¹•ä¸­å¿ƒ 320 åŠå¾„
            const u = Math.random();
            const v = Math.random();
            const theta = 2 * Math.PI * u;
            const phi = Math.acos(2 * v - 1);
            
            const spreadPos = new THREE.Vector3(
                sphereR * Math.sin(phi) * Math.cos(theta),
                sphereR * Math.sin(phi) * Math.sin(theta),
                sphereR * Math.cos(phi)
            );

            sprite.position.copy(spreadPos);
            
            // å¤§å°
            let baseScale = Math.random() * 25 + 15; // Emoji å¤§å°
            if (isPhoto) baseScale = 50; // ç…§ç‰‡é»˜è®¤å¤§å°
            
            if (isPhoto && material.userData.aspect) {
                sprite.scale.set(baseScale * material.userData.aspect, baseScale, 1);
            } else {
                sprite.scale.set(baseScale, baseScale, 1);
            }

            sprite.userData = {
                treePos: treePos,
                spreadPos: spreadPos,
                baseScale: baseScale,
                aspect: material.userData.aspect || 1,
                isPhoto: isPhoto
            };

            particleGroup.add(sprite);
            particles.push(sprite);
            if (isPhoto) photoParticles.push(sprite);
        }

        // ================= 4. ç…§ç‰‡ä¸Šä¼  (åŸæ¯”ä¾‹ & é«˜æ¸…) =================
        const fileInput = document.getElementById('file-input');
        
        fileInput.addEventListener('change', function(e) {
            if (this.files.length > 0) {
                statusText.innerText = `æ­£åœ¨å¤„ç†...`;
                
                Array.from(this.files).forEach((file) => {
                    const reader = new FileReader();
                    reader.onload = function(event) {
                        const img = new Image();
                        img.src = event.target.result;
                        img.onload = () => {
                            const aspect = img.width / img.height;
                            const tex = new THREE.TextureLoader().load(img.src);
                            tex.minFilter = THREE.LinearFilter; // ä¿è¯ç¼©å°æ—¶ä¸ç³Š
                            
                            const mat = new THREE.SpriteMaterial({ 
                                map: tex, 
                                color: 0xffffff,
                                transparent: true,
                                userData: { aspect: aspect } // å­˜å…¥æ¯”ä¾‹
                            });
                            
                            replaceParticleWithPhoto(mat);
                        }
                    };
                    reader.readAsDataURL(file);
                });
                
                setTimeout(() => statusText.innerText = "ç…§ç‰‡å·²æŒ‚è½½ï¼æåˆæŸ¥çœ‹", 1500);
            }
        });

        function replaceParticleWithPhoto(newMat) {
            let idx = Math.floor(Math.random() * particles.length);
            // æ‰¾ä¸€ä¸ªä¸æ˜¯ç…§ç‰‡çš„ç²’å­
            while(particles[idx].userData.isPhoto) {
                idx = Math.floor(Math.random() * particles.length);
            }
            const oldSprite = particles[idx];
            
            createParticle(newMat, true);
            const newSprite = particles[particles.length - 1];
            
            newSprite.position.copy(oldSprite.position);
            newSprite.scale.set(0,0,1);
            
            particleGroup.remove(oldSprite);
            particles.splice(idx, 1);
            
            // å¼¹å‡ºåŠ¨ç”»
            const h = newSprite.userData.baseScale;
            const w = h * newSprite.userData.aspect;
            new TWEEN.Tween(newSprite.scale).to({x:w, y:h, z:1}, 600).easing(TWEEN.Easing.Elastic.Out).start();
        }

        // ================= 5. äº¤äº’çŠ¶æ€ (ä¿®æ­£æå–é€»è¾‘) =================
        let currentState = 'spread'; 
        let isPinching = false;
        let activePhoto = null; 

        function toTreeState() {
            if (currentState === 'tree') return;
            currentState = 'tree';
            statusText.innerText = "ğŸ„ åœ£è¯æ ‘å·²èšåˆ";
            statusText.style.color = "#ffff00";
            topStar.visible = true;

            particles.forEach(p => {
                if (p === activePhoto) return; 
                new TWEEN.Tween(p.position)
                    .to(p.userData.treePos, 1500)
                    .easing(TWEEN.Easing.Exponential.InOut)
                    .start();
            });
        }

        function toSpreadState() {
            if (currentState === 'spread') return;
            currentState = 'spread';
            statusText.innerText = "âœ¨ æ˜Ÿå°˜çƒä½“æ¨¡å¼";
            statusText.style.color = "#50ff50";
            topStar.visible = false;

            particles.forEach(p => {
                if (p === activePhoto) return;
                new TWEEN.Tween(p.position)
                    .to(p.userData.spreadPos, 2000)
                    .easing(TWEEN.Easing.Cubic.Out)
                    .start();
            });
        }

        // â˜…â˜…â˜… æ ¸å¿ƒï¼šå®Œç¾ç…§ç‰‡å±•ç¤ºé€»è¾‘ â˜…â˜…â˜…
        function grabPhoto() {
            if (isPinching || photoParticles.length === 0) return;
            
            // 1. æ‰¾æœ€è¿‘çš„ç…§ç‰‡
            let closestDist = Infinity;
            let closestPhoto = null;
            const worldPos = new THREE.Vector3();
            
            photoParticles.forEach(p => {
                p.getWorldPosition(worldPos);
                const d = camera.position.distanceTo(worldPos);
                if(d < closestDist) {
                    closestDist = d;
                    closestPhoto = p;
                }
            });
            
            if(!closestPhoto) return;
            
            isPinching = true;
            activePhoto = closestPhoto;
            
            // 2. å‰¥ç¦»çˆ¶çº§ï¼Œç¡®ä¿é™æ­¢
            scene.attach(activePhoto);

            // 3. é£åˆ°æ­£å‰æ–¹
            new TWEEN.Tween(activePhoto.position)
                .to({ x: 0, y: 0, z: 600 }, 600)
                .easing(TWEEN.Easing.Back.Out)
                .start();

            // 4. â˜… è®¡ç®—é€‚åº”å±å¹•çš„å¤§å° (Fit Screen) â˜…
            // ç›®æ ‡å æ®å±å¹•é«˜åº¦çš„ 60%
            // ç®€å•çš„é€è§†ä¼°ç®—ï¼šåœ¨ z=600, camera z=800 æ—¶ï¼Œè·ç¦»ç›¸æœº 200
            // ä¸ºäº†è§†è§‰èˆ’é€‚ï¼Œæˆ‘ä»¬ç›´æ¥è®¾ä¸€ä¸ªåˆç†çš„å›ºå®šé«˜åº¦
            const MAX_H = 300; 
            const MAX_W = 400;
            
            const aspect = activePhoto.userData.aspect;
            let targetH = MAX_H;
            let targetW = targetH * aspect;
            
            // å¦‚æœå¤ªå®½äº†ï¼Œå°±æŒ‰å®½åº¦é™åˆ¶
            if (targetW > MAX_W) {
                targetW = MAX_W;
                targetH = targetW / aspect;
            }
            
            new TWEEN.Tween(activePhoto.scale)
                .to({ x: targetW, y: targetH, z: 1 }, 600)
                .easing(TWEEN.Easing.Back.Out)
                .start();
                
            statusText.innerText = "ğŸ–¼ï¸ å›å¿†æ—¶åˆ»";
        }

        function releasePhoto() {
            if (!isPinching || !activePhoto) return;
            isPinching = false;
            
            particleGroup.attach(activePhoto);

            const target = currentState === 'tree' ? activePhoto.userData.treePos : activePhoto.userData.spreadPos;
            const h = activePhoto.userData.baseScale;
            const w = h * activePhoto.userData.aspect;

            new TWEEN.Tween(activePhoto.position).to(target, 800).easing(TWEEN.Easing.Exponential.Out).start();
            new TWEEN.Tween(activePhoto.scale).to({x: w, y: h, z: 1}, 800).easing(TWEEN.Easing.Exponential.Out).start();
            
            activePhoto = null;
            statusText.innerText = currentState === 'tree' ? "ğŸ„ åœ£è¯æ ‘" : "âœ¨ æ˜Ÿå°˜";
        }

        // ================= 6. MediaPipe æ‰‹åŠ¿ =================
        const videoElement = document.getElementById('input-video');
        const canvasElement = document.getElementById('output-canvas');
        const canvasCtx = canvasElement.getContext('2d');

        function onResults(results) {
            if(statusText.innerText.includes("åˆå§‹åŒ–")) {
                 statusText.innerText = "å¼•æ“å°±ç»ªï¼Œè¯·ä¸Šä¼ ç…§ç‰‡";
            }
            canvasCtx.save();
            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
            canvasCtx.drawImage(results.image, 0, 0, canvasElement.width, canvasElement.height);

            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const landmarks = results.multiHandLandmarks[0];
                drawConnectors(canvasCtx, landmarks, HAND_CONNECTIONS, {color: '#00FF00', lineWidth: 2});
                drawLandmarks(canvasCtx, landmarks, {color: '#FF0000', lineWidth: 1, radius: 2});

                const wrist = landmarks[0];
                const middleTip = landmarks[12];
                const palmDist = Math.sqrt(Math.pow(middleTip.x - wrist.x, 2) + Math.pow(middleTip.y - wrist.y, 2));

                const thumbTip = landmarks[4];
                const indexTip = landmarks[8];
                const pinchDist = Math.sqrt(Math.pow(thumbTip.x - indexTip.x, 2) + Math.pow(thumbTip.y - indexTip.y, 2));

                if (pinchDist < 0.05) grabPhoto();
                else releasePhoto();

                if (!isPinching) {
                    if (palmDist < 0.25) toTreeState(); 
                    else if (palmDist > 0.35) toSpreadState(); 
                }
            }
            canvasCtx.restore();
        }

        const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
        hands.setOptions({maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5});
        hands.onResults(onResults);

        const cameraUtils = new Camera(videoElement, {
            onFrame: async () => { await hands.send({image: videoElement}); },
            width: 320, height: 240
        });
        cameraUtils.start();

        // ================= 7. æ¸²æŸ“å¾ªç¯ (å«é—ªå…‰ç‰¹æ•ˆ) =================
        function animate(time) {
            requestAnimationFrame(animate);
            TWEEN.update(time); 

            // A. æ—‹è½¬
            if (currentState === 'tree' && !isPinching) {
                particleGroup.rotation.y += 0.005; 
                topStar.rotation.y -= 0.02;
            } else if (currentState === 'spread') {
                particleGroup.rotation.y += 0.001;
                particleGroup.rotation.x = Math.sin(time * 0.0005) * 0.1;
            }
            dustGroup.rotation.y -= 0.0005;

            // B. â˜…â˜…â˜… è§¦å‘éšæœºé—ªå…‰ (Flash Effect) â˜…â˜…â˜…
            // æ¯å¸§æœ‰ 5% çš„æ¦‚ç‡è§¦å‘ä¸€æ¬¡é—ªå…‰
            if (Math.random() < 0.05) {
                triggerRandomFlash();
            }

            renderer.render(scene, camera);
        }
        animate();

        // è§¦å‘é—ªå…‰é€»è¾‘
        function triggerRandomFlash() {
            // 1. æ‰¾ä¸€ä¸ªç©ºé—²çš„é—ªå…‰ç²¾çµ
            const flashSprite = flashPool.find(s => !s.visible);
            if (!flashSprite) return;

            // 2. æ‰¾ä¸€ä¸ªéšæœºçš„ Emoji ç²’å­ä½œä¸ºç›®æ ‡
            const target = particles[Math.floor(Math.random() * particles.length)];
            
            // 3. è®¾ç½®ä½ç½®
            // è·å– target çš„ä¸–ç•Œåæ ‡
            const worldPos = new THREE.Vector3();
            target.getWorldPosition(worldPos);
            flashSprite.position.copy(worldPos);
            
            // 4. æ¿€æ´»
            flashSprite.visible = true;
            flashSprite.material.opacity = 1;
            flashSprite.scale.set(0, 0, 1);

            // 5. åŠ¨ç”»ï¼šè¿…é€Ÿå˜å¤§ -> æ…¢æ…¢æ¶ˆå¤±
            // å˜å¤§ (50ms)
            new TWEEN.Tween(flashSprite.scale)
                .to({ x: 120, y: 120 }, 100)
                .easing(TWEEN.Easing.Quadratic.Out)
                .onComplete(() => {
                    // å˜æ·¡ (300ms)
                    new TWEEN.Tween(flashSprite.material)
                        .to({ opacity: 0 }, 300)
                        .onComplete(() => {
                            flashSprite.visible = false;
                        })
                        .start();
                })
                .start();
        }

        window.addEventListener('resize', () => {
            if(!container) return;
            width = container.clientWidth;
            height = container.clientHeight;
            camera.aspect = width / height;
            camera.updateProjectionMatrix();
            renderer.setSize(width, height);
        });

    } catch (e) {
        console.error(e);
        document.getElementById('status-text').innerText = "âŒ é”™è¯¯: " + e.message;
        document.getElementById('status-text').style.backgroundColor = "red";
    }
</script>