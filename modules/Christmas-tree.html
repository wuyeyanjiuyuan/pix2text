<style>
    #tree-container {
        position: relative; width: 100%; height: 600px;
        background: #111; /* èƒŒæ™¯æ”¹ä¸ºæ·±ç°ï¼Œé˜²æ­¢å…¨é»‘çœ‹ä¸æ¸… */
        border-radius: 12px; overflow: hidden;
        box-shadow: 0 10px 30px rgba(0,0,0,0.2);
    }
    #three-canvas { width: 100%; height: 100%; display: block; }
    
    /* UI å±‚ */
    .ui-layer {
        position: absolute; top: 20px; left: 20px; z-index: 10;
        pointer-events: none; 
    }
    .status-pill {
        display: inline-block; padding: 8px 16px;
        background: rgba(255, 255, 255, 0.1); 
        border: 1px solid rgba(255, 255, 255, 0.2);
        border-radius: 30px; backdrop-filter: blur(5px);
        font-family: 'Segoe UI', sans-serif; font-size: 14px; 
        color: #ffcc00; /* é‡‘è‰²æ–‡å­— */
        margin-bottom: 10px;
    }
    
    .cam-box {
        position: absolute; bottom: 20px; right: 20px;
        width: 120px; height: 90px; border-radius: 8px; overflow: hidden;
        border: 2px solid rgba(255,255,255,0.2); z-index: 10; background: #000;
    }
    #input-video { position: absolute; opacity: 0; pointer-events: none; }
    #output-canvas { width: 100%; height: 100%; transform: scaleX(-1); }
</style>

<div id="tree-container">
    <div class="ui-layer">
        <div id="status-text" class="status-pill">æ­£åœ¨æ„å»º 3D ç§¯æœ¨æ ‘...</div>
        <div style="margin-top:10px; font-size:12px; color:rgba(255,255,255,0.6);">
            âœŠ æ¡æ‹³ï¼šèšåˆ | ğŸ‘Œ æåˆï¼šæŠ“å–çº¢è‰²æ–¹å—
        </div>
    </div>

    <div class="cam-box"><canvas id="output-canvas"></canvas></div>
    <video id="input-video" playsinline></video>
    <div id="three-canvas"></div>
</div>

<script src="js/three.min.js"></script>
<script src="js/tween.umd.js"></script>
<script src="js/camera_utils.js"></script>
<script src="js/control_utils.js"></script>
<script src="js/drawing_utils.js"></script>
<script src="js/hands.js"></script>

<script>
    const container = document.getElementById('tree-canvas');
    const statusText = document.getElementById('status-text');
    let width = container.clientWidth;
    let height = container.clientHeight;

    // ================= 1. åˆå§‹åŒ–åœºæ™¯ (æ— é›¾æ°”ç‰ˆ) =================
    const scene = new THREE.Scene();
    // scene.fog = new THREE.FogExp2(0x000000, 0.0008); // â˜… ç§»é™¤é›¾æ°”ï¼Œé˜²æ­¢å˜é»‘

    const camera = new THREE.PerspectiveCamera(60, width / height, 1, 5000);
    camera.position.set(0, 50, 800); // ç›¸æœºæ”¾ä½ä¸€ç‚¹ï¼Œå¹³è§†

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(width, height);
    renderer.setPixelRatio(window.devicePixelRatio);
    container.appendChild(renderer.domElement);

    // â˜… ç¯å…‰ç³»ç»Ÿ (3Dç‰©ä½“éœ€è¦ç¯å…‰)
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.6); // å¼ºç¯å¢ƒå…‰
    scene.add(ambientLight);
    
    const dirLight = new THREE.DirectionalLight(0xffddcc, 0.8); // æš–è‰²ä¸»å…‰
    dirLight.position.set(200, 500, 200);
    scene.add(dirLight);

    const pointLight = new THREE.PointLight(0xff0000, 1, 500); // çº¢è‰²ç‚¹å…‰å¢åŠ æ°›å›´
    pointLight.position.set(0, 0, 0);
    scene.add(pointLight);

    // ================= 2. å‡ ä½•ç²’å­ç³»ç»Ÿ =================
    
    const PARTICLE_COUNT = 600; // 3Dæ¨¡å‹æ¯”è¾ƒé‡ï¼Œæ•°é‡ç¨å¾®å‡å°‘ä¸€ç‚¹
    const TREE_HEIGHT = 600;
    const TREE_BASE_RADIUS = 300;

    // é¢„å®šä¹‰å‡ ç§å‡ ä½•ä½“ (Geometry)
    const geoBox = new THREE.BoxGeometry(1, 1, 1);       // ç¤¼ç‰©/æ–¹å—
    const geoSphere = new THREE.SphereGeometry(0.6, 16, 16); // å½©çƒ
    const geoCone = new THREE.ConeGeometry(0.6, 1.5, 16);    // å°æ ‘
    const geoTetra = new THREE.TetrahedronGeometry(0.8);     // æ˜Ÿæ˜Ÿ/ç¢ç‰‡

    // é¢„å®šä¹‰å‡ ç§æè´¨é¢œè‰² (Material)
    // ä½¿ç”¨ MeshPhongMaterialï¼Œè¿™æ ·ä¼šæœ‰åå…‰ç«‹ä½“æ„Ÿ
    function getMat(color) {
        return new THREE.MeshPhongMaterial({ 
            color: color, 
            shininess: 100, 
            emissive: color, // è‡ªå‘å…‰ä¸€ç‚¹ç‚¹ï¼Œé˜²æ­¢å¤ªæš—
            emissiveIntensity: 0.3
        });
    }
    
    const matRed = getMat(0xff3333);   // çº¢
    const matGreen = getMat(0x33aa33); // ç»¿
    const matGold = getMat(0xffaa00);  // é‡‘
    const matWhite = getMat(0xffffff); // ç™½
    const matBlue = getMat(0x3333ff);  // è“

    // ç»„åˆæ± 
    const shapes = [
        { geo: geoBox, mat: matRed },    // çº¢ç¤¼ç‰©
        { geo: geoBox, mat: matGold },   // é‡‘ç¤¼ç‰©
        { geo: geoSphere, mat: matRed }, // çº¢çƒ
        { geo: geoSphere, mat: matGold },// é‡‘çƒ
        { geo: geoSphere, mat: matBlue },// è“çƒ
        { geo: geoCone, mat: matGreen }, // ç»¿æ ‘
        { geo: geoTetra, mat: matWhite } // é›ªèŠ±
    ];

    const particles = [];
    const specialParticles = []; // å­˜å‡ ä¸ªç‰¹æ®Šçš„ç”¨æ¥äº¤äº’
    const particleGroup = new THREE.Group();
    scene.add(particleGroup);

    // æ ‘é¡¶å¤§æ˜Ÿæ˜Ÿ
    const topStar = new THREE.Mesh(
        new THREE.OctahedronGeometry(25, 0), 
        new THREE.MeshBasicMaterial({ color: 0xffff00 }) // çº¯è‰²å‘å…‰
    );
    topStar.position.set(0, TREE_HEIGHT/2 + 30, 0);
    topStar.visible = false;
    scene.add(topStar);

    // åˆå§‹åŒ–ç²’å­
    function initParticles() {
        for (let i = 0; i < PARTICLE_COUNT; i++) {
            // éšæœºé€‰ä¸€ä¸ªå½¢çŠ¶
            const shape = shapes[Math.floor(Math.random() * shapes.length)];
            
            // åˆ›å»º Mesh
            const mesh = new THREE.Mesh(shape.geo, shape.mat);
            
            // éšæœºä½ç½®é€»è¾‘ (ä¿æŒä¹‹å‰çš„ç®—æ³•)
            // 1. æ ‘å½¢æ€
            const y = (Math.random() - 0.5) * TREE_HEIGHT; 
            const relY = (y + TREE_HEIGHT/2) / TREE_HEIGHT; 
            const radius = TREE_BASE_RADIUS * (1 - relY) + 20; // +20é˜²æ­¢å¤ªç»†
            const angle = Math.random() * Math.PI * 2 * 8; 
            
            const targetX = Math.cos(angle) * radius;
            const targetY = y;
            const targetZ = Math.sin(angle) * radius;

            // 2. æ•£å¼€å½¢æ€
            const spreadX = (Math.random() - 0.5) * 1500;
            const spreadY = (Math.random() - 0.5) * 1000;
            const spreadZ = (Math.random() - 0.5) * 800;

            mesh.position.set(spreadX, spreadY, spreadZ);
            
            // éšæœºå¤§å° (3Dç‰©ä½“å¤§å°å¤§æ¦‚åœ¨ 10~25 ä¹‹é—´)
            const s = Math.random() * 15 + 10;
            mesh.scale.set(s, s, s);
            
            // éšæœºæ—‹è½¬
            mesh.rotation.set(Math.random()*3, Math.random()*3, Math.random()*3);

            // æ•°æ®ç»‘å®š
            mesh.userData = {
                treePos: new THREE.Vector3(targetX, targetY, targetZ),
                spreadPos: new THREE.Vector3(spreadX, spreadY, spreadZ),
                baseScale: s,
                rotSpeed: { x: Math.random()*0.02, y: Math.random()*0.02 }
            };

            particleGroup.add(mesh);
            particles.push(mesh);
        }

        // â˜… åˆ›å»ºå‡ ä¸ªç‰¹æ®Šçš„â€œé»‘å¡ç‰‡â€æ›¿ä»£å“ (ç”¨çº¢è‰²å¤§æ–¹å—ä»£æ›¿)
        // ç¡®ä¿æåˆæ—¶è‚¯å®šèƒ½çœ‹åˆ°ä¸œè¥¿
        for(let i=0; i<5; i++) {
            const mesh = new THREE.Mesh(geoBox, matRed);
            mesh.position.set((Math.random()-0.5)*500, (Math.random()-0.5)*500, 0);
            mesh.scale.set(30, 30, 5); // æ‰å¹³å¤§æ–¹å—
            
            mesh.userData = {
                treePos: new THREE.Vector3(0, (Math.random()-0.5)*400, 200), // æ ‘ä¸Šæ˜¾çœ¼ä½ç½®
                spreadPos: new THREE.Vector3((Math.random()-0.5)*500, (Math.random()-0.5)*500, 200),
                baseScale: 30,
                rotSpeed: { x: 0.01, y: 0.01 },
                isSpecial: true
            };
            particleGroup.add(mesh);
            specialParticles.push(mesh);
        }
    }

    initParticles();

    // ================= 3. çŠ¶æ€æ§åˆ¶ =================
    
    let currentState = 'spread'; 
    let isPinching = false;
    let activeObj = null; 

    function toTreeState() {
        if (currentState === 'tree') return;
        currentState = 'tree';
        statusText.innerText = "ğŸ„ 3D åœ£è¯æ ‘";
        topStar.visible = true;

        [...particles, ...specialParticles].forEach(p => {
            if (p === activeObj) return; 
            new TWEEN.Tween(p.position)
                .to({ x: p.userData.treePos.x, y: p.userData.treePos.y, z: p.userData.treePos.z }, 1500)
                .easing(TWEEN.Easing.Elastic.Out) // æ¢ä¸ªå¼¹æ€§çš„ç¼“åŠ¨
                .start();
        });
    }

    function toSpreadState() {
        if (currentState === 'spread') return;
        currentState = 'spread';
        statusText.innerText = "âœ¨ è‡ªç”±æµ®åŠ¨";
        topStar.visible = false;

        [...particles, ...specialParticles].forEach(p => {
            if (p === activeObj) return;
            new TWEEN.Tween(p.position)
                .to({ x: p.userData.spreadPos.x, y: p.userData.spreadPos.y, z: p.userData.spreadPos.z }, 2000)
                .easing(TWEEN.Easing.Cubic.Out)
                .start();
        });
    }

    function grabObj() {
        if (isPinching || specialParticles.length === 0) return;
        isPinching = true;
        
        activeObj = specialParticles[Math.floor(Math.random() * specialParticles.length)];
        
        // ç§»åˆ°å±å¹•ä¸­å¤®
        new TWEEN.Tween(activeObj.position)
            .to({ x: 0, y: 50, z: 600 }, 800)
            .easing(TWEEN.Easing.Back.Out)
            .start();

        // æ—‹è½¬å›æ­£
        new TWEEN.Tween(activeObj.rotation)
            .to({ x: 0, y: 0, z: 0 }, 800)
            .start();

        // æ”¾å¤§
        new TWEEN.Tween(activeObj.scale)
            .to({ x: 80, y: 80, z: 10 }, 800) 
            .easing(TWEEN.Easing.Back.Out)
            .start();
            
        // å˜è‰²æç¤º
        activeObj.material.color.setHex(0xffff00); 
        statusText.innerText = "ğŸ æŠ“å–æˆåŠŸï¼";
    }

    function releaseObj() {
        if (!isPinching || !activeObj) return;
        isPinching = false;
        
        activeObj.material.color.setHex(0xff3333); // æ¢å¤çº¢è‰²

        const target = currentState === 'tree' ? activeObj.userData.treePos : activeObj.userData.spreadPos;
        const scale = activeObj.userData.baseScale;

        new TWEEN.Tween(activeObj.position).to(target, 1000).easing(TWEEN.Easing.Back.Out).start();
        new TWEEN.Tween(activeObj.scale).to({x: scale, y: scale, z: 5}, 1000).easing(TWEEN.Easing.Back.Out).start();
        
        activeObj = null;
        statusText.innerText = currentState === 'tree' ? "ğŸ„ 3D åœ£è¯æ ‘" : "âœ¨ è‡ªç”±æµ®åŠ¨";
    }

    // ================= 4. MediaPipe =================
    const videoElement = document.getElementById('input-video');
    const canvasElement = document.getElementById('output-canvas');
    const canvasCtx = canvasElement.getContext('2d');

    function onResults(results) {
        if(statusText.innerText.includes("æ„å»º")) {
             statusText.innerText = "å¼•æ“å°±ç»ªï¼Œè¯·ä¼¸æ‰‹";
        }
        
        canvasCtx.save();
        canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
        canvasCtx.drawImage(results.image, 0, 0, canvasElement.width, canvasElement.height);

        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
            const landmarks = results.multiHandLandmarks[0];
            drawConnectors(canvasCtx, landmarks, HAND_CONNECTIONS, {color: '#00FF00', lineWidth: 2});
            drawLandmarks(canvasCtx, landmarks, {color: '#FF0000', lineWidth: 1, radius: 2});

            const wrist = landmarks[0];
            const middleTip = landmarks[12];
            const palmDist = Math.sqrt(Math.pow(middleTip.x - wrist.x, 2) + Math.pow(middleTip.y - wrist.y, 2));

            const thumbTip = landmarks[4];
            const indexTip = landmarks[8];
            const pinchDist = Math.sqrt(Math.pow(thumbTip.x - indexTip.x, 2) + Math.pow(thumbTip.y - indexTip.y, 2));

            if (pinchDist < 0.05) { 
                grabObj();
            } else {
                releaseObj();
            }

            if (!isPinching) {
                if (palmDist < 0.25) {
                    toTreeState(); 
                } else if (palmDist > 0.35) {
                    toSpreadState(); 
                }
            }
        }
        canvasCtx.restore();
    }

    const hands = new Hands({locateFile: (file) => {
        return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
    }});
    hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
    hands.onResults(onResults);

    const cameraUtils = new Camera(videoElement, {
        onFrame: async () => { await hands.send({image: videoElement}); },
        width: 320, height: 240
    });
    cameraUtils.start();

    // ================= 5. æ¸²æŸ“å¾ªç¯ =================
    function animate(time) {
        requestAnimationFrame(animate);
        TWEEN.update(time); 

        // æ•´ä½“æ—‹è½¬
        if (currentState === 'tree' && !isPinching) {
            particleGroup.rotation.y += 0.005;
            topStar.rotation.y -= 0.02;
        } else if (currentState === 'spread') {
            particleGroup.rotation.y += 0.001;
        }

        // è®©æ¯ä¸ªå°ç§¯æœ¨è‡ªå·±ä¹Ÿè½¬èµ·æ¥ï¼Œæ›´æœ‰åŠ¨æ„Ÿ
        particles.forEach(p => {
            p.rotation.x += p.userData.rotSpeed.x;
            p.rotation.y += p.userData.rotSpeed.y;
        });

        renderer.render(scene, camera);
    }
    animate();

    window.addEventListener('resize', () => {
        if(!container) return;
        width = container.clientWidth;
        height = container.clientHeight;
        camera.aspect = width / height;
        camera.updateProjectionMatrix();
        renderer.setSize(width, height);
    });

</script>