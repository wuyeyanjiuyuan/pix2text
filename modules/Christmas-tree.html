<style>
    /* å®¹å™¨æ ·å¼ */
    #tree-container {
        position: relative; width: 100%; height: 600px;
        background: #000000; 
        border-radius: 12px; overflow: hidden;
        box-shadow: 0 10px 40px rgba(0,0,0,0.9);
        cursor: crosshair; 
    }
    
    #tree-canvas { 
        width: 100%; height: 100%; display: block; 
        position: absolute; top: 0; left: 0; z-index: 1;
    }
    
    /* UI å±‚ */
    .ui-layer {
        position: absolute; top: 20px; left: 20px; z-index: 10;
        pointer-events: none; 
    }
    
    .status-pill {
        display: inline-block; padding: 8px 16px;
        background: rgba(255, 215, 0, 0.1); 
        border: 1px solid rgba(255, 215, 0, 0.3);
        border-radius: 30px; backdrop-filter: blur(5px);
        font-family: 'Segoe UI', sans-serif; font-size: 14px; 
        color: #ffdd44; text-shadow: 0 0 10px rgba(255, 200, 0, 0.5);
        margin-bottom: 12px; transition: all 0.3s;
    }
    
    .upload-btn {
        pointer-events: auto; cursor: pointer;
        display: inline-flex; align-items: center; gap: 8px;
        padding: 10px 20px; 
        background: linear-gradient(135deg, #b8860b, #daa520); 
        border: 1px solid rgba(255, 255, 255, 0.3); 
        color: #fff; font-weight: bold; text-shadow: 0 1px 2px rgba(0,0,0,0.3);
        border-radius: 25px; font-size: 14px; 
        box-shadow: 0 4px 15px rgba(218, 165, 32, 0.3);
        transition: transform 0.2s;
    }
    .upload-btn:hover { transform: translateY(-2px); filter: brightness(1.2); }
    #file-input { display: none; }

    .cam-box {
        position: absolute; bottom: 20px; right: 20px;
        width: 120px; height: 90px; border-radius: 8px; overflow: hidden;
        border: 1px solid rgba(255,215,0,0.3); z-index: 10; background: #000;
    }
    #input-video { position: absolute; opacity: 0; pointer-events: none; }
    #output-canvas { width: 100%; height: 100%; transform: scaleX(-1); }
</style>

<div id="tree-container">
    <div class="ui-layer">
        <div id="status-text" class="status-pill">æ­£åœ¨éƒ¨ç½²å‡åŒ€åŠ›åœº...</div>
        <br>
        <label class="upload-btn">
            ğŸ“· ä¸Šä¼ ç…§ç‰‡
            <input type="file" id="file-input" accept="image/*" multiple>
        </label>
        <div style="margin-top:12px; font-size:12px; color:rgba(255,255,255,0.5); line-height:1.6;">
            ğŸ–ï¸ æ‰‹åœ¨ä¸­å¿ƒ=åˆ¹è½¦ | æ‰‹åœ¨è¾¹ç¼˜=åŠ é€Ÿ<br>
            âœŠ æ¡æ‹³ï¼šèšåˆ | ğŸ‘Œ æåˆï¼šæŠ“å–
        </div>
    </div>

    <div class="cam-box"><canvas id="output-canvas"></canvas></div>
    <video id="input-video" playsinline></video>
    <div id="tree-canvas"></div>
</div>

<script src="js/three.min.js"></script>
<script src="js/tween.umd.js"></script>
<script src="js/camera_utils.js"></script>
<script src="js/control_utils.js"></script>
<script src="js/drawing_utils.js"></script>
<script src="js/hands.js"></script>

<script>
    console.log(">>> [ChristmasTree] å®Œç¾äº¤äº’ç‰ˆå¯åŠ¨");

    try {
        const container = document.getElementById('tree-canvas');
        const statusText = document.getElementById('status-text');
        
        if (!container) throw new Error("å®¹å™¨æœªæ‰¾åˆ°");

        let width = container.clientWidth || 800;
        let height = container.clientHeight || 600;

        // ================= 1. åœºæ™¯åˆå§‹åŒ– =================
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000000, 0.0004); 

        const camera = new THREE.PerspectiveCamera(60, width / height, 1, 5000);
        camera.position.set(0, 0, 900); 

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(width, height);
        renderer.setPixelRatio(window.devicePixelRatio);
        container.appendChild(renderer.domElement);

        // ================= 2. æè´¨ä¸çº¹ç† =================
        
        function createGoldOrbTexture() {
            const cvs = document.createElement('canvas');
            cvs.width = 64; cvs.height = 64;
            const ctx = cvs.getContext('2d');
            const gradient = ctx.createRadialGradient(32, 32, 0, 32, 32, 32);
            gradient.addColorStop(0, 'rgba(255, 255, 255, 1)');
            gradient.addColorStop(0.3, 'rgba(255, 215, 0, 0.9)'); 
            gradient.addColorStop(0.6, 'rgba(218, 165, 32, 0.4)'); 
            gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 64, 64);
            return new THREE.CanvasTexture(cvs);
        }

        // é—ªå…‰çº¹ç† (æ˜ŸèŠ’)
        function createFlashTexture() {
            const cvs = document.createElement('canvas');
            cvs.width = 64; cvs.height = 64;
            const ctx = cvs.getContext('2d');
            const gradient = ctx.createRadialGradient(32, 32, 0, 32, 32, 32);
            gradient.addColorStop(0, 'rgba(255, 255, 255, 1)'); 
            gradient.addColorStop(0.3, 'rgba(255, 255, 200, 0.9)'); 
            gradient.addColorStop(0.6, 'rgba(255, 220, 100, 0.4)'); 
            gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 64, 64);
            return new THREE.CanvasTexture(cvs);
        }
        
        // æ˜Ÿå°˜çº¹ç†
        function createDotTexture() {
            const cvs = document.createElement('canvas');
            cvs.width = 32; cvs.height = 32;
            const ctx = cvs.getContext('2d');
            const gradient = ctx.createRadialGradient(16, 16, 0, 16, 16, 16);
            gradient.addColorStop(0, 'rgba(255, 255, 255, 1)');
            gradient.addColorStop(0.5, 'rgba(200, 220, 255, 0.5)'); 
            gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 32, 32);
            return new THREE.CanvasTexture(cvs);
        }

        const goldTex = createGoldOrbTexture();
        const flashTex = createFlashTexture();
        const dotTex = createDotTexture();

        const matGoldHigh = new THREE.SpriteMaterial({ 
            map: goldTex, color: 0xffffff, transparent: true, opacity: 1.0, blending: THREE.AdditiveBlending 
        });
        const matGoldMid = new THREE.SpriteMaterial({ 
            map: goldTex, color: 0xffddaa, transparent: true, opacity: 0.7, blending: THREE.AdditiveBlending 
        });
        const matGoldLow = new THREE.SpriteMaterial({ 
            map: goldTex, color: 0xaa8844, transparent: true, opacity: 0.4, blending: THREE.AdditiveBlending 
        });
        const goldMats = [matGoldHigh, matGoldMid, matGoldLow];

        // ================= 3. ç²’å­ç³»ç»Ÿ =================
        
        const PARTICLE_COUNT = 2000; 
        const DUST_COUNT = 1500; // â˜… æ˜Ÿå°˜å¢è‡³3å€
        const FLASH_COUNT = 100;      
        
        const TREE_HEIGHT = 650;
        const TREE_BASE_RADIUS = 300;

        const particleGroup = new THREE.Group();
        const dustGroup = new THREE.Group();  
        const flashGroup = new THREE.Group(); 
        
        // æ¸²æŸ“é¡ºåº
        scene.add(dustGroup);     
        scene.add(particleGroup); 
        scene.add(flashGroup);    

        const particles = [];
        const photoMeshes = []; 
        
        // 3.1 äº”è§’æ˜Ÿæ ‘é¡¶
        function createStarGeometry(radius, thickness) {
            const shape = new THREE.Shape();
            const points = 5;
            for (let i = 0; i < points * 2; i++) {
                const l = i % 2 == 1 ? radius * 0.5 : radius;
                const a = i / points * Math.PI;
                const angle = a + Math.PI / 2;
                const x = Math.cos(angle) * l;
                const y = Math.sin(angle) * l;
                if (i === 0) shape.moveTo(x, y);
                else shape.lineTo(x, y);
            }
            shape.closePath();
            const extrudeSettings = { depth: thickness, bevelEnabled: true, bevelThickness: 2, bevelSize: 1, bevelSegments: 2 };
            return new THREE.ExtrudeGeometry(shape, extrudeSettings);
        }

        const topStar = new THREE.Mesh(
            createStarGeometry(30, 8),
            new THREE.MeshBasicMaterial({ color: 0xffffaa }) 
        );
        topStar.position.set(0, TREE_HEIGHT/2 + 30, 0);
        topStar.visible = false;
        scene.add(topStar);

        // 3.2 ç”Ÿæˆä¸»ç²’å­
        for (let i = 0; i < PARTICLE_COUNT; i++) {
            const mat = goldMats[Math.floor(Math.random() * goldMats.length)];
            const sprite = new THREE.Sprite(mat);
            createParticleData(sprite, false);
            particleGroup.add(sprite);
            particles.push(sprite);
        }
        
        // 3.3 ç”ŸæˆèƒŒæ™¯æ˜Ÿå°˜
        for (let i = 0; i < DUST_COUNT; i++) {
            const mat = new THREE.SpriteMaterial({
                map: dotTex, color: 0xffffff, 
                transparent: true, opacity: 0.6 + Math.random()*0.4, 
                blending: THREE.AdditiveBlending
            });
            const sprite = new THREE.Sprite(mat);
            
            const r = 800 + Math.random() * 800; // èŒƒå›´æ›´å¤§
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.acos(2 * Math.random() - 1);
            
            sprite.position.set(
                r * Math.sin(phi) * Math.cos(theta),
                r * Math.sin(phi) * Math.sin(theta),
                r * Math.cos(phi)
            );
            const s = Math.random() * 4 + 2;
            sprite.scale.set(s, s, 1);
            
            // æ˜Ÿå°˜ä¸å‚ä¸èšæ•£ï¼Œä¸€ç›´ç¯ç»•
            dustGroup.add(sprite);
        }

        // 3.4 é—ªå…‰æ± 
        const flashPool = [];
        for(let i=0; i<FLASH_COUNT; i++) {
            const mat = new THREE.SpriteMaterial({
                map: flashTex,
                color: 0xffaa00, 
                transparent: true,
                opacity: 0,
                blending: THREE.AdditiveBlending, 
                depthWrite: false
            });
            const sprite = new THREE.Sprite(mat);
            sprite.visible = false;
            // ç»‘å®šæ•°æ®ï¼Œç”¨äºè·Ÿéš
            sprite.userData = { target: null };
            flashGroup.add(sprite);
            flashPool.push(sprite);
        }

        function createParticleData(obj, isPhoto) {
            const y = (Math.random() - 0.5) * TREE_HEIGHT; 
            const relY = (y + TREE_HEIGHT/2) / TREE_HEIGHT; 
            const radius = TREE_BASE_RADIUS * Math.pow((1 - relY), 0.8) * (0.8 + Math.random()*0.4); 
            const angle = Math.random() * Math.PI * 2 * 12;
            const treePos = new THREE.Vector3(Math.cos(angle)*radius, y, Math.sin(angle)*radius);

            const maxR = 550; 
            const r = maxR * Math.cbrt(Math.random()); 
            const theta = Math.random() * Math.PI * 2; 
            const phi = Math.acos(2 * Math.random() - 1); 
            const spreadPos = new THREE.Vector3(
                r * Math.sin(phi) * Math.cos(theta),
                r * Math.sin(phi) * Math.sin(theta),
                r * Math.cos(phi)
            );

            obj.position.copy(spreadPos);
            
            let baseScale = Math.random() * 15 + 8; 
            if (isPhoto) baseScale = 50; 
            
            obj.scale.set(baseScale, baseScale, baseScale);

            obj.userData = {
                treePos: treePos,
                spreadPos: spreadPos,
                baseScale: baseScale,
                isPhoto: isPhoto,
                aspect: obj.userData.aspect || 1
            };
        }

        // ================= 4. ç…§ç‰‡ä¸Šä¼  (å‡åŒ€åˆ†å¸ƒç®—æ³•) =================
        const fileInput = document.getElementById('file-input');
        
        fileInput.addEventListener('change', function(e) {
            if (this.files.length > 0) {
                statusText.innerText = `é•€é‡‘ ${this.files.length} å¼ ç…§ç‰‡...`;
                Array.from(this.files).forEach((file) => {
                    const reader = new FileReader();
                    reader.onload = function(event) {
                        const img = new Image();
                        img.src = event.target.result;
                        img.onload = () => {
                            const aspect = img.width / img.height;
                            const tex = new THREE.TextureLoader().load(img.src);
                            tex.minFilter = THREE.LinearFilter; 
                            addPhotoMesh(tex, aspect);
                        }
                    };
                    reader.readAsDataURL(file);
                });
                setTimeout(() => statusText.innerText = "ç…§ç‰‡å·²æ‚¬æŒ‚ï¼æåˆæŸ¥çœ‹", 1500);
            }
        });

        function addPhotoMesh(texture, aspect) {
            const geo = new THREE.BoxGeometry(1, 1, 0.05);
            const matPhoto = new THREE.MeshBasicMaterial({ map: texture });
            const matGold = new THREE.MeshBasicMaterial({ color: 0xffd700 }); 
            const materials = [matGold, matGold, matGold, matGold, matPhoto, matGold];
            
            const mesh = new THREE.Mesh(geo, materials);
            mesh.userData.aspect = aspect;
            
            // â˜…â˜…â˜… æ ¸å¿ƒï¼šå‡åŒ€åˆ†å¸ƒç®—æ³• â˜…â˜…â˜…
            // éšæœºé‡‡æ · 10 ä¸ªå€™é€‰ç‚¹ï¼Œé€‰ç¦»å…¶ä»–ç…§ç‰‡æœ€è¿œçš„é‚£ä¸ª
            let bestIdx = -1;
            let maxMinDist = -1;
            
            for(let k=0; k<10; k++) {
                // éšæœºæ‰¾ä¸€ä¸ªéç…§ç‰‡çš„ç²’å­
                let tryIdx = Math.floor(Math.random() * particles.length);
                let safety = 0;
                while((particles[tryIdx].userData.isPhoto || particles[tryIdx].userData.isDust) && safety < 100) {
                    tryIdx = Math.floor(Math.random() * particles.length);
                    safety++;
                }
                
                const candidate = particles[tryIdx];
                
                // è®¡ç®—è¯¥å€™é€‰ç‚¹ä¸å·²å­˜åœ¨ç…§ç‰‡çš„æœ€å°è·ç¦»
                let minDist = Infinity;
                if (photoMeshes.length === 0) {
                    minDist = Infinity; // ç¬¬ä¸€å¼ ç…§ç‰‡éšä¾¿æ”¾
                } else {
                    for(let p of photoMeshes) {
                        // æ¯”è¾ƒ TreePos (æŒ‚åœ¨æ ‘ä¸Šçš„ä½ç½®)
                        const d = candidate.userData.treePos.distanceTo(p.userData.treePos);
                        if(d < minDist) minDist = d;
                    }
                }
                
                // å¦‚æœè¿™ä¸ªå€™é€‰ç‚¹çš„â€œæœ€å°è·ç¦»â€æ¯”ä¹‹å‰çš„éƒ½å¤§ï¼Œè¯´æ˜å®ƒæ›´ç¨€ç–ï¼Œæ›´å¥½
                if (minDist > maxMinDist) {
                    maxMinDist = minDist;
                    bestIdx = tryIdx;
                }
            }
            
            // ä½¿ç”¨é€‰å‡ºçš„æœ€ä½³ä½ç½®
            const oldSprite = particles[bestIdx];
            createParticleData(mesh, true);
            // å¼ºåˆ¶è¦†ç›–ä¸ºæ—§ç²’å­çš„ä½ç½®æ•°æ®ï¼Œä¿è¯ä½ç½®ä¸€è‡´
            mesh.userData.treePos.copy(oldSprite.userData.treePos);
            
            // ç»§æ‰¿å½“å‰è§†è§‰ä½ç½®
            mesh.position.copy(oldSprite.position);
            mesh.scale.set(0,0,0);
            
            particleGroup.remove(oldSprite);
            particles.splice(bestIdx, 1);
            
            particleGroup.add(mesh);
            photoMeshes.push(mesh);
            
            const h = 50; 
            const w = h * aspect;
            new TWEEN.Tween(mesh.scale).to({x:w, y:h, z:2}, 800).easing(TWEEN.Easing.Elastic.Out).start();
        }

        // ================= 5. äº¤äº’çŠ¶æ€ =================
        let currentState = 'spread'; 
        let isPinching = false;
        let activePhoto = null; 
        
        let handPos = { x: 0, y: 0 };
        let isHandDetected = false;
        let rotVelocity = { x: 0, y: 0 };
        
        const MAX_SPEED = 0.03;  
        const FRICTION_IDLE = 0.98; 
        const FRICTION_BRAKE = 0.85; 
        const ACCELERATION = 0.002; 
        const DEAD_ZONE = 0.15; 

        function toTreeState() {
            if (currentState === 'tree') return;
            currentState = 'tree';
            statusText.innerText = "ğŸ„ åœ£è¯æ ‘å·²èšåˆ";
            topStar.visible = true;

            [...particles, ...photoMeshes].forEach(p => {
                if (p === activePhoto) return; 
                new TWEEN.Tween(p.position)
                    .to(p.userData.treePos, 1500)
                    .easing(TWEEN.Easing.Exponential.InOut)
                    .start();
            });
        }

        function toSpreadState() {
            if (currentState === 'spread') return;
            currentState = 'spread';
            statusText.innerText = "âœ¨ æ˜Ÿæ²³æ“æ§æ¨¡å¼";
            topStar.visible = false;

            [...particles, ...photoMeshes].forEach(p => {
                if (p === activePhoto) return;
                new TWEEN.Tween(p.position)
                    .to(p.userData.spreadPos, 2000)
                    .easing(TWEEN.Easing.Cubic.Out)
                    .start();
            });
        }

        function grabPhoto() {
            if (isPinching || photoMeshes.length === 0) return;
            
            let closestDist = Infinity;
            let closestPhoto = null;
            const worldPos = new THREE.Vector3();
            
            photoMeshes.forEach(p => {
                p.getWorldPosition(worldPos);
                const d = camera.position.distanceTo(worldPos);
                if(d < closestDist) {
                    closestDist = d;
                    closestPhoto = p;
                }
            });
            
            if(!closestPhoto) return;
            
            isPinching = true;
            activePhoto = closestPhoto;
            
            scene.attach(activePhoto);

            new TWEEN.Tween(activePhoto.position)
                .to({ x: 0, y: 0, z: 600 }, 600)
                .easing(TWEEN.Easing.Back.Out)
                .start();

            new TWEEN.Tween(activePhoto.rotation)
                .to({ x: 0, y: 0, z: 0 }, 600)
                .start();

            const MAX_H = 220; 
            const MAX_W = 400;
            const aspect = activePhoto.userData.aspect;
            
            let targetH = MAX_H;
            let targetW = targetH * aspect;
            
            if (targetW > MAX_W) {
                targetW = MAX_W;
                targetH = targetW / aspect;
            }
            
            new TWEEN.Tween(activePhoto.scale)
                .to({ x: targetW, y: targetH, z: 5 }, 600)
                .easing(TWEEN.Easing.Back.Out)
                .start();
                
            statusText.innerText = "ğŸ–¼ï¸ å›å¿†æ—¶åˆ»";
        }

        function releasePhoto() {
            if (!isPinching || !activePhoto) return;
            isPinching = false;
            
            particleGroup.attach(activePhoto);

            const target = currentState === 'tree' ? activePhoto.userData.treePos : activePhoto.userData.spreadPos;
            const h = 50; 
            const w = h * activePhoto.userData.aspect;

            new TWEEN.Tween(activePhoto.position).to(target, 800).easing(TWEEN.Easing.Exponential.Out).start();
            new TWEEN.Tween(activePhoto.scale).to({x: w, y: h, z: 2}, 800).easing(TWEEN.Easing.Exponential.Out).start();
            
            activePhoto = null;
            statusText.innerText = currentState === 'tree' ? "ğŸ„ åœ£è¯æ ‘" : "âœ¨ æµé‡‘";
        }

        // ================= 6. MediaPipe æ‰‹åŠ¿ =================
        const videoElement = document.getElementById('input-video');
        const canvasElement = document.getElementById('output-canvas');
        const canvasCtx = canvasElement.getContext('2d');

        function onResults(results) {
            if(statusText.innerText.includes("åˆå§‹åŒ–")) {
                 statusText.innerText = "å¼•æ“å°±ç»ªï¼Œè¯·ä¸Šä¼ ç…§ç‰‡";
            }
            canvasCtx.save();
            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
            canvasCtx.drawImage(results.image, 0, 0, canvasElement.width, canvasElement.height);

            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                isHandDetected = true;
                const landmarks = results.multiHandLandmarks[0];
                drawConnectors(canvasCtx, landmarks, HAND_CONNECTIONS, {color: '#00FF00', lineWidth: 2});
                drawLandmarks(canvasCtx, landmarks, {color: '#FF0000', lineWidth: 1, radius: 2});

                const cx = (landmarks[0].x + landmarks[9].x) / 2;
                const cy = (landmarks[0].y + landmarks[9].y) / 2;
                handPos.x = (0.5 - cx) * 2; 
                handPos.y = (0.5 - cy) * 2; 

                const wrist = landmarks[0];
                const middleTip = landmarks[12];
                const palmDist = Math.sqrt(Math.pow(middleTip.x - wrist.x, 2) + Math.pow(middleTip.y - wrist.y, 2));

                const thumbTip = landmarks[4];
                const indexTip = landmarks[8];
                const pinchDist = Math.sqrt(Math.pow(thumbTip.x - indexTip.x, 2) + Math.pow(thumbTip.y - indexTip.y, 2));

                if (pinchDist < 0.05) grabPhoto();
                else releasePhoto();

                if (!isPinching) {
                    if (palmDist < 0.25) toTreeState(); 
                    else if (palmDist > 0.35) toSpreadState(); 
                }
            } else {
                isHandDetected = false;
            }
            canvasCtx.restore();
        }

        const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
        hands.setOptions({maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5});
        hands.onResults(onResults);

        const cameraUtils = new Camera(videoElement, {
            onFrame: async () => { await hands.send({image: videoElement}); },
            width: 320, height: 240
        });
        cameraUtils.start();

        // ================= 7. æ¸²æŸ“å¾ªç¯ (å«é—ªå…‰è·Ÿéš) =================
        function animate(time) {
            requestAnimationFrame(animate);
            TWEEN.update(time); 

            // A. æ—‹è½¬é€»è¾‘
            if (currentState === 'spread' && !isPinching) {
                if (isHandDetected) {
                    const dist = Math.sqrt(handPos.x*handPos.x + handPos.y*handPos.y);
                    if (dist < DEAD_ZONE) {
                        rotVelocity.x *= FRICTION_BRAKE;
                        rotVelocity.y *= FRICTION_BRAKE;
                        if(Math.abs(rotVelocity.x) < 0.0001) rotVelocity.x = 0;
                        if(Math.abs(rotVelocity.y) < 0.0001) rotVelocity.y = 0;
                    } else {
                        const targetSpeedX = -handPos.y * MAX_SPEED; 
                        const targetSpeedY = handPos.x * MAX_SPEED; 
                        rotVelocity.x += (targetSpeedX - rotVelocity.x) * ACCELERATION * 10;
                        rotVelocity.y += (targetSpeedY - rotVelocity.y) * ACCELERATION * 10;
                    }
                } else {
                    rotVelocity.x *= FRICTION_IDLE;
                    rotVelocity.y *= FRICTION_IDLE;
                }
                particleGroup.rotation.x += rotVelocity.x;
                particleGroup.rotation.y += rotVelocity.y;
                
            } else if (currentState === 'tree' && !isPinching) {
                particleGroup.rotation.y += 0.005;
                particleGroup.rotation.x *= 0.9; 
            }
            
            // æ˜Ÿå°˜åå‘æ…¢è½¬
            dustGroup.rotation.y -= 0.0005;

            // B. â˜…â˜…â˜… é—ªå…‰ç‰¹æ•ˆä¸ä½ç½®æ›´æ–° â˜…â˜…â˜…
            let activeFlashCount = 0;
            flashGroup.children.forEach(f => { 
                if(f.visible) {
                    activeFlashCount++;
                    // â˜… æ ¸å¿ƒï¼šå®æ—¶è·Ÿéšç›®æ ‡ç²’å­ â˜…
                    if(f.userData.target) {
                        const worldPos = new THREE.Vector3();
                        // è·å–ç›®æ ‡ç²’å­çš„å½“å‰ä¸–ç•Œåæ ‡
                        f.userData.target.getWorldPosition(worldPos);
                        f.position.copy(worldPos);
                    }
                } 
            });
            
            if (activeFlashCount < 30 && Math.random() < 0.5) {
                triggerRandomFlash();
            }

            renderer.render(scene, camera);
        }
        animate();

        // è§¦å‘é—ªå…‰ (ç»‘å®šç›®æ ‡)
        function triggerRandomFlash() {
            const flash = flashGroup.children.find(s => !s.visible);
            if (!flash) return;

            const target = particles[Math.floor(Math.random() * particles.length)];
            
            // â˜… ç»‘å®šç›®æ ‡ç²’å­åˆ°é—ªå…‰å¯¹è±¡ä¸Š
            flash.userData.target = target;
            
            // ç«‹å³åŒæ­¥ä¸€æ¬¡ä½ç½®
            const worldPos = new THREE.Vector3();
            target.getWorldPosition(worldPos);
            flash.position.copy(worldPos);
            
            flash.visible = true;
            flash.material.opacity = 1;
            flash.material.rotation = Math.random() * Math.PI; 
            flash.scale.set(0, 0, 1);

            new TWEEN.Tween(flash.scale)
                .to({ x: 80, y: 80 }, 50)
                .easing(TWEEN.Easing.Quadratic.Out)
                .onComplete(() => {
                    new TWEEN.Tween(flash.material)
                        .to({ opacity: 0 }, 100)
                        .onComplete(() => { 
                            flash.visible = false; 
                            flash.userData.target = null; // é‡Šæ”¾ç»‘å®š
                        })
                        .start();
                })
                .start();
        }

        window.addEventListener('resize', () => {
            if(!container) return;
            width = container.clientWidth;
            height = container.clientHeight;
            camera.aspect = width / height;
            camera.updateProjectionMatrix();
            renderer.setSize(width, height);
        });

    } catch (e) {
        console.error(e);
        document.getElementById('status-text').innerText = "âŒ é”™è¯¯: " + e.message;
        document.getElementById('status-text').style.backgroundColor = "red";
    }
</script>