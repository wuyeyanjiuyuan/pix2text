<style>
    /* å®¹å™¨æ ·å¼ */
    #tree-container {
        position: relative; width: 100%; height: 600px;
        /* é»˜è®¤æ·±ç°èƒŒæ™¯ï¼Œå¦‚æœå˜çº¢è¯´æ˜æŠ¥é”™ï¼Œå˜è“è¯´æ˜æˆåŠŸ */
        background: #111; 
        border-radius: 12px; overflow: hidden;
        box-shadow: 0 10px 30px rgba(0,0,0,0.2);
    }
    
    /* â˜…â˜…â˜… ä¿®æ­£ç‚¹ï¼šè¿™é‡Œçš„ ID æ”¹ä¸º tree-canvas ä»¥åŒ¹é… JS â˜…â˜…â˜… */
    #tree-canvas { 
        width: 100%; height: 100%; display: block; 
        position: absolute; top: 0; left: 0; z-index: 1;
    }
    
    .ui-layer {
        position: absolute; top: 20px; left: 20px; z-index: 10;
        pointer-events: none; 
    }
    .status-pill {
        display: inline-block; padding: 8px 16px;
        background: rgba(255, 255, 255, 0.2); 
        border: 1px solid rgba(255, 255, 255, 0.5);
        border-radius: 30px; color: #fff; font-size: 14px;
        backdrop-filter: blur(4px);
    }
    
    .cam-box {
        position: absolute; bottom: 20px; right: 20px;
        width: 120px; height: 90px; border-radius: 8px; overflow: hidden;
        border: 2px solid white; z-index: 10; background: #000;
    }
    #input-video { position: absolute; opacity: 0; pointer-events: none; }
    #output-canvas { width: 100%; height: 100%; transform: scaleX(-1); }
</style>

<div id="tree-container">
    <div class="ui-layer">
        <div id="status-text" class="status-pill">è°ƒè¯•æ¨¡å¼ï¼šæ­£åœ¨å¯åŠ¨...</div>
        <div style="margin-top:10px; font-size:12px; color:white;">
            âœŠ æ¡æ‹³ï¼šèšåˆ | ğŸ‘Œ æåˆï¼šæŠ“å–
        </div>
    </div>

    <div class="cam-box"><canvas id="output-canvas"></canvas></div>
    <video id="input-video" playsinline></video>
    
    <div id="tree-canvas"></div>
</div>

<script src="js/three.min.js"></script>
<script src="js/tween.umd.js"></script>
<script src="js/camera_utils.js"></script>
<script src="js/control_utils.js"></script>
<script src="js/drawing_utils.js"></script>
<script src="js/hands.js"></script>

<script>
    console.log(">>> [Debug] è„šæœ¬å¼€å§‹æ‰§è¡Œ");

    try {
        // 1. è·å–å®¹å™¨ (ID å¿…é¡»åŒ¹é… HTML ä¸­çš„ id="tree-canvas")
        const container = document.getElementById('tree-canvas');
        if (!container) throw new Error("æ‰¾ä¸åˆ° #tree-canvasï¼Œè¯·æ£€æŸ¥ HTML ID");

        // 2. å°ºå¯¸æ£€æŸ¥
        let width = container.clientWidth;
        let height = container.clientHeight;
        
        // å…œåº•å°ºå¯¸ (é˜²æ­¢å®¹å™¨æœªæ¸²æŸ“æ—¶å°ºå¯¸ä¸º0)
        if (!width || width === 0) width = 800;
        if (!height || height === 0) height = 600;

        // 3. åˆå§‹åŒ–åœºæ™¯
        const scene = new THREE.Scene();
        // â˜…â˜…â˜… æˆåŠŸæ ‡å¿—ï¼šå¦‚æœä½ çœ‹åˆ°è¿™ä¸ªæ·±è“è‰²ï¼Œè¯´æ˜ Three.js è·‘é€šäº† â˜…â˜…â˜…
        scene.background = new THREE.Color(0x000055); 

        const camera = new THREE.PerspectiveCamera(60, width / height, 1, 5000);
        camera.position.set(0, 100, 800); 

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(width, height);
        renderer.setPixelRatio(window.devicePixelRatio);
        
        // æ¸…ç†æ—§ç”»å¸ƒ (é˜²æ­¢çƒ­é‡è½½å †å )
        while(container.firstChild) { container.removeChild(container.firstChild); }
        container.appendChild(renderer.domElement);

        // 4. åˆ›å»ºå‡ ä½•ä½“ (ä¸ä¾èµ–çº¹ç†ï¼Œä¸ä¾èµ–ç¯å…‰ï¼Œåªè¦æ¸²æŸ“å™¨å·¥ä½œå°±èƒ½çœ‹è§)
        const particleGroup = new THREE.Group();
        scene.add(particleGroup);

        const geoBox = new THREE.BoxGeometry(15, 15, 15);
        // ä½¿ç”¨ Basic æè´¨ï¼Œå®ƒæ˜¯è‡ªå‘å…‰çš„ï¼Œç»å¯¹ä¸ä¼šé»‘
        const matRed = new THREE.MeshBasicMaterial({ color: 0xff3333 });
        const matGreen = new THREE.MeshBasicMaterial({ color: 0x33ff33 });
        const matYellow = new THREE.MeshBasicMaterial({ color: 0xffff33 });
        const mats = [matRed, matGreen, matYellow];

        const particles = [];
        const PARTICLE_COUNT = 400;

        for(let i=0; i<PARTICLE_COUNT; i++) {
            const mat = mats[Math.floor(Math.random() * mats.length)];
            const mesh = new THREE.Mesh(geoBox, mat);
            
            // éšæœºæ•£å¼€ä½ç½®
            mesh.position.set(
                (Math.random() - 0.5) * 1200,
                (Math.random() - 0.5) * 800,
                (Math.random() - 0.5) * 800
            );
            
            // è®¡ç®—æ ‘çš„å½¢çŠ¶ä½ç½® (ç›®æ ‡ç‚¹)
            const y = (Math.random() - 0.5) * 600;
            const relY = (y + 300) / 600;
            const radius = 300 * (1 - relY) + 20;
            const angle = Math.random() * Math.PI * 2 * 6;
            
            mesh.userData = {
                spreadPos: mesh.position.clone(),
                treePos: new THREE.Vector3(
                    Math.cos(angle) * radius,
                    y,
                    Math.sin(angle) * radius
                )
            };
            
            particleGroup.add(mesh);
            particles.push(mesh);
        }

        // 5. çŠ¶æ€æ§åˆ¶
        let isTree = false;
        
        function toTree() {
            if(isTree) return;
            isTree = true;
            document.getElementById('status-text').innerText = "çŠ¶æ€ï¼šèšåˆåœ£è¯æ ‘";
            particles.forEach(p => {
                new TWEEN.Tween(p.position).to(p.userData.treePos, 1000).easing(TWEEN.Easing.Quadratic.Out).start();
            });
        }

        function toSpread() {
            if(!isTree) return;
            isTree = false;
            document.getElementById('status-text').innerText = "çŠ¶æ€ï¼šè‡ªç”±æ•£å¼€";
            particles.forEach(p => {
                new TWEEN.Tween(p.position).to(p.userData.spreadPos, 1000).easing(TWEEN.Easing.Quadratic.Out).start();
            });
        }

        // 6. æ¸²æŸ“å¾ªç¯
        function animate(time) {
            requestAnimationFrame(animate);
            TWEEN.update(time);
            
            if(isTree) {
                particleGroup.rotation.y += 0.01;
            } else {
                particleGroup.rotation.y += 0.002;
            }
            
            renderer.render(scene, camera);
        }
        animate();

        // 7. MediaPipe æ‰‹åŠ¿
        const videoElement = document.getElementById('input-video');
        const canvasElement = document.getElementById('output-canvas');
        const canvasCtx = canvasElement.getContext('2d');

        function onResults(results) {
            // åªè¦è¿›è¿™é‡Œï¼Œè¯´æ˜ AI åœ¨å·¥ä½œ
            if(document.getElementById('status-text').innerText.includes("å¯åŠ¨")) {
                document.getElementById('status-text').innerText = "AI å°±ç»ªï¼Œè¯·ä¼¸æ‰‹";
            }

            canvasCtx.save();
            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
            canvasCtx.drawImage(results.image, 0, 0, canvasElement.width, canvasElement.height);
            
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const landmarks = results.multiHandLandmarks[0];
                drawConnectors(canvasCtx, landmarks, HAND_CONNECTIONS, {color: '#00FF00', lineWidth: 2});
                drawLandmarks(canvasCtx, landmarks, {color: '#FF0000', lineWidth: 1, radius: 2});

                const wrist = landmarks[0];
                const middleTip = landmarks[12];
                // ç®€å•çš„è·ç¦»è®¡ç®—
                const dist = Math.sqrt(Math.pow(middleTip.x - wrist.x, 2) + Math.pow(middleTip.y - wrist.y, 2));
                
                // é˜ˆå€¼åˆ¤æ–­
                if(dist < 0.25) toTree();
                else if(dist > 0.4) toSpread();
            }
            canvasCtx.restore();
        }

        const hands = new Hands({locateFile: (file) => {
            // return `js/${file}`; // æœ¬åœ°
            return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`; // CDN
        }});
        hands.setOptions({maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5});
        hands.onResults(onResults);

        const cameraUtils = new Camera(videoElement, {
            onFrame: async () => { await hands.send({image: videoElement}); },
            width: 320, height: 240
        });
        cameraUtils.start();

    } catch (e) {
        console.error(e);
        const status = document.getElementById('status-text');
        if(status) {
            status.innerText = "é”™è¯¯: " + e.message;
            status.style.backgroundColor = "red";
        }
    }
</script>