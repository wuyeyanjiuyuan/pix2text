<style>
    /* === æ•´ä½“å¸ƒå±€ === */
    #drone-app {
        display: flex;
        width: 100%;
        height: 600px;
        background: #111;
        font-family: 'Segoe UI', sans-serif;
        border-radius: 12px;
        overflow: hidden;
        color: #ddd;
    }

    /* === å·¦ä¾§ 3D èˆå° (70%) === */
    #stage-container {
        flex: 7;
        position: relative;
        background: linear-gradient(to bottom, #000 0%, #1a1a1a 100%);
        overflow: hidden;
    }
    #three-canvas-drone { width: 100%; height: 100%; display: block; }
    
    /* æ‘„åƒå¤´é¢„è§ˆ & çŠ¶æ€ */
    .drone-overlay {
        position: absolute; top: 20px; left: 20px; pointer-events: none;
    }
    .status-tag {
        background: rgba(0, 255, 255, 0.1); border: 1px solid cyan;
        color: cyan; padding: 5px 10px; border-radius: 4px;
        font-size: 14px; text-shadow: 0 0 5px cyan; margin-bottom: 5px;
    }
    .cam-preview-box {
        position: absolute; bottom: 10px; left: 10px;
        width: 100px; height: 75px; background: #000;
        border: 1px solid #333; z-index: 5;
    }
    #drone-video { opacity: 0; position: absolute; pointer-events: none; }
    #drone-mask-canvas { width: 100%; height: 100%; transform: scaleX(-1); }

    /* === å³ä¾§ æ§åˆ¶å° (30%) === */
    #controls-panel {
        flex: 3;
        background: #1e1e1e;
        border-left: 1px solid #333;
        display: flex;
        flex-direction: column;
        user-select: none;
    }

    /* 1. å…¨å±€è®¾ç½®æ  */
    .panel-section {
        padding: 15px;
        border-bottom: 1px solid #333;
    }
    .panel-title { font-size: 14px; color: #888; margin-bottom: 10px; text-transform: uppercase; letter-spacing: 1px; }
    
    .input-row { display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px; }
    .input-row label { font-size: 12px; }
    input[type="number"] { width: 50px; background: #333; border: none; color: white; padding: 4px; border-radius: 3px; }
    input[type="checkbox"] { accent-color: cyan; }

    /* 2. ç§¯æœ¨æ—¶é—´è½´ (æ ¸å¿ƒ) */
    #timeline-container {
        flex: 1;
        overflow-y: auto;
        padding: 15px;
        background: #151515;
    }
    .timeline-layer {
        background: #252525;
        border-radius: 6px;
        margin-bottom: 10px;
        padding: 8px;
        border: 1px solid #333;
        display: flex;
        flex-wrap: wrap;
        gap: 5px;
        align-items: center;
        min-height: 40px;
        position: relative;
    }
    .layer-index { 
        position: absolute; left: -10px; top: 50%; transform: translateY(-50%); 
        font-size: 10px; color: #555; 
    }
    /* ç§¯æœ¨å— */
    .block-item {
        background: #3a3a3a;
        padding: 5px 10px;
        border-radius: 4px;
        font-size: 12px;
        cursor: pointer;
        border: 1px solid #555;
        display: flex;
        align-items: center;
        gap: 5px;
    }
    .block-item.configured { border-color: cyan; color: cyan; }
    .block-color-dot { width: 8px; height: 8px; border-radius: 50%; background: #fff; }
    
    .add-btn {
        width: 24px; height: 24px; border-radius: 4px;
        border: 1px dashed #666; color: #666;
        display: flex; align-items: center; justify-content: center;
        cursor: pointer; transition: 0.2s;
    }
    .add-btn:hover { border-color: cyan; color: cyan; }

    /* å¼¹å‡ºé…ç½®æ¡† */
    #config-popup {
        display: none;
        position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
        width: 260px; background: #2a2a2a; border: 1px solid #444;
        box-shadow: 0 10px 40px rgba(0,0,0,0.8);
        z-index: 100; border-radius: 8px; padding: 15px;
    }
    .popup-row { margin-bottom: 12px; }
    select, input[type="text"] { width: 100%; background: #111; border: 1px solid #444; color: white; padding: 6px; border-radius: 4px; margin-top: 4px;}
    .popup-btns { display: flex; justify-content: flex-end; gap: 10px; margin-top: 15px; }
    .btn { padding: 5px 12px; border-radius: 4px; border: none; cursor: pointer; font-size: 12px; }
    .btn-cancel { background: #444; color: #ccc; }
    .btn-confirm { background: cyan; color: #000; font-weight: bold; }

    /* é®ç½© */
    #popup-overlay {
        display: none; position: absolute; top: 0; left: 0; width: 100%; height: 100%;
        background: rgba(0,0,0,0.5); z-index: 90;
    }
</style>

<div id="drone-app">
    <div id="stage-container">
        <div class="drone-overlay">
            <div id="sys-status" class="status-tag">System Ready</div>
            <div id="gesture-hint" style="font-size:12px; color:#888; margin-top:5px;">
                ğŸ‘‹ æŠ¬æ‰‹: èµ·é£ | â¬…ï¸ å·¦æŒ¥: ä¸Šä¸€å¹• | â¡ï¸ å³æŒ¥: ä¸‹ä¸€å¹• | ğŸ‘‡ ä¸‹æŒ¥: é™è½
            </div>
        </div>
        <div class="cam-preview-box"><canvas id="drone-mask-canvas"></canvas></div>
        <video id="drone-video" playsinline></video>
        <div id="three-canvas-drone"></div>
    </div>

    <div id="controls-panel">
        <div class="panel-section">
            <div class="panel-title">é£è¡Œå‚æ•°</div>
            <div class="input-row">
                <label>æ— äººæœºæ•°é‡</label>
                <input type="number" id="inp-count" value="400" min="100" max="1000">
            </div>
            <div class="input-row">
                <label>é£è¡Œé€Ÿåº¦</label>
                <input type="number" id="inp-speed" value="5" min="1" max="20">
            </div>
            <div class="input-row">
                <label>è‡ªåŠ¨å˜æ¢</label>
                <input type="checkbox" id="inp-auto">
            </div>
            <div class="input-row" id="row-interval" style="opacity:0.5; pointer-events:none;">
                <label>æ¯å¹•æ—¶é•¿(s)</label>
                <input type="number" id="inp-interval" value="8">
            </div>
        </div>

        <div class="panel-title" style="padding: 0 15px; margin-top:15px;">ç¼–æ’æ—¶é—´è½´</div>
        <div id="timeline-container">
            </div>
    </div>

    <div id="popup-overlay"></div>
    <div id="config-popup">
        <div class="panel-title">ç§¯æœ¨é…ç½®</div>
        <div class="popup-row">
            <label>ç±»å‹</label>
            <select id="cfg-type">
                <option value="shape">é¢„è®¾å›¾å½¢</option>
                <option value="text">æ–‡å­—</option>
            </select>
        </div>
        
        <div class="popup-row" id="group-shape">
            <label>å›¾å½¢é€‰æ‹©</label>
            <select id="cfg-shape">
                <option value="cube">ç«‹æ–¹ä½“ (Cube)</option>
                <option value="sphere">çƒä½“ (Sphere)</option>
                <option value="heart">çˆ±å¿ƒ (Heart)</option>
                <option value="star">äº”è§’æ˜Ÿ (Star)</option>
                <option value="tree">åœ£è¯æ ‘ (Tree)</option>
                <option value="helix">åŒèºæ—‹ (Helix)</option>
            </select>
        </div>

        <div class="popup-row" id="group-text" style="display:none">
            <label>è¾“å…¥æ–‡å­— (å»ºè®®1-2å­—)</label>
            <input type="text" id="cfg-text-val" placeholder="Hi">
        </div>

        <div class="popup-row">
            <label>é¢œè‰²æ¨¡å¼</label>
            <div style="display:flex; align-items:center; gap:10px; margin-top:5px;">
                <input type="color" id="cfg-color" value="#00ffff">
                <label style="font-size:11px"><input type="checkbox" id="cfg-rainbow"> å½©è™¹æ¸å˜</label>
            </div>
        </div>

        <div class="popup-btns">
            <button class="btn btn-cancel" id="btn-cancel">å–æ¶ˆ</button>
            <button class="btn btn-confirm" id="btn-ok">ç¡®å®š</button>
        </div>
    </div>
</div>

<script src="js/three.min.js"></script>
<script src="js/camera_utils.js"></script>
<script src="js/control_utils.js"></script>
<script src="js/drawing_utils.js"></script>
<script src="js/hands.js"></script>

<script>
(function() {
    // ================= 1. æ ¸å¿ƒæ•°æ®ç»“æ„ =================
    const APP = {
        drones: [],         // å­˜æ”¾ {mesh, currentPos, targetPos, speed, delay}
        timeline: [],       // å­˜æ”¾æ¯ä¸€å±‚çš„æ•°æ® [{blocks: [...]}, ...]
        currentStage: -1,   // -1: åœ°é¢, 0~N: è¡¨æ¼”å±‚çº§
        state: 'LANDED',    // LANDED, TAKEOFF, FLYING, LANDING
        config: {
            count: 400,
            speed: 0.05,
            auto: false,
            interval: 8000
        },
        autoTimer: null,
        gestureCooldown: 0
    };

    // ================= 2. UI é€»è¾‘ä¸ç§¯æœ¨ç³»ç»Ÿ =================
    const timelineContainer = document.getElementById('timeline-container');
    const popup = document.getElementById('config-popup');
    const overlay = document.getElementById('popup-overlay');
    
    let currentEditingBlock = null; // å½“å‰æ­£åœ¨ç¼–è¾‘çš„ç§¯æœ¨ DOM å¼•ç”¨

    // åˆå§‹åŒ–æ—¶é—´è½´ï¼šæ·»åŠ ç¬¬ä¸€å±‚ + ç©ºå±‚
    function initTimeline() {
        addLayer();
    }

    function addLayer() {
        const div = document.createElement('div');
        div.className = 'timeline-layer';
        div.innerHTML = `<span class="layer-index">${APP.timeline.length + 1}</span>`;
        
        // åŠ å·æŒ‰é’®
        const addBtn = document.createElement('div');
        addBtn.className = 'add-btn';
        addBtn.innerHTML = '+';
        addBtn.onclick = () => addBlockToLayer(div, addBtn);
        
        div.appendChild(addBtn);
        timelineContainer.appendChild(div);
        
        // æ•°æ®å±‚åŒæ­¥
        APP.timeline.push({ blocks: [] });
    }

    function addBlockToLayer(layerDom, btnDom) {
        const block = document.createElement('div');
        block.className = 'block-item';
        block.innerHTML = `<div class="block-color-dot"></div><span>æœªè®¾ç½®</span>`;
        
        // ç‚¹å‡»ç§¯æœ¨æ‰“å¼€é…ç½®
        block.onclick = () => openConfig(block, layerDom);
        
        // æ’å…¥åˆ°åŠ å·å‰é¢
        layerDom.insertBefore(block, btnDom);

        // å¦‚æœè¿™æ˜¯æœ€åä¸€å±‚ï¼Œè‡ªåŠ¨è¡¥ä¸€ä¸ªæ–°çš„ç©ºå±‚
        if (layerDom === timelineContainer.lastElementChild) {
            addLayer();
        }
    }

    // --- å¼¹çª—é€»è¾‘ ---
    function openConfig(blockDom, layerDom) {
        currentEditingBlock = { dom: blockDom, layerIndex: Array.from(timelineContainer.children).indexOf(layerDom) };
        overlay.style.display = 'block';
        popup.style.display = 'block';
        
        // è¯»å–å·²æœ‰æ•°æ®ï¼ˆå¦‚æœæœ‰ï¼‰
        // è¿™é‡Œç®€åŒ–ï¼Œæ¯æ¬¡æ‰“å¼€é‡ç½®æˆ–è¯»å– DOM ä¸Šçš„ data-attribute
    }

    document.getElementById('btn-cancel').onclick = closePopup;
    document.getElementById('btn-ok').onclick = saveConfig;
    document.getElementById('cfg-type').onchange = (e) => {
        document.getElementById('group-shape').style.display = e.target.value === 'shape' ? 'block' : 'none';
        document.getElementById('group-text').style.display = e.target.value === 'text' ? 'block' : 'none';
    };
    
    // å…¨å±€è®¾ç½®ç›‘å¬
    document.getElementById('inp-count').onchange = e => APP.config.count = parseInt(e.target.value);
    document.getElementById('inp-speed').onchange = e => APP.config.speed = parseInt(e.target.value) / 100;
    document.getElementById('inp-auto').onchange = e => {
        APP.config.auto = e.target.checked;
        document.getElementById('row-interval').style.opacity = APP.config.auto ? 1 : 0.5;
        document.getElementById('row-interval').style.pointerEvents = APP.config.auto ? 'auto' : 'none';
    };

    function closePopup() {
        overlay.style.display = 'none';
        popup.style.display = 'none';
        currentEditingBlock = null;
    }

    function saveConfig() {
        if (!currentEditingBlock) return;
        
        const type = document.getElementById('cfg-type').value;
        const shape = document.getElementById('cfg-shape').value;
        const text = document.getElementById('cfg-text-val').value;
        const color = document.getElementById('cfg-color').value;
        const rainbow = document.getElementById('cfg-rainbow').checked;

        // 1. æ›´æ–° UI
        const label = type === 'shape' ? shape : (text || 'Text');
        currentEditingBlock.dom.querySelector('span').innerText = label;
        currentEditingBlock.dom.querySelector('.block-color-dot').style.background = rainbow ? 'linear-gradient(45deg, red, blue)' : color;
        currentEditingBlock.dom.classList.add('configured');

        // 2. ä¿å­˜æ•°æ®åˆ°ç»“æ„ä¸­
        // æ‰¾åˆ°è¿™ä¸€å±‚å¯¹åº”çš„æ•°æ®
        const layerData = APP.timeline[currentEditingBlock.layerIndex];
        // æ‰¾åˆ°è¿™ä¸ªç§¯æœ¨åœ¨å±‚é‡Œçš„ index (é™¤å» span index)
        // ç®€å•å¤„ç†ï¼šæŠŠæ‰€æœ‰ç§¯æœ¨æ•°æ®å…¨æ¸…ç©ºï¼Œé‡æ–°éå† DOM ç”Ÿæˆæ•°æ®ï¼ˆé˜²æ­¢é¡ºåºé”™ä¹±ï¼‰
        rebuildLayerData(currentEditingBlock.layerIndex);

        closePopup();
    }

    function rebuildLayerData(layerIndex) {
        const layerDom = timelineContainer.children[layerIndex];
        const blocks = layerDom.querySelectorAll('.block-item');
        const blockData = [];
        
        blocks.forEach(b => {
            if (!b.classList.contains('configured')) return;
            const label = b.querySelector('span').innerText;
            // ä¸ºäº†ç®€åŒ–ï¼Œæˆ‘ä»¬åªä» DOM çŠ¶æ€åæ¨ï¼ˆå®é™…å¼€å‘åº”åœ¨ openConfig æ—¶æŠŠæ•°æ®å­˜å˜é‡ï¼‰
            // è¿™é‡Œä¸ºäº†æ¼”ç¤ºï¼Œå‡è®¾åˆšåˆšä¿å­˜çš„å°±æ˜¯ç°åœ¨çš„å€¼ï¼Œå®é™…é¡¹ç›®åº”è¯¥ç”¨ object ç»‘å®š
            blockData.push({
                type: document.getElementById('cfg-type').value, // æ³¨æ„ï¼šè¿™é‡Œæœ‰ä¸ª bugï¼Œå¦‚æœç¼–è¾‘åˆ«çš„æ—¶å€™è¿™å€¼ä¼šå˜ï¼Œè¿™é‡Œç®€åŒ–
                value: label, // ç®€å•å­˜ label
                color: b.querySelector('.block-color-dot').style.background.includes('gradient') ? 'rainbow' :  rgbToHex(b.querySelector('.block-color-dot').style.backgroundColor)
            });
        });
        
        // ä¿®æ­£ bugï¼šçœŸæ­£çš„æ•°æ®åº”è¯¥å­˜åœ¨ DOM å±æ€§ä¸Š
        // è¿™é‡Œåšä¸€ä¸ªç®€å•çš„æ¨¡æ‹Ÿæ•°æ®ç”Ÿæˆå™¨
        // å®é™…æ¯æ¬¡ saveConfig åº”è¯¥æŠŠ config å¯¹è±¡ attach åˆ° dom ä¸Š
        const activeConfig = {
            type: document.getElementById('cfg-type').value,
            shape: document.getElementById('cfg-shape').value,
            text: document.getElementById('cfg-text-val').value,
            color: document.getElementById('cfg-color').value,
            rainbow: document.getElementById('cfg-rainbow').checked
        };
        currentEditingBlock.dom.dataset.config = JSON.stringify(activeConfig);
        
        // çœŸæ­£çš„ rebuild
        const finalBlocks = [];
        blocks.forEach(b => {
            if(b.dataset.config) finalBlocks.push(JSON.parse(b.dataset.config));
        });
        APP.timeline[layerIndex].blocks = finalBlocks;
    }

    function rgbToHex(rgb) {
        // è¾…åŠ©å‡½æ•°ï¼Œæµè§ˆå™¨è¿”å›çš„æ˜¯ rgb(r, g, b)
        if(!rgb) return '#ffffff';
        if(rgb.startsWith('#')) return rgb;
        // ç®€å•å¤„ç†
        return '#00ffff'; 
    }

    initTimeline();

    // ================= 3. Three.js åœºæ™¯æ„å»º =================
    const container = document.getElementById('three-canvas-drone');
    const width = container.clientWidth;
    const height = container.clientHeight;

    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x050505, 0.002);

    const camera = new THREE.PerspectiveCamera(60, width / height, 1, 2000);
    camera.position.set(0, 50, 200);
    camera.lookAt(0, 50, 0);

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(width, height);
    renderer.setPixelRatio(window.devicePixelRatio);
    container.appendChild(renderer.domElement);

    // åœ°é¢ç½‘æ ¼
    const gridHelper = new THREE.GridHelper(400, 40, 0x333333, 0x111111);
    scene.add(gridHelper);

    // æ— äººæœºç”Ÿæˆ
    const droneGeo = new THREE.SphereGeometry(1.5, 8, 8); // ä½æ¨¡çƒä½“
    const dummy = new THREE.Object3D();

    function initDrones() {
        // æ¸…ç†æ—§çš„
        APP.drones.forEach(d => scene.remove(d.mesh));
        APP.drones = [];

        const count = APP.config.count;
        const cols = Math.floor(Math.sqrt(count));
        
        for(let i=0; i<count; i++) {
            const material = new THREE.MeshBasicMaterial({ color: 0xffffff });
            const mesh = new THREE.Mesh(droneGeo, material);
            
            // åˆå§‹åœæœºåªä½ç½®
            const row = Math.floor(i / cols);
            const col = i % cols;
            const x = (col - cols/2) * 5;
            const z = (row - cols/2) * 5;
            
            mesh.position.set(x, 0.5, z);
            scene.add(mesh);

            APP.drones.push({
                mesh: mesh,
                homePos: new THREE.Vector3(x, 0.5, z),
                targetPos: new THREE.Vector3(x, 0.5, z),
                color: new THREE.Color(1,1,1),
                delay: 0, // èµ·é£å»¶è¿Ÿ
                active: false // æ˜¯å¦åœ¨å½“å‰è¡¨æ¼”ä¸­è¢«ç”¨åˆ°
            });
        }
    }
    
    // åˆå§‹åŒ–ä¸€æ¬¡
    initDrones();

    // ================= 4. é˜Ÿå½¢è®¡ç®—å¼•æ“ (Formation Engine) =================
    
    // å·¥å…·ï¼šä»æ–‡æœ¬è·å–ç‚¹é˜µ
    function getTextPoints(text, count) {
        const canvas = document.createElement('canvas');
        canvas.width = 100; canvas.height = 100;
        const ctx = canvas.getContext('2d');
        ctx.font = 'bold 80px Arial';
        ctx.fillStyle = 'white';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(text, 50, 50);
        
        const imageData = ctx.getImageData(0,0,100,100);
        const points = [];
        for(let y=0; y<100; y+=4) { // é‡‡æ ·æ­¥é•¿
            for(let x=0; x<100; x+=4) {
                if(imageData.data[(y*100+x)*4] > 128) {
                    // æ˜ å°„åˆ° 3D ç©ºé—´: x -> x, y -> y (ä¸Šä¸‹ç¿»è½¬)
                    points.push(new THREE.Vector3((x-50)*3, (100-y)*2 + 20, 0));
                }
            }
        }
        return points;
    }

    // å·¥å…·ï¼šç”Ÿæˆå½¢çŠ¶ç‚¹
    function getShapePoints(shape, count) {
        const points = [];
        for(let i=0; i<count; i++) {
            const t = i / count;
            let x, y, z;
            
            if (shape === 'sphere') {
                const phi = Math.acos( -1 + ( 2 * i ) / count );
                const theta = Math.sqrt( count * Math.PI ) * phi;
                const r = 60;
                x = r * Math.cos( theta ) * Math.sin( phi );
                y = r * Math.sin( theta ) * Math.sin( phi ) + 80;
                z = r * Math.cos( phi );
            } else if (shape === 'heart') {
                // å¿ƒå½¢å…¬å¼
                const r = 4; // åŠå¾„ç³»æ•°
                // t 0->2PI
                const angle = t * Math.PI * 2; 
                // è¿™æ˜¯ä¸€ä¸ª 2D å¿ƒå½¢ï¼Œæˆ‘ä»¬éœ€è¦å¡«å……å†…éƒ¨æˆ–è€…åš 3D è½®å»“
                // ç®€å•èµ·è§ï¼Œåšä¸ª 2D è½®å»“
                x = 16 * Math.pow(Math.sin(angle), 3) * r;
                y = (13 * Math.cos(angle) - 5 * Math.cos(2*angle) - 2 * Math.cos(3*angle) - Math.cos(4*angle)) * r + 80;
                z = 0;
            } else if (shape === 'cube') {
                 // éšæœºå¡«å……ç«‹æ–¹ä½“
                 const s = 80;
                 x = (Math.random() - 0.5) * s;
                 y = (Math.random() - 0.5) * s + 80;
                 z = (Math.random() - 0.5) * s;
            } else {
                 // é»˜è®¤åœ†å½¢
                 const angle = t * Math.PI * 2;
                 x = Math.cos(angle) * 50;
                 y = Math.sin(angle) * 50 + 80;
                 z = 0;
            }
            points.push(new THREE.Vector3(x, y, z));
        }
        return points;
    }

    // æ ¸å¿ƒï¼šè®¡ç®—ä¸‹ä¸€å¸§æ‰€æœ‰é£æœºç›®æ ‡
    function calculateStageTargets(stageIndex) {
        // 1. è·å–å½“å‰å±‚çš„æ•°æ®
        if (stageIndex >= APP.timeline.length) return;
        
        // è¿‡æ»¤æ‰æ²¡é…ç½®çš„ block (timeline é‡Œæœ€åä¸€è¡Œå¯èƒ½æ˜¯ç©ºçš„æˆ–è€…åŒ…å«æœªé…ç½®çš„)
        const layerData = APP.timeline[stageIndex];
        const blocks = layerData ? layerData.blocks : [];
        if (blocks.length === 0) return;

        // 2. åˆ†é…æ— äººæœº
        const dronesPerBlock = Math.floor(APP.drones.length / blocks.length);
        
        let droneIdx = 0;
        
        blocks.forEach(block => {
            let points = [];
            // ç”Ÿæˆè¶³å¤Ÿçš„ç‚¹æ¥è¦†ç›–åˆ†é…ç»™è¯¥ç§¯æœ¨çš„æ— äººæœºæ•°é‡
            // å¦‚æœç‚¹ä¸å¤Ÿï¼Œå°±å¾ªç¯ä½¿ç”¨ï¼›ç‚¹å¤šäº†å°±ä¸¢å¼ƒ
            const targetCount = dronesPerBlock; 
            
            if (block.type === 'shape') {
                // å½¢çŠ¶ç®—æ³•ç”Ÿæˆ (ç®€å•éšæœºåˆ†å¸ƒåœ¨å½¢çŠ¶è¡¨é¢æˆ–ä½“ç§¯å†…)
                // è¿™é‡Œä¸ºäº†æ¼”ç¤ºï¼Œæˆ‘ä»¬ç”Ÿæˆå¤§é‡éšæœºç‚¹ï¼Œç„¶åå–å‰ N ä¸ª
                // çœŸæ­£çš„ç®—æ³•å¯ä»¥æ›´å¤æ‚
                points = getShapePoints(block.shape, targetCount);
            } else {
                points = getTextPoints(block.text || block.value, targetCount);
            }
            
            // å¦‚æœç”Ÿæˆçš„ç‚¹å°‘äºæ— äººæœºæ•°é‡ï¼ˆæ¯”å¦‚æ–‡å­—ç‚¹å¾ˆå°‘ï¼‰ï¼Œå¾ªç¯å¡«å……
            if (points.length < targetCount && points.length > 0) {
                const originalLen = points.length;
                for(let k=0; k < targetCount - originalLen; k++) {
                    points.push(points[k % originalLen].clone());
                }
            }

            // 3. è®¾ç½®ç›®æ ‡
            for (let i = 0; i < targetCount; i++) {
                if (droneIdx >= APP.drones.length) break;
                
                const d = APP.drones[droneIdx];
                const p = points[i] || new THREE.Vector3(0,100,0); // fallback
                
                // è®¾ç½®åç§» (å¦‚æœè¿™ä¸€å±‚æœ‰å¤šä¸ªç§¯æœ¨ï¼Œæˆ‘ä»¬å¯ä»¥æŠŠå®ƒä»¬å·¦å³æ’å¼€)
                // è¿™é‡Œç®€åŒ–ï¼šå…¨éƒ¨é‡å åœ¨ä¸­å¿ƒï¼Œæˆ–è€…ä½ å¯ä»¥åŠ  x offset
                // ç®€å• offset:
                const offsetX = (blocks.length > 1) ? (i % blocks.length - (blocks.length-1)/2) * 60 : 0;
                
                d.targetPos.set(p.x + offsetX, p.y, p.z);
                
                // è®¾ç½®é¢œè‰²
                if (block.rainbow) {
                    d.mesh.material.color.setHSL(i/targetCount, 1.0, 0.5);
                } else {
                    d.mesh.material.color.set(block.color);
                }
                
                d.active = true;
                droneIdx++;
            }
        });

        // å‰©ä¸‹çš„æ— äººæœºè®©å®ƒå›å®¶æˆ–è€…éšè— (é£åˆ°åœ°ä¸‹)
        for (let j = droneIdx; j < APP.drones.length; j++) {
             APP.drones[j].targetPos.copy(APP.drones[j].homePos);
             APP.drones[j].mesh.material.color.setHex(0x333333);
        }
    }

    // ================= 5. åŠ¨ç”»ä¸æ‰‹åŠ¿æ§åˆ¶ =================

    // çŠ¶æ€åˆ‡æ¢å‡½æ•°
    function switchState(action) {
        const statusDiv = document.getElementById('sys-status');
        
        if (action === 'TAKEOFF') {
            if (APP.timeline[0].blocks.length === 0) {
                statusDiv.innerText = "âŒ é”™è¯¯: ç¬¬1å±‚æœªè®¾ç½®ç§¯æœ¨";
                statusDiv.style.color = "red";
                return;
            }
            APP.state = 'TAKEOFF';
            APP.currentStage = 0;
            statusDiv.innerText = "ğŸš€ èµ·é£ä¸­...";
            
            // è®¡ç®—ç¬¬ä¸€å¸§ç›®æ ‡
            calculateStageTargets(0);
            
            // è®¾ç½®èµ·é£å»¶è¿Ÿï¼ˆèµ›è½¦èµ·æ­¥æ„Ÿï¼‰
            APP.drones.forEach((d, i) => {
                // ç®€å•çš„æ³¢æµªèµ·é£
                d.delay = i * 0.005; // æ¯ä¸ªå·® 5ms
            });

            if(APP.config.auto) startAutoPlay();

        } else if (action === 'NEXT') {
            if (APP.currentStage < APP.timeline.length - 2) { // -2 å› ä¸ºæœ€åä¸€å±‚æ˜¯ç©ºçš„UIå ä½
                APP.currentStage++;
                APP.state = 'TRANSITION';
                statusDiv.innerText = `å˜æ¢: ç¬¬ ${APP.currentStage+1} å¹•`;
                calculateStageTargets(APP.currentStage);
                // å˜æ¢æ—¶ä¸€èµ·åŠ¨ï¼Œæ— å»¶è¿Ÿ
                APP.drones.forEach(d => d.delay = 0);
            } else {
                statusDiv.innerText = "å·²æ˜¯æœ€åä¸€å¹•";
            }

        } else if (action === 'PREV') {
            if (APP.currentStage > 0) {
                APP.currentStage--;
                APP.state = 'TRANSITION';
                statusDiv.innerText = `å˜æ¢: ç¬¬ ${APP.currentStage+1} å¹•`;
                calculateStageTargets(APP.currentStage);
                APP.drones.forEach(d => d.delay = 0);
            }

        } else if (action === 'LAND') {
            APP.state = 'LANDING';
            statusDiv.innerText = "ğŸ›¬ é™è½ä¸­...";
            APP.drones.forEach((d, i) => {
                d.targetPos.copy(d.homePos);
                d.delay = i * 0.002;
                d.mesh.material.color.setHex(0xffffff);
            });
            setTimeout(() => { APP.state = 'LANDED'; statusDiv.innerText = "System Ready"; }, 5000);
        }
    }

    function startAutoPlay() {
        if(APP.autoTimer) clearInterval(APP.autoTimer);
        APP.autoTimer = setInterval(() => {
            if(APP.state === 'LANDED') return;
            if(APP.currentStage < APP.timeline.length - 2) {
                switchState('NEXT');
            } else {
                switchState('LAND');
                clearInterval(APP.autoTimer);
            }
        }, parseInt(document.getElementById('inp-interval').value) * 1000);
    }

    // æ¯ä¸€å¸§é€»è¾‘
    const clock = new THREE.Clock();
    
    function animate() {
        requestAnimationFrame(animate);
        const dt = clock.getDelta();
        const time = clock.getElapsedTime();
        
        // æ›´æ–°æ— äººæœºä½ç½®
        let allArrived = true;
        
        APP.drones.forEach(d => {
            if (d.delay > 0) {
                d.delay -= dt;
                allArrived = false;
                return;
            }

            // ç®€å•çš„ Pæ§åˆ¶å™¨ (Lerp)
            const dist = d.mesh.position.distanceTo(d.targetPos);
            if (dist > 0.1) {
                allArrived = false;
                const speed = APP.config.speed * 60 * dt; // å½’ä¸€åŒ–é€Ÿåº¦
                d.mesh.position.lerp(d.targetPos, 0.05 * speed); // 0.05 æ˜¯å¹³æ»‘å› å­
            } else {
                d.mesh.position.copy(d.targetPos);
            }
        });

        // æ‘„åƒæœºå›´ç»•æ—‹è½¬
        const r = 300;
        camera.position.x = r * Math.sin(time * 0.1);
        camera.position.z = r * Math.cos(time * 0.1);
        camera.lookAt(0, 80, 0);

        renderer.render(scene, camera);
    }
    animate();

    // ================= 6. æ‰‹åŠ¿è¯†åˆ« (Swipe) =================
    const videoElement = document.getElementById('drone-video');
    const canvasElement = document.getElementById('drone-mask-canvas');
    const canvasCtx = canvasElement.getContext('2d');
    const statusText = document.getElementById('sys-status');

    // æ‰‹åŠ¿çŠ¶æ€å˜é‡
    let lastPalmPos = null;
    let gestureFrames = 0; // æŒç»­å¸§æ•°ç»Ÿè®¡ï¼Œé˜²æŠ–

    function onResults(results) {
        canvasCtx.save();
        canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
        
        // ç»˜åˆ¶æ‰‹åŠ¿éª¨æ¶ (å¯é€‰ï¼Œä¸ºäº†Debug)
        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
            const landmarks = results.multiHandLandmarks[0];
            drawConnectors(canvasCtx, landmarks, HAND_CONNECTIONS, {color: '#00FFFF', lineWidth: 2});
            drawLandmarks(canvasCtx, landmarks, {color: '#FF0000', lineWidth: 1, radius: 2});
            
            // æ ¸å¿ƒé€»è¾‘ï¼šæ‰‹æŒä¸­å¿ƒ (9å·ç‚¹: Middle Finger MCP)
            const palm = landmarks[9]; 
            
            // å†·å´æ—¶é—´
            if (APP.gestureCooldown > 0) {
                APP.gestureCooldown--;
                lastPalmPos = palm; // ä¿æŒæ›´æ–°ä½†ä¸è§¦å‘
                canvasCtx.restore();
                return;
            }

            if (lastPalmPos) {
                const dx = palm.x - lastPalmPos.x;
                const dy = palm.y - lastPalmPos.y;
                
                // é˜ˆå€¼è®¾å®š (æ ¹æ®æ‘„åƒå¤´ 0-1 åæ ‡ç³»)
                const swipeThreshold = 0.15; // éœ€è¦å¿«é€Ÿç§»åŠ¨
                
                // è‡ªåŠ¨æ’­æ”¾æ¨¡å¼ä¸‹ä¸å“åº”æ‰‹åŠ¿
                if (!APP.config.auto) {
                    if (APP.state === 'LANDED') {
                        // æŠ¬æ‰‹èµ·é£: y å‘ä¸Š (MediaPipe yå‘ä¸‹å¢å¤§ï¼Œæ‰€ä»¥å‘ä¸Šæ˜¯ y å‡å°)
                        if (palm.y < 0.4) { // æ‰‹ä¸¾é«˜
                             switchState('TAKEOFF');
                             triggerCooldown(60);
                        }
                    } else {
                        // é£è¡Œä¸­æ§åˆ¶
                        // å³æŒ¥ (x å¢å¤§) -> æ³¨æ„é•œåƒåè½¬é—®é¢˜
                        // å±å¹• scale(-1)ï¼Œæ‰€ä»¥åŸæœ¬å‘å³æŒ¥(è‡ªå·±å³æ‰‹å‘å³)ï¼Œåœ¨ landmarks é‡Œ x æ˜¯å‡å°è¿˜æ˜¯å¢å¤§ï¼Ÿ
                        // é€šå¸¸ï¼šè‡ªå·±å‘å³æŒ¥ï¼Œç”»é¢é‡Œæ‰‹å‘å³ç§»ã€‚
                        // ç®€å•åˆ¤å®šï¼š
                        if (dx > swipeThreshold) { 
                             statusText.innerText = "ğŸ‘‰ è¯†åˆ«: ä¸‹ä¸€å¹•";
                             switchState('NEXT');
                             triggerCooldown(30);
                        } else if (dx < -swipeThreshold) {
                             statusText.innerText = "ğŸ‘ˆ è¯†åˆ«: ä¸Šä¸€å¹•";
                             switchState('PREV');
                             triggerCooldown(30);
                        } else if (dy > swipeThreshold) {
                             statusText.innerText = "ğŸ‘‡ è¯†åˆ«: é™è½";
                             switchState('LAND');
                             triggerCooldown(60);
                        }
                    }
                }
            }
            lastPalmPos = palm;
        } else {
            lastPalmPos = null;
        }
        canvasCtx.restore();
    }
    
    function triggerCooldown(frames) {
        APP.gestureCooldown = frames;
        const st = document.getElementById('sys-status');
        st.style.borderColor = 'white';
        setTimeout(() => st.style.borderColor = 'cyan', 500);
    }

    // åˆå§‹åŒ– MediaPipe
    const hands = new Hands({locateFile: (file) => {
        return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
    }});
    hands.setOptions({maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5});
    hands.onResults(onResults);
    
    const cameraUtils = new Camera(videoElement, {
        onFrame: async () => { await hands.send({image: videoElement}); },
        width: 320, height: 240
    });
    cameraUtils.start();

    // Resize Handler
    window.addEventListener('resize', () => {
        if(!container) return;
        camera.aspect = container.clientWidth / container.clientHeight;
        camera.updateProjectionMatrix();
        renderer.setSize( container.clientWidth, container.clientHeight );
    });

})();
</script>