<style>
    /* === æ•´ä½“å¸ƒå±€ === */
    #drone-app {
        position: relative; /* å…³é”®ï¼šè®©å¼¹çª—åŸºäºè¿™ä¸ªå®¹å™¨å®šä½ */
        display: flex;
        width: 100%;
        height: 600px;
        background: #111;
        font-family: 'Segoe UI', sans-serif;
        border-radius: 12px;
        overflow: hidden;
        color: #ddd;
    }

    /* === å·¦ä¾§ 3D èˆå° (70%) === */
    #stage-container {
        flex: 7;
        position: relative;
        background: linear-gradient(to bottom, #000 0%, #1a1a1a 100%);
        overflow: hidden;
    }
    #three-canvas-drone { width: 100%; height: 100%; display: block; }
    
    .drone-overlay {
        position: absolute; top: 20px; left: 20px; pointer-events: none; z-index: 10;
    }
    .status-tag {
        background: rgba(0, 255, 255, 0.1); border: 1px solid cyan;
        color: cyan; padding: 5px 10px; border-radius: 4px;
        font-size: 14px; text-shadow: 0 0 5px cyan; margin-bottom: 5px;
        transition: all 0.3s;
    }
    .gesture-hint { font-size:12px; color:#888; margin-top:5px; background: rgba(0,0,0,0.5); padding: 5px; border-radius: 4px;}

    .cam-preview-box {
        position: absolute; bottom: 10px; left: 10px;
        width: 100px; height: 75px; background: #000;
        border: 1px solid #333; z-index: 5;
    }
    #drone-video { opacity: 0; position: absolute; pointer-events: none; }
    #drone-mask-canvas { width: 100%; height: 100%; transform: scaleX(-1); }

    /* === å³ä¾§ æ§åˆ¶å° (30%) === */
    #controls-panel {
        flex: 3;
        background: #1e1e1e;
        border-left: 1px solid #333;
        display: flex;
        flex-direction: column;
        user-select: none;
        transition: opacity 0.3s;
    }
    /* é”å®šçŠ¶æ€æ ·å¼ */
    #controls-panel.ui-locked {
        opacity: 0.5;
        pointer-events: none;
        filter: grayscale(1);
    }

    .panel-section { padding: 15px; border-bottom: 1px solid #333; }
    .panel-title { font-size: 14px; color: #888; margin-bottom: 10px; text-transform: uppercase; letter-spacing: 1px; }
    .input-row { display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px; }
    .input-row label { font-size: 12px; }
    input[type="number"] { width: 50px; background: #333; border: none; color: white; padding: 4px; border-radius: 3px; }
    input[type="checkbox"] { accent-color: cyan; }

    /* ç§¯æœ¨æ—¶é—´è½´ */
    #timeline-container { flex: 1; overflow-y: auto; padding: 15px; background: #151515; }
    .timeline-layer {
        background: #252525; border-radius: 6px; margin-bottom: 10px; padding: 8px;
        border: 1px solid #333; display: flex; flex-wrap: wrap; gap: 5px;
        align-items: center; min-height: 40px; position: relative;
    }
    .layer-index { 
        position: absolute; left: -8px; top: 50%; transform: translateY(-50%); 
        font-size: 10px; color: #555; 
    }
    .block-item {
        background: #3a3a3a; padding: 5px 10px; border-radius: 4px; font-size: 12px;
        cursor: pointer; border: 1px solid #555; display: flex; align-items: center; gap: 5px;
    }
    .block-item.configured { border-color: cyan; color: cyan; }
    .block-color-preview { width: 12px; height: 12px; border-radius: 2px; background: #666; border: 1px solid #fff; }
    
    .add-btn {
        width: 24px; height: 24px; border-radius: 4px;
        border: 1px dashed #666; color: #666; display: flex; align-items: center; justify-content: center;
        cursor: pointer; transition: 0.2s;
    }
    .add-btn:hover { border-color: cyan; color: cyan; }

    /* === å¼¹çª— (Popup) === */
    /* é®ç½©ï¼šåªè¦†ç›– drone-app */
    #popup-overlay {
        display: none; position: absolute; top: 0; left: 0; width: 100%; height: 100%;
        background: rgba(0,0,0,0.7); z-index: 90; backdrop-filter: blur(2px);
    }
    /* å¼¹çª—ä¸»ä½“ */
    #config-popup {
        display: none;
        position: absolute; 
        top: 50%; left: 50%; 
        transform: translate(-50%, -50%); /* å®Œç¾å±…ä¸­ */
        width: 300px; 
        background: #252525; 
        border: 1px solid #444;
        box-shadow: 0 20px 50px rgba(0,0,0,0.9);
        z-index: 100; border-radius: 12px; padding: 20px;
    }
    .popup-row { margin-bottom: 15px; }
    .popup-row label { display: block; font-size: 12px; color: #aaa; margin-bottom: 5px; }
    select, input[type="text"] { width: 100%; background: #111; border: 1px solid #444; color: white; padding: 8px; border-radius: 4px; box-sizing: border-box; }
    
    /* é¢œè‰²ç®¡ç†å™¨ */
    .color-manager { display: flex; flex-wrap: wrap; gap: 5px; margin-top: 5px; background: #1a1a1a; padding: 5px; border-radius: 4px; min-height: 30px;}
    .color-chip { width: 24px; height: 24px; border-radius: 4px; border: 1px solid #555; cursor: pointer; position: relative; }
    .color-chip:hover::after { content: 'x'; position: absolute; top:-5px; right:-5px; font-size:10px; background:red; color:white; width:12px; height:12px; border-radius:50%; display:flex; justify-content:center; align-items:center; }
    .btn-add-color { width: 24px; height: 24px; border: 1px dashed #666; color: #666; display: flex; justify-content: center; align-items: center; cursor: pointer; border-radius: 4px; }
    
    .popup-btns { display: flex; justify-content: flex-end; gap: 10px; margin-top: 20px; border-top: 1px solid #333; padding-top: 15px; }
    .btn { padding: 6px 16px; border-radius: 4px; border: none; cursor: pointer; font-size: 12px; }
    .btn-cancel { background: #333; color: #ccc; }
    .btn-confirm { background: cyan; color: #000; font-weight: bold; }
</style>

<div id="drone-app">
    <div id="stage-container">
        <div class="drone-overlay">
            <div id="sys-status" class="status-tag">System Ready - ç­‰å¾…è®¾ç½®</div>
            <div class="gesture-hint">
                ğŸ‘‹ æŠ¬æ‰‹: èµ·é£ | â¬…ï¸ å·¦æŒ¥: ä¸Šä¸€å¹• | â¡ï¸ å³æŒ¥: ä¸‹ä¸€å¹• | ğŸ‘‡ ä¸‹æŒ¥: é™è½
            </div>
        </div>
        <div class="cam-preview-box"><canvas id="drone-mask-canvas"></canvas></div>
        <video id="drone-video" playsinline></video>
        <div id="three-canvas-drone"></div>
    </div>

    <div id="controls-panel">
        <div class="panel-section">
            <div class="panel-title">é£è¡Œå‚æ•°</div>
            <div class="input-row">
                <label>æ— äººæœºæ•°é‡</label>
                <input type="number" id="inp-count" value="400" min="100" max="1000">
            </div>
            <div class="input-row">
                <label>é£è¡Œé€Ÿåº¦</label>
                <input type="number" id="inp-speed" value="8" min="1" max="20">
            </div>
            <div class="input-row">
                <label>è‡ªåŠ¨å˜æ¢</label>
                <input type="checkbox" id="inp-auto">
            </div>
            <div class="input-row" id="row-interval" style="opacity:0.5; pointer-events:none;">
                <label>æ¯å¹•æ—¶é•¿(s)</label>
                <input type="number" id="inp-interval" value="8">
            </div>
        </div>

        <div class="panel-title" style="padding: 15px 15px 0;">ç¼–æ’æ—¶é—´è½´</div>
        <div id="timeline-container">
            </div>
    </div>

    <div id="popup-overlay"></div>
    <div id="config-popup">
        <h3 style="margin:0 0 15px 0; color:white; font-size:16px;">ç§¯æœ¨é…ç½®</h3>
        
        <div class="popup-row">
            <label>å›¾æ¡ˆç±»å‹</label>
            <select id="cfg-type">
                <option value="shape">é¢„è®¾å‡ ä½•ä½“</option>
                <option value="text">æ–‡å­—ç”Ÿæˆ</option>
            </select>
        </div>
        
        <div class="popup-row" id="group-shape">
            <label>é€‰æ‹©å½¢çŠ¶</label>
            <select id="cfg-shape">
                <option value="heart">â¤ï¸ çˆ±å¿ƒ (Heart)</option>
                <option value="star">â­ äº”è§’æ˜Ÿ (Star)</option>
                <option value="tree">ğŸŒ² åœ£è¯æ ‘ (Tree)</option>
                <option value="cube">ğŸ§Š ç«‹æ–¹ä½“ (Cube)</option>
                <option value="sphere">ğŸ”® çƒä½“ (Sphere)</option>
                <option value="helix">ğŸ§¬ åŒèºæ—‹ (Helix)</option>
            </select>
        </div>

        <div class="popup-row" id="group-text" style="display:none">
            <label>è¾“å…¥æ–‡å­— (å»ºè®®1-2å­—ï¼Œæ”¯æŒä¸­æ–‡)</label>
            <input type="text" id="cfg-text-val" placeholder="Hi">
        </div>

        <div class="popup-row">
            <label>é¢œè‰²é…ç½® (ç‚¹å‡» + æ·»åŠ å¤šè‰²)</label>
            <div class="color-manager" id="color-list-container">
                <div class="btn-add-color" onclick="addColorPicker()">+</div>
            </div>
        </div>

        <div class="popup-row">
            <label>é¢œè‰²æ•ˆæœ</label>
            <select id="cfg-color-mode">
                <option value="solid">æ— æ•ˆæœ (äº¤æ›¿åˆ†é…)</option>
                <option value="gradient">çº¿æ€§æ¸å˜ (å·¦->å³)</option>
                <option value="breathing">å‘¼å¸é—ªçƒ (åŠ¨æ€å¾ªç¯)</option>
            </select>
        </div>

        <div class="popup-btns">
            <button class="btn btn-cancel" id="btn-cancel">å–æ¶ˆ</button>
            <button class="btn btn-confirm" id="btn-ok">ç¡®å®šä¿å­˜</button>
        </div>
    </div>
</div>

<script src="js/three.min.js"></script>
<script src="js/camera_utils.js"></script>
<script src="js/control_utils.js"></script>
<script src="js/drawing_utils.js"></script>
<script src="js/hands.js"></script>

<script>
(function() {
    // ================= 1. æ ¸å¿ƒæ•°æ®ç»“æ„ =================
    const APP = {
        drones: [],         // {mesh, currentPos, targetPos, baseColors:[], colorMode, colorOffset}
        timeline: [],       // [{blocks: [...]}, ...]
        currentStage: -1,   // -1: åœ°é¢, 0~N: è¡¨æ¼”å±‚çº§
        state: 'LANDED',    // LANDED, TAKEOFF, HOVERING, TRANSITION, LANDING
        config: {
            count: 400,
            speed: 0.08,
            auto: false,
            interval: 8000
        },
        autoTimer: null,
        gestureCooldown: 0,
        tempColors: ['#ff0000'] // å¼¹çª—ä¸´æ—¶çš„é¢œè‰²å­˜å‚¨
    };

    // ================= 2. UI é€»è¾‘ä¸ç§¯æœ¨ç³»ç»Ÿ =================
    const timelineContainer = document.getElementById('timeline-container');
    const popup = document.getElementById('config-popup');
    const overlay = document.getElementById('popup-overlay');
    const controlsPanel = document.getElementById('controls-panel');
    let currentEditingBlock = null; 

    // é”å®š/è§£é” UI
    function setUILocked(locked) {
        if(locked) controlsPanel.classList.add('ui-locked');
        else controlsPanel.classList.remove('ui-locked');
    }

    function initTimeline() { addLayer(); }

    function addLayer() {
        const div = document.createElement('div');
        div.className = 'timeline-layer';
        div.innerHTML = `<span class="layer-index">${APP.timeline.length + 1}</span>`;
        
        const addBtn = document.createElement('div');
        addBtn.className = 'add-btn';
        addBtn.innerHTML = '+';
        addBtn.onclick = () => addBlockToLayer(div, addBtn);
        
        div.appendChild(addBtn);
        timelineContainer.appendChild(div);
        APP.timeline.push({ blocks: [] });
    }

    function addBlockToLayer(layerDom, btnDom) {
        const block = document.createElement('div');
        block.className = 'block-item';
        block.innerHTML = `<div class="block-color-preview"></div><span>æœªè®¾ç½®</span>`;
        block.dataset.configured = "false";
        
        block.onclick = () => {
            // åªæœ‰åœ¨åœ°é¢çš„çŠ¶æ€ä¸‹æ‰å…è®¸ç¼–è¾‘ï¼Œé˜²æ­¢é€»è¾‘å†²çª
            if(APP.state !== 'LANDED') {
                alert("è¯·å…ˆé™è½æ— äººæœºå†ä¿®æ”¹è®¾ç½®ï¼");
                return;
            }
            openConfig(block, layerDom);
        };
        
        layerDom.insertBefore(block, btnDom);
        if (layerDom === timelineContainer.lastElementChild) {
            addLayer();
        }
    }

    // --- é¢œè‰²ç®¡ç†é€»è¾‘ ---
    window.addColorPicker = function() {
        APP.tempColors.push('#00ffff');
        renderColorList();
    }
    window.removeColor = function(index) {
        if(APP.tempColors.length > 1) {
            APP.tempColors.splice(index, 1);
            renderColorList();
        }
    }
    window.updateColor = function(index, val) {
        APP.tempColors[index] = val;
        renderColorList();
    }
    
    function renderColorList() {
        const container = document.getElementById('color-list-container');
        // ä¿ç•™æœ€åä¸€ä¸ª + æŒ‰é’®
        const addBtn = container.lastElementChild;
        container.innerHTML = '';
        
        APP.tempColors.forEach((c, i) => {
            const chip = document.createElement('div');
            chip.className = 'color-chip';
            chip.style.backgroundColor = c;
            
            // éšè—çš„ input color
            const input = document.createElement('input');
            input.type = 'color';
            input.value = c;
            input.style.opacity = 0;
            input.style.position = 'absolute';
            input.style.width = '100%'; input.style.height = '100%'; input.style.cursor = 'pointer';
            input.oninput = (e) => {
                chip.style.backgroundColor = e.target.value;
                APP.tempColors[i] = e.target.value;
            };

            // å³é”®æˆ–ç‚¹å‡»ç‰¹å®šåŒºåŸŸåˆ é™¤? è¿™é‡Œç®€åŒ–ä¸ºï¼šhover æ˜¾ç¤º xï¼Œç‚¹å‡» x åˆ é™¤
            // ä¸ºäº†ç®€å•ï¼Œæˆ‘ä»¬ç»‘å®šç‚¹å‡»äº‹ä»¶ï¼šå¦‚æœæ˜¯ chip æœ¬ä½“æ‰“å¼€é¢œè‰²ï¼Œå¦‚æœæ˜¯ä¼ªå…ƒç´ (é€šè¿‡åæ ‡åˆ¤æ–­å¤ªéº»çƒ¦)ï¼ŒåŠ ä¸ªç‹¬ç«‹åˆ é™¤é’®
            // ç®€åŒ–äº¤äº’ï¼šåŒå‡»åˆ é™¤ï¼Œå•å‡»æ”¹è‰²
            chip.title = "å•å‡»æ”¹è‰²ï¼ŒåŒå‡»åˆ é™¤";
            chip.ondblclick = () => removeColor(i);

            chip.appendChild(input);
            container.appendChild(chip);
        });
        container.appendChild(addBtn);
    }

    // --- å¼¹çª—é€»è¾‘ ---
    function openConfig(blockDom, layerDom) {
        currentEditingBlock = { dom: blockDom, layerIndex: Array.from(timelineContainer.children).indexOf(layerDom) };
        overlay.style.display = 'block';
        popup.style.display = 'block'; // å±…ä¸­æ˜¾ç¤º

        // æ¢å¤å·²æœ‰é…ç½®
        if (blockDom.dataset.config) {
            const cfg = JSON.parse(blockDom.dataset.config);
            document.getElementById('cfg-type').value = cfg.type;
            document.getElementById('cfg-shape').value = cfg.shape;
            document.getElementById('cfg-text-val').value = cfg.text;
            document.getElementById('cfg-color-mode').value = cfg.colorMode || 'solid';
            APP.tempColors = cfg.colors || ['#ff0000'];
        } else {
            APP.tempColors = ['#00ffff'];
        }
        
        // è§¦å‘ä¸€æ¬¡æ˜¾ç¤ºåˆ‡æ¢
        document.getElementById('cfg-type').dispatchEvent(new Event('change'));
        renderColorList();
    }

    document.getElementById('btn-cancel').onclick = closePopup;
    document.getElementById('btn-ok').onclick = saveConfig;
    document.getElementById('cfg-type').onchange = (e) => {
        document.getElementById('group-shape').style.display = e.target.value === 'shape' ? 'block' : 'none';
        document.getElementById('group-text').style.display = e.target.value === 'text' ? 'block' : 'none';
    };
    
    // å…¨å±€è®¾ç½®
    document.getElementById('inp-count').onchange = e => APP.config.count = parseInt(e.target.value);
    document.getElementById('inp-speed').onchange = e => APP.config.speed = parseInt(e.target.value) / 100;
    document.getElementById('inp-auto').onchange = e => {
        APP.config.auto = e.target.checked;
        document.getElementById('row-interval').style.opacity = APP.config.auto ? 1 : 0.5;
        document.getElementById('row-interval').style.pointerEvents = APP.config.auto ? 'auto' : 'none';
    };

    function closePopup() {
        overlay.style.display = 'none';
        popup.style.display = 'none';
        currentEditingBlock = null;
    }

    function saveConfig() {
        if (!currentEditingBlock) return;
        
        const type = document.getElementById('cfg-type').value;
        const shape = document.getElementById('cfg-shape').value;
        const text = document.getElementById('cfg-text-val').value;
        const colorMode = document.getElementById('cfg-color-mode').value;
        
        // 1. æ„å»ºé…ç½®å¯¹è±¡
        const config = {
            type, shape, text, colorMode,
            colors: [...APP.tempColors], // å¤åˆ¶å‰¯æœ¬
            configured: true
        };

        // 2. æ›´æ–° DOM æ ·å¼
        const label = type === 'shape' ? shape : (text || 'Text');
        currentEditingBlock.dom.querySelector('span').innerText = label;
        // é¢„è§ˆè‰²å—ï¼šå¦‚æœæ˜¯å¤šè‰²ï¼Œæ˜¾ç¤ºæ¸å˜
        const preview = currentEditingBlock.dom.querySelector('.block-color-preview');
        if (config.colors.length > 1) {
            preview.style.background = `linear-gradient(45deg, ${config.colors.join(',')})`;
        } else {
            preview.style.background = config.colors[0];
        }
        
        currentEditingBlock.dom.classList.add('configured');
        currentEditingBlock.dom.dataset.configured = "true";
        currentEditingBlock.dom.dataset.config = JSON.stringify(config);

        // 3. é‡å»ºæ•°æ®å±‚
        rebuildTimelineData();

        closePopup();
    }

    function rebuildTimelineData() {
        APP.timeline = [];
        const layers = timelineContainer.querySelectorAll('.timeline-layer');
        layers.forEach(layer => {
            const blocksData = [];
            layer.querySelectorAll('.block-item').forEach(b => {
                if(b.dataset.configured === "true" && b.dataset.config) {
                    blocksData.push(JSON.parse(b.dataset.config));
                }
            });
            APP.timeline.push({ blocks: blocksData });
        });
    }

    initTimeline();

    // ================= 3. Three.js åœºæ™¯æ„å»º =================
    const container = document.getElementById('three-canvas-drone');
    const width = container.clientWidth;
    const height = container.clientHeight;

    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x050505, 0.002);

    const camera = new THREE.PerspectiveCamera(60, width / height, 1, 2000);
    camera.position.set(0, 50, 200);
    camera.lookAt(0, 50, 0);

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(width, height);
    renderer.setPixelRatio(window.devicePixelRatio);
    container.appendChild(renderer.domElement);

    const gridHelper = new THREE.GridHelper(400, 40, 0x333333, 0x111111);
    scene.add(gridHelper);

    const droneGeo = new THREE.SphereGeometry(1.5, 8, 8); 

    function initDrones() {
        APP.drones.forEach(d => scene.remove(d.mesh));
        APP.drones = [];
        const count = APP.config.count;
        const cols = Math.floor(Math.sqrt(count));
        
        for(let i=0; i<count; i++) {
            const material = new THREE.MeshBasicMaterial({ color: 0xffffff });
            const mesh = new THREE.Mesh(droneGeo, material);
            const row = Math.floor(i / cols);
            const col = i % cols;
            const x = (col - cols/2) * 5;
            const z = (row - cols/2) * 5;
            
            mesh.position.set(x, 0.5, z);
            scene.add(mesh);

            APP.drones.push({
                mesh: mesh,
                homePos: new THREE.Vector3(x, 0.5, z),
                targetPos: new THREE.Vector3(x, 0.5, z),
                baseColors: [new THREE.Color(1,1,1)], // å­˜å‚¨ THREE.Color å¯¹è±¡
                colorMode: 'solid',
                delay: 0
            });
        }
    }
    initDrones();

    // ================= 4. é˜Ÿå½¢ä¸é¢œè‰²è®¡ç®— =================
    
    function getTextPoints(text, count) {
        const canvas = document.createElement('canvas');
        canvas.width = 100; canvas.height = 100;
        const ctx = canvas.getContext('2d');
        ctx.font = 'bold 70px "Microsoft YaHei"'; // æ”¯æŒä¸­æ–‡
        ctx.fillStyle = 'white';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(text, 50, 50);
        
        const imageData = ctx.getImageData(0,0,100,100);
        const points = [];
        for(let y=0; y<100; y+=3) { // å¯†åº¦è°ƒæ•´
            for(let x=0; x<100; x+=3) {
                if(imageData.data[(y*100+x)*4] > 128) {
                    points.push(new THREE.Vector3((x-50)*3, (100-y)*2 + 20, 0));
                }
            }
        }
        return points;
    }

    function getShapePoints(shape, count) {
        const points = [];
        for(let i=0; i<count; i++) {
            const t = i / count;
            let x, y, z;
            if (shape === 'sphere') {
                const phi = Math.acos( -1 + ( 2 * i ) / count );
                const theta = Math.sqrt( count * Math.PI ) * phi;
                x = 60 * Math.cos(theta) * Math.sin(phi);
                y = 60 * Math.sin(theta) * Math.sin(phi) + 80;
                z = 60 * Math.cos(phi);
            } else if (shape === 'heart') {
                const angle = t * Math.PI * 2; 
                x = 16 * Math.pow(Math.sin(angle), 3) * 4;
                y = (13 * Math.cos(angle) - 5 * Math.cos(2*angle) - 2 * Math.cos(3*angle) - Math.cos(4*angle)) * 4 + 80;
                z = (Math.random()-0.5) * 10; // ç»™ä¸€ç‚¹åšåº¦
            } else if (shape === 'tree') {
                // ç®€å•çš„åœ†é”¥èºæ—‹
                const h = t * 100; // é«˜åº¦ 0-100
                const r = (100 - h) * 0.4; // åŠå¾„éšé«˜åº¦å‡å°
                const angle = t * 30;
                x = Math.cos(angle) * r;
                y = h + 20;
                z = Math.sin(angle) * r;
            } else { // Cube/Star/Default
                 const s = 80;
                 x = (Math.random() - 0.5) * s;
                 y = (Math.random() - 0.5) * s + 80;
                 z = (Math.random() - 0.5) * s;
            }
            points.push(new THREE.Vector3(x, y, z));
        }
        return points;
    }

    function calculateStageTargets(stageIndex) {
        if (stageIndex >= APP.timeline.length) return false;
        
        const layerData = APP.timeline[stageIndex];
        // è¿‡æ»¤æ‰æœªé…ç½®çš„ç§¯æœ¨ (Fix Bug #4)
        const validBlocks = layerData ? layerData.blocks.filter(b => b.configured) : [];
        
        if (validBlocks.length === 0) return false; // è¿™ä¸€è½®æ˜¯ç©ºçš„ï¼Œä¸æ‰§è¡Œ

        const dronesPerBlock = Math.floor(APP.drones.length / validBlocks.length);
        let droneIdx = 0;
        
        validBlocks.forEach((block, blockIdx) => {
            let points = block.type === 'shape' ? 
                         getShapePoints(block.shape, dronesPerBlock) : 
                         getTextPoints(block.text || '?', dronesPerBlock);
            
            // ç‚¹æ•°è¡¥å…¨æˆ–æˆªæ–­
            if (points.length === 0) points.push(new THREE.Vector3(0,50,0));
            const targetCount = dronesPerBlock;
            while(points.length < targetCount) {
                 points.push(points[Math.floor(Math.random()*points.length)].clone());
            }

            // åˆ†é…
            for (let i = 0; i < targetCount; i++) {
                if (droneIdx >= APP.drones.length) break;
                
                const d = APP.drones[droneIdx];
                const p = points[i];
                
                // åç§» (å¦‚æœå¤šä¸ªç§¯æœ¨)
                const offsetX = (validBlocks.length > 1) ? (blockIdx - (validBlocks.length-1)/2) * 80 : 0;
                d.targetPos.set(p.x + offsetX, p.y, p.z);
                
                // --- é¢œè‰²åˆ†é… (Fix Bug #3) ---
                d.colorMode = block.colorMode;
                d.baseColors = block.colors.map(c => new THREE.Color(c));
                
                if (block.colorMode === 'gradient') {
                    // æ¸å˜ï¼šæ ¹æ® i/total æ··åˆ
                    const ratio = i / targetCount;
                    // ç®€å•çº¿æ€§æ’å€¼ (åªå–å¤´å°¾é¢œè‰²ï¼Œå¦‚æœå¤šä¸ªé¢œè‰²éœ€è¦åˆ†æ®µï¼Œè¿™é‡Œç®€åŒ–ä¸ºåœ¨æ‰€æœ‰é¢œè‰²é—´æ’å€¼)
                    // ç®€åŒ–å®ç°ï¼šå–ä¸¤ä¸ªé¢œè‰² lerp
                    const c1 = d.baseColors[0];
                    const c2 = d.baseColors[d.baseColors.length - 1];
                    d.mesh.material.color.copy(c1).lerp(c2, ratio);
                } else if (block.colorMode === 'breathing') {
                    // å‘¼å¸æ¨¡å¼ï¼šå­˜ä¸‹æ‰€æœ‰é¢œè‰²ï¼Œupdate é‡Œç®—
                    d.mesh.material.color.copy(d.baseColors[0]); // åˆå§‹é¢œè‰²
                } else {
                    // Solid / Alternating
                    const c = d.baseColors[i % d.baseColors.length];
                    d.mesh.material.color.copy(c);
                }
                
                droneIdx++;
            }
        });

        // å¤šä½™çš„é£æœºå›å®¶
        for (let j = droneIdx; j < APP.drones.length; j++) {
             APP.drones[j].targetPos.copy(APP.drones[j].homePos);
             APP.drones[j].mesh.material.color.setHex(0x222222);
        }
        
        return true;
    }

    // ================= 5. åŠ¨ç”»ä¸æ‰‹åŠ¿æ§åˆ¶ =================

    function updateStatus(msg, type='normal') {
        const el = document.getElementById('sys-status');
        el.innerText = msg;
        el.style.color = type === 'error' ? 'red' : (type === 'success' ? '#00ff00' : 'cyan');
        el.style.borderColor = el.style.color;
    }

    function switchState(action) {
        if (action === 'TAKEOFF') {
            if (APP.timeline.length === 0 || !APP.timeline[0].blocks.some(b => b.configured)) {
                updateStatus("âš ï¸ ç¬¬1å±‚æœªè®¾ç½®æœ‰æ•ˆç§¯æœ¨", 'error');
                return;
            }
            APP.state = 'TAKEOFF';
            APP.currentStage = 0;
            updateStatus("ğŸš€ èµ·é£ä¸­...", 'cyan');
            setUILocked(true); // é”å®š UI (Fix Bug #5)
            
            if(calculateStageTargets(0)) {
                APP.drones.forEach((d, i) => d.delay = i * 0.005);
            }
            if(APP.config.auto) startAutoPlay();

        } else if (action === 'NEXT') {
            let nextStage = APP.currentStage + 1;
            // æ‰¾ä¸‹ä¸€ä¸ªæœ‰å†…å®¹çš„å±‚
            while(nextStage < APP.timeline.length && 
                  (!APP.timeline[nextStage].blocks || APP.timeline[nextStage].blocks.length === 0)) {
                nextStage++;
            }
            
            if (nextStage < APP.timeline.length) {
                APP.currentStage = nextStage;
                APP.state = 'TRANSITION';
                updateStatus(`å˜æ¢: ç¬¬ ${APP.currentStage+1} å¹•`);
                
                // å¦‚æœè¿™ä¸€å±‚æ˜¯æœªè®¾ç½®çš„ï¼ŒcalculateStageTargets ä¼šè¿”å› falseï¼Œæ­¤æ—¶æˆ‘ä»¬ä¿æŒä¸Šä¸€çŠ¶æ€
                if(calculateStageTargets(APP.currentStage)){
                    APP.drones.forEach(d => d.delay = 0);
                } else {
                    updateStatus(`ç¬¬ ${APP.currentStage+1} å¹•ä¸ºç©º`, 'error');
                }
            } else {
                updateStatus("å·²æ˜¯æœ€åä¸€å¹•");
            }

        } else if (action === 'PREV') {
            if (APP.currentStage > 0) {
                APP.currentStage--;
                APP.state = 'TRANSITION';
                updateStatus(`å˜æ¢: ç¬¬ ${APP.currentStage+1} å¹•`);
                calculateStageTargets(APP.currentStage);
                APP.drones.forEach(d => d.delay = 0);
            }

        } else if (action === 'LAND') {
            APP.state = 'LANDING';
            updateStatus("ğŸ›¬ é™è½ä¸­...");
            APP.drones.forEach((d, i) => {
                d.targetPos.copy(d.homePos);
                d.delay = i * 0.002;
                d.mesh.material.color.setHex(0xffffff);
            });
            if(APP.autoTimer) clearInterval(APP.autoTimer);
        }
    }

    function startAutoPlay() {
        if(APP.autoTimer) clearInterval(APP.autoTimer);
        APP.autoTimer = setInterval(() => {
            if(APP.state === 'LANDED') return;
            // ç®€å•åˆ¤æ–­æ˜¯å¦è¿˜æœ‰ä¸‹ä¸€å¹•
            if(APP.currentStage < APP.timeline.length - 2) { // -2 é¢„ç•™ä¿é™©
                switchState('NEXT');
            } else {
                switchState('LAND');
                clearInterval(APP.autoTimer);
            }
        }, parseInt(document.getElementById('inp-interval').value) * 1000);
    }

    const clock = new THREE.Clock();
    
    function animate() {
        requestAnimationFrame(animate);
        const dt = clock.getDelta();
        const time = clock.getElapsedTime();
        
        let allArrived = true;
        
        APP.drones.forEach(d => {
            // 1. è¿åŠ¨é€»è¾‘
            if (d.delay > 0) {
                d.delay -= dt;
                allArrived = false;
            } else {
                const dist = d.mesh.position.distanceTo(d.targetPos);
                if (dist > 0.5) { // ç¨å¾®æ”¾å®½åˆ¤å®š
                    allArrived = false;
                    const speed = APP.config.speed * 60 * dt; 
                    d.mesh.position.lerp(d.targetPos, 0.08 * speed); 
                } else {
                    d.mesh.position.copy(d.targetPos);
                }
            }

            // 2. é¢œè‰²åŠ¨æ€é€»è¾‘ (Breathing)
            if (d.colorMode === 'breathing' && d.baseColors.length > 0) {
                // æ ¹æ®æ—¶é—´å¾ªç¯åˆ‡æ¢é¢œè‰²
                // å‘¨æœŸ 2ç§’
                const t = (time * 2) % d.baseColors.length;
                const idx1 = Math.floor(t);
                const idx2 = (idx1 + 1) % d.baseColors.length;
                const alpha = t - idx1;
                d.mesh.material.color.copy(d.baseColors[idx1]).lerp(d.baseColors[idx2], alpha);
            }
        });

        // --- çŠ¶æ€æµè½¬æ ¸å¿ƒ (Fix Bug #1) ---
        // åªæœ‰å½“æ‰€æœ‰é£æœºåˆ°ä½ï¼Œä¸”å¤„äºè¿‡æ¸¡çŠ¶æ€æ—¶ï¼Œæ‰åˆ‡æ¢åˆ°æ‚¬åœ
        if (allArrived) {
            if (APP.state === 'TAKEOFF' || APP.state === 'TRANSITION') {
                APP.state = 'HOVERING';
                updateStatus("âœ… æ‚¬åœè¡¨æ¼”ä¸­ (è¯·å±•ç¤ºæ‰‹åŠ¿)", 'success');
            } else if (APP.state === 'LANDING') {
                APP.state = 'LANDED';
                updateStatus("System Ready");
                setUILocked(false); // è§£é” UI
            }
        }

        // ç›¸æœºåŠ¨æ•ˆ
        const r = 300;
        camera.position.x = r * Math.sin(time * 0.1);
        camera.position.z = r * Math.cos(time * 0.1);
        camera.lookAt(0, 60, 0);

        renderer.render(scene, camera);
    }
    animate();

    // ================= 6. æ‰‹åŠ¿è¯†åˆ« =================
    const videoElement = document.getElementById('drone-video');
    const canvasElement = document.getElementById('drone-mask-canvas');
    const canvasCtx = canvasElement.getContext('2d');
    
    let lastPalmPos = null;

    function onResults(results) {
        canvasCtx.save();
        canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
        
        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
            const landmarks = results.multiHandLandmarks[0];
            drawConnectors(canvasCtx, landmarks, HAND_CONNECTIONS, {color: '#00FFFF', lineWidth: 2});
            drawLandmarks(canvasCtx, landmarks, {color: '#FF0000', lineWidth: 1, radius: 2});
            
            const palm = landmarks[9]; 
            
            if (APP.gestureCooldown > 0) {
                APP.gestureCooldown--;
                lastPalmPos = palm;
                canvasCtx.restore();
                return;
            }

            if (lastPalmPos) {
                const dx = palm.x - lastPalmPos.x;
                const dy = palm.y - lastPalmPos.y;
                const swipeThreshold = 0.15; 
                
                if (!APP.config.auto) {
                    if (APP.state === 'LANDED') {
                        if (palm.y < 0.4) { 
                             switchState('TAKEOFF');
                             triggerCooldown(60);
                        }
                    } else if (APP.state === 'HOVERING') { // åªæœ‰æ‚¬åœæ—¶æ‰æ¥å—æŒ‡ä»¤ (Fix Bug #1)
                        if (dx > swipeThreshold) { 
                             switchState('NEXT');
                             triggerCooldown(40);
                        } else if (dx < -swipeThreshold) {
                             switchState('PREV');
                             triggerCooldown(40);
                        } else if (dy > swipeThreshold) {
                             switchState('LAND');
                             triggerCooldown(60);
                        }
                    }
                }
            }
            lastPalmPos = palm;
        } else {
            lastPalmPos = null;
        }
        canvasCtx.restore();
    }
    
    function triggerCooldown(frames) {
        APP.gestureCooldown = frames;
    }

    const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
    hands.setOptions({maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5});
    hands.onResults(onResults);
    
    const cameraUtils = new Camera(videoElement, {
        onFrame: async () => { await hands.send({image: videoElement}); },
        width: 320, height: 240
    });
    cameraUtils.start();

    window.addEventListener('resize', () => {
        if(!container) return;
        camera.aspect = container.clientWidth / container.clientHeight;
        camera.updateProjectionMatrix();
        renderer.setSize( container.clientWidth, container.clientHeight );
    });
})();
</script>