<style>
    /* === æ•´ä½“å¸ƒå±€ === */
    #drone-app {
        position: relative;
        display: flex;
        width: 100%;
        height: 600px;
        background: #111;
        font-family: 'Segoe UI', sans-serif;
        border-radius: 12px;
        overflow: hidden;
        color: #ddd;
    }

    /* === å·¦ä¾§ 3D èˆå° (70%) === */
    #stage-container {
        flex: 7;
        position: relative;
        background: linear-gradient(to bottom, #000 0%, #1a1a1a 100%);
        overflow: hidden;
    }
    #three-canvas-drone { width: 100%; height: 100%; display: block; }
    
    .drone-overlay {
        position: absolute; top: 20px; left: 20px; pointer-events: none; z-index: 10;
        display: flex; flex-direction: column; gap: 5px;
    }
    .status-row { display: flex; gap: 10px; align-items: center; }
    .status-tag {
        background: rgba(0, 255, 255, 0.1); border: 1px solid cyan;
        color: cyan; padding: 5px 10px; border-radius: 4px;
        font-size: 14px; text-shadow: 0 0 5px cyan;
        transition: all 0.3s; white-space: nowrap;
    }
    .info-tag {
        background: rgba(255, 255, 255, 0.1); border: 1px solid #666;
        color: #ccc; padding: 5px 10px; border-radius: 4px;
        font-size: 12px; white-space: nowrap;
    }
    
    .gesture-hint { font-size:12px; color:#888; background: rgba(0,0,0,0.5); padding: 5px; border-radius: 4px;}

    .cam-preview-box {
        position: absolute; bottom: 10px; left: 10px;
        width: 100px; height: 75px; background: #000;
        border: 1px solid #333; z-index: 5;
    }
    #drone-video { opacity: 0; position: absolute; pointer-events: none; }
    #drone-mask-canvas { width: 100%; height: 100%; transform: scaleX(-1); }

    /* === å³ä¾§ æ§åˆ¶å° (30%) === */
    #controls-panel {
        flex: 3;
        background: #1e1e1e;
        border-left: 1px solid #333;
        display: flex;
        flex-direction: column;
        user-select: none;
        transition: opacity 0.3s;
    }
    #controls-panel.ui-locked {
        opacity: 0.5; pointer-events: none; filter: grayscale(1);
    }

    .panel-section { padding: 15px; border-bottom: 1px solid #333; }
    .panel-title { font-size: 14px; color: #888; margin-bottom: 10px; text-transform: uppercase; letter-spacing: 1px; }
    .input-row { display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px; }
    .input-row label { font-size: 12px; }
    input[type="number"] { width: 50px; background: #333; border: none; color: white; padding: 4px; border-radius: 3px; }
    input[type="checkbox"] { accent-color: cyan; }

    .btn-start-auto {
        display: none; padding: 4px 10px; background: #00ff00; color: #000;
        border: none; border-radius: 4px; font-size: 11px; font-weight: bold;
        cursor: pointer; margin-right: 10px; box-shadow: 0 0 5px rgba(0,255,0,0.4);
    }
    .btn-start-auto:hover { background: #66ff66; box-shadow: 0 0 10px rgba(0,255,0,0.6); }

    /* ç§¯æœ¨æ—¶é—´è½´ */
    #timeline-container { flex: 1; overflow-y: auto; padding: 15px; background: #151515; }
    .timeline-layer {
        background: #252525; border-radius: 6px; margin-bottom: 10px; padding: 8px;
        border: 1px solid #333; display: flex; flex-wrap: wrap; gap: 5px;
        align-items: center; min-height: 40px; position: relative;
    }
    .layer-index { 
        position: absolute; left: -8px; top: 50%; transform: translateY(-50%); 
        font-size: 10px; color: #555; 
    }
    .block-item {
        background: #3a3a3a; padding: 5px 10px; border-radius: 4px; font-size: 12px;
        cursor: pointer; border: 1px solid #555; display: flex; align-items: center; gap: 5px;
    }
    .block-item.configured { border-color: cyan; color: cyan; }
    .block-color-preview { width: 12px; height: 12px; border-radius: 2px; background: #666; border: 1px solid #fff; }
    
    .add-btn {
        width: 24px; height: 24px; border-radius: 4px;
        border: 1px dashed #666; color: #666; display: flex; align-items: center; justify-content: center;
        cursor: pointer; transition: 0.2s;
    }
    .add-btn:hover { border-color: cyan; color: cyan; }

    /* === å¼¹çª— (Popup) === */
    #popup-overlay {
        display: none; position: absolute; top: 0; left: 0; width: 100%; height: 100%;
        background: rgba(0,0,0,0.7); z-index: 90; backdrop-filter: blur(2px);
    }
    #config-popup {
        display: none;
        position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
        width: 320px; background: #252525; border: 1px solid #444;
        box-shadow: 0 20px 50px rgba(0,0,0,0.9);
        z-index: 100; border-radius: 12px; padding: 20px;
    }
    .popup-row { margin-bottom: 15px; }
    .popup-row label { display: block; font-size: 12px; color: #aaa; margin-bottom: 5px; }
    select, input[type="text"] { width: 100%; background: #111; border: 1px solid #444; color: white; padding: 8px; border-radius: 4px; box-sizing: border-box; }
    
    .color-manager { display: flex; flex-wrap: wrap; gap: 5px; margin-top: 5px; background: #1a1a1a; padding: 5px; border-radius: 4px; min-height: 30px;}
    .color-chip { width: 24px; height: 24px; border-radius: 4px; border: 1px solid #555; cursor: pointer; position: relative; }
    .color-chip:hover::after { content: 'x'; position: absolute; top:-5px; right:-5px; font-size:10px; background:red; color:white; width:12px; height:12px; border-radius:50%; display:flex; justify-content:center; align-items:center; }
    .btn-add-color { width: 24px; height: 24px; border: 1px dashed #666; color: #666; display: flex; justify-content: center; align-items: center; cursor: pointer; border-radius: 4px; }
    
    .popup-btns { display: flex; justify-content: flex-end; gap: 10px; margin-top: 10px; border-top: 1px solid #333; padding-top: 15px; }
    .btn { padding: 6px 16px; border-radius: 4px; border: none; cursor: pointer; font-size: 12px; }
    .btn-cancel { background: #333; color: #ccc; }
    .btn-confirm { background: cyan; color: #000; font-weight: bold; }
    
    /* é¢„ä¼°æç¤º */
    #est-hint { font-size: 11px; color: #666; text-align: right; margin-top: -10px; margin-bottom: 10px; height: 16px;}
</style>

<div id="drone-app">
    <div id="stage-container">
        <div class="drone-overlay">
            <div class="status-row">
                <div id="sys-status" class="status-tag">System Ready</div>
                <div id="sys-info" class="info-tag">ğŸ›¸ 400 | âš¡ 8.0</div>
            </div>
            <div class="gesture-hint">
                ğŸ‘‹ æŠ¬æ‰‹: èµ·é£ | â¬…ï¸ å·¦æŒ¥: ä¸Šä¸€å¹• | â¡ï¸ å³æŒ¥: ä¸‹ä¸€å¹• | ğŸ‘‡ ä¸‹æŒ¥: é™è½
            </div>
        </div>
        <div class="cam-preview-box"><canvas id="drone-mask-canvas"></canvas></div>
        <video id="drone-video" playsinline></video>
        <div id="three-canvas-drone"></div>
    </div>

    <div id="controls-panel">
        <div class="panel-section">
            <div class="panel-title">é£è¡Œå‚æ•°</div>
            <div class="input-row">
                <label>æ— äººæœºæ•°é‡</label>
                <input type="number" id="inp-count" value="400" min="50" max="2000" step="50">
            </div>
            <div class="input-row">
                <label>é£è¡Œé€Ÿåº¦</label>
                <input type="number" id="inp-speed" value="8" min="1" max="20">
            </div>
            <div class="input-row">
                <label>è‡ªåŠ¨å˜æ¢</label>
                <div style="display:flex; align-items:center;">
                    <button id="btn-auto-start" class="btn-start-auto">â–¶ å¯åŠ¨</button>
                    <input type="checkbox" id="inp-auto">
                </div>
            </div>
            <div class="input-row" id="row-interval" style="opacity:0.5; pointer-events:none;">
                <label>æ¯å¹•æ—¶é•¿(s)</label>
                <input type="number" id="inp-interval" value="8">
            </div>
        </div>

        <div class="panel-title" style="padding: 15px 15px 0;">ç¼–æ’æ—¶é—´è½´</div>
        <div id="timeline-container"></div>
    </div>

    <div id="popup-overlay"></div>
    <div id="config-popup">
        <h3 style="margin:0 0 15px 0; color:white; font-size:16px;">ç§¯æœ¨é…ç½®</h3>
        
        <div class="popup-row">
            <label>å›¾æ¡ˆç±»å‹</label>
            <select id="cfg-type">
                <option value="shape">é¢„è®¾å‡ ä½•ä½“</option>
                <option value="text">æ–‡å­—ç”Ÿæˆ (æ”¯æŒé•¿å¥)</option>
            </select>
        </div>
        
        <div class="popup-row" id="group-shape">
            <label>é€‰æ‹©å½¢çŠ¶</label>
            <select id="cfg-shape">
                <option value="heart">â¤ï¸ çˆ±å¿ƒ (Heart)</option>
                <option value="star">â­ äº”è§’æ˜Ÿ (Star)</option>
                <option value="tree">ğŸŒ² åœ£è¯æ ‘ (Tree)</option>
                <option value="cube">ğŸ§Š ç«‹æ–¹ä½“ (Cube)</option>
                <option value="sphere">ğŸ”® çƒä½“ (Sphere)</option>
                <option value="helix">ğŸ§¬ åŒèºæ—‹ (Helix)</option>
            </select>
        </div>

        <div class="popup-row" id="group-text" style="display:none">
            <label>è¾“å…¥æ–‡å­—</label>
            <input type="text" id="cfg-text-val" placeholder="Hello World">
        </div>

        <div id="est-hint">é¢„ä¼°æ¶ˆè€—: 0 / 400</div>

        <div class="popup-row">
            <label>é¢œè‰²é…ç½®</label>
            <div class="color-manager" id="color-list-container">
                <div class="btn-add-color" onclick="addColorPicker()">+</div>
            </div>
        </div>

        <div class="popup-row">
            <label>é¢œè‰²æ•ˆæœ</label>
            <select id="cfg-color-mode">
                <option value="solid">æ— æ•ˆæœ (äº¤æ›¿åˆ†é…)</option>
                <option value="gradient">çº¿æ€§æ¸å˜ (å·¦->å³)</option>
                <option value="breathing">å‘¼å¸é—ªçƒ (åŠ¨æ€å¾ªç¯)</option>
            </select>
        </div>

        <div class="popup-btns">
            <button class="btn btn-cancel" id="btn-cancel">å–æ¶ˆ</button>
            <button class="btn btn-confirm" id="btn-ok">ç¡®å®šä¿å­˜</button>
        </div>
    </div>
</div>

<script src="js/three.min.js"></script>
<script src="js/camera_utils.js"></script>
<script src="js/control_utils.js"></script>
<script src="js/drawing_utils.js"></script>
<script src="js/hands.js"></script>

<script>
(function() {
    const APP = {
        drones: [],         
        timeline: [],       
        currentStage: -1,   
        state: 'LANDED',   
        config: {
            count: 400,
            speed: 0.08,
            auto: false,
            interval: 8000
        },
        autoTimer: null,
        gestureCooldown: 0,
        tempColors: ['#ff0000']
    };

    const timelineContainer = document.getElementById('timeline-container');
    const popup = document.getElementById('config-popup');
    const overlay = document.getElementById('popup-overlay');
    const controlsPanel = document.getElementById('controls-panel');
    const estHint = document.getElementById('est-hint');
    const sysInfo = document.getElementById('sys-info');
    let currentEditingBlock = null; 

    function setUILocked(locked) {
        if(locked) controlsPanel.classList.add('ui-locked');
        else controlsPanel.classList.remove('ui-locked');
    }

    // å®æ—¶æ›´æ–°é¡¶éƒ¨çŠ¶æ€
    function updateSysInfo() {
        sysInfo.innerText = `ğŸ›¸ ${APP.config.count} | âš¡ ${document.getElementById('inp-speed').value}`;
    }

    function initTimeline() { addLayer(); }

    function addLayer() {
        const div = document.createElement('div');
        div.className = 'timeline-layer';
        div.innerHTML = `<span class="layer-index">${APP.timeline.length + 1}</span>`;
        
        const addBtn = document.createElement('div');
        addBtn.className = 'add-btn';
        addBtn.innerHTML = '+';
        addBtn.onclick = () => addBlockToLayer(div, addBtn);
        
        div.appendChild(addBtn);
        timelineContainer.appendChild(div);
        APP.timeline.push({ blocks: [] });
    }

    function addBlockToLayer(layerDom, btnDom) {
        const block = document.createElement('div');
        block.className = 'block-item';
        block.innerHTML = `<div class="block-color-preview"></div><span>æœªè®¾ç½®</span>`;
        block.dataset.configured = "false";
        
        block.onclick = () => {
            if(APP.state !== 'LANDED') {
                alert("è¯·å…ˆé™è½æ— äººæœºå†ä¿®æ”¹è®¾ç½®ï¼");
                return;
            }
            openConfig(block, layerDom);
        };
        
        layerDom.insertBefore(block, btnDom);
        if (layerDom === timelineContainer.lastElementChild) {
            addLayer();
        }
    }

    window.addColorPicker = function() {
        APP.tempColors.push('#00ffff');
        renderColorList();
    }
    window.removeColor = function(index) {
        if(APP.tempColors.length > 1) {
            APP.tempColors.splice(index, 1);
            renderColorList();
        }
    }
    window.updateColor = function(index, val) {
        APP.tempColors[index] = val;
        renderColorList();
    }
    
    function renderColorList() {
        const container = document.getElementById('color-list-container');
        const addBtn = container.lastElementChild;
        container.innerHTML = '';
        
        APP.tempColors.forEach((c, i) => {
            const chip = document.createElement('div');
            chip.className = 'color-chip';
            chip.style.backgroundColor = c;
            
            const input = document.createElement('input');
            input.type = 'color';
            input.value = c;
            input.style.opacity = 0;
            input.style.position = 'absolute';
            input.style.width = '100%'; input.style.height = '100%'; input.style.cursor = 'pointer';
            input.oninput = (e) => {
                chip.style.backgroundColor = e.target.value;
                APP.tempColors[i] = e.target.value;
            };

            chip.title = "å•å‡»æ”¹è‰²ï¼ŒåŒå‡»åˆ é™¤";
            chip.ondblclick = () => removeColor(i);

            chip.appendChild(input);
            container.appendChild(chip);
        });
        container.appendChild(addBtn);
    }

    function openConfig(blockDom, layerDom) {
        currentEditingBlock = { dom: blockDom, layerIndex: Array.from(timelineContainer.children).indexOf(layerDom) };
        overlay.style.display = 'block';
        popup.style.display = 'block'; 

        if (blockDom.dataset.config) {
            const cfg = JSON.parse(blockDom.dataset.config);
            document.getElementById('cfg-type').value = cfg.type;
            document.getElementById('cfg-shape').value = cfg.shape;
            document.getElementById('cfg-text-val').value = cfg.text;
            document.getElementById('cfg-color-mode').value = cfg.colorMode || 'solid';
            APP.tempColors = cfg.colors || ['#ff0000'];
        } else {
            APP.tempColors = ['#00ffff'];
        }
        
        document.getElementById('cfg-type').dispatchEvent(new Event('change'));
        renderColorList();
        checkPointCount(); // æ‰“å¼€æ—¶æ£€æŸ¥ä¸€æ¬¡
    }

    // â˜…â˜…â˜… æ ¸å¿ƒå‡çº§ï¼šå®æ—¶è®¡ç®—ç‚¹æ•°æ¶ˆè€— â˜…â˜…â˜…
    function checkPointCount() {
        const type = document.getElementById('cfg-type').value;
        const text = document.getElementById('cfg-text-val').value;
        const currentTotal = APP.config.count;
        let estimated = 0;

        if (type === 'shape') {
            estimated = Math.min(currentTotal, 200); // å½¢çŠ¶é€šå¸¸ä¸ç”¨å¤ªå¤š
            estHint.innerText = `é¢„ä¼°æ¶ˆè€—: ${estimated} / ${currentTotal} (è‡ªåŠ¨é€‚é…)`;
            estHint.style.color = '#666';
        } else {
            // æ–‡å­—ï¼šç®€å•çš„ä¼°ç®—ç®—æ³•
            // å‡è®¾æ¯ä¸ªæ±‰å­—å¹³å‡éœ€è¦ 50-80 ä¸ªç‚¹æ‰èƒ½çœ‹æ¸…
            // è‹±æ–‡æ¯ä¸ªå­—æ¯éœ€è¦ 20-30 ä¸ªç‚¹
            // æˆ‘ä»¬é€šè¿‡ Canvas çœŸå®è®¡ç®—ä¸€ä¸‹ï¼ˆé‡‡æ ·ç‡ä½ä¸€ç‚¹ä»¥æé«˜æ€§èƒ½ï¼‰
            if(!text) {
                estHint.innerText = `é¢„ä¼°æ¶ˆè€—: 0 / ${currentTotal}`;
                return;
            }
            
            // å¿«é€Ÿæ¨¡æ‹Ÿè®¡ç®—
            const pts = getTextPoints(text, 1000, 5); // 5æ˜¯stepï¼Œç²—ç•¥è®¡ç®—
            estimated = pts.length;
            
            if (estimated > currentTotal) {
                estHint.innerText = `âš ï¸ è­¦å‘Š: æ–‡å­—å¤ªé•¿ (éœ€çº¦ ${estimated} æ¶)ï¼Œå»ºè®®å¢åŠ æ— äººæœºæ•°é‡`;
                estHint.style.color = 'red';
            } else {
                estHint.innerText = `é¢„ä¼°æ¶ˆè€—: ${estimated} / ${currentTotal}`;
                estHint.style.color = '#00ff00';
            }
        }
    }

    // ç›‘å¬è¾“å…¥ï¼Œå®æ—¶è®¡ç®—æç¤º
    document.getElementById('cfg-text-val').addEventListener('input', checkPointCount);

    document.getElementById('btn-cancel').onclick = closePopup;
    document.getElementById('btn-ok').onclick = saveConfig;
    document.getElementById('cfg-type').onchange = (e) => {
        document.getElementById('group-shape').style.display = e.target.value === 'shape' ? 'block' : 'none';
        document.getElementById('group-text').style.display = e.target.value === 'text' ? 'block' : 'none';
        checkPointCount();
    };
    
    // â˜…â˜…â˜… ç›‘å¬ï¼šæ— äººæœºæ•°é‡æ”¹å˜ï¼Œå®æ—¶é‡ç»˜ â˜…â˜…â˜…
    document.getElementById('inp-count').onchange = e => {
        const val = parseInt(e.target.value);
        if(APP.state !== 'LANDED') {
            alert("è¯·å…ˆé™è½å†ä¿®æ”¹æ•°é‡ï¼Œè¿™æ¶‰åŠåˆ°ç¡¬ä»¶é‡ç½®ï¼");
            e.target.value = APP.config.count; // æ¢å¤æ—§å€¼
            return;
        }
        APP.config.count = val;
        updateSysInfo();
        initDrones(); // é”€æ¯å¹¶é‡å»º
    };

    // â˜…â˜…â˜… ç›‘å¬ï¼šé€Ÿåº¦æ”¹å˜ï¼Œå®æ—¶ç”Ÿæ•ˆ â˜…â˜…â˜…
    document.getElementById('inp-speed').onchange = e => {
        const val = parseFloat(e.target.value);
        APP.config.speed = val / 100;
        updateSysInfo(); // æ›´æ–°é¡¶éƒ¨æ˜¾ç¤º
    };
    
    document.getElementById('inp-auto').onchange = e => {
        APP.config.auto = e.target.checked;
        const rowInterval = document.getElementById('row-interval');
        const btnStart = document.getElementById('btn-auto-start');
        rowInterval.style.opacity = APP.config.auto ? 1 : 0.5;
        rowInterval.style.pointerEvents = APP.config.auto ? 'auto' : 'none';
        btnStart.style.display = APP.config.auto ? 'block' : 'none';
    };

    document.getElementById('btn-auto-start').onclick = () => {
        if(APP.state === 'LANDED') {
            switchState('TAKEOFF');
        }
    };

    function closePopup() {
        overlay.style.display = 'none';
        popup.style.display = 'none';
        currentEditingBlock = null;
    }

    function saveConfig() {
        if (!currentEditingBlock) return;
        
        const type = document.getElementById('cfg-type').value;
        const shape = document.getElementById('cfg-shape').value;
        const text = document.getElementById('cfg-text-val').value;
        const colorMode = document.getElementById('cfg-color-mode').value;
        
        const config = {
            type, shape, text, colorMode,
            colors: [...APP.tempColors], 
            configured: true
        };

        let label = type === 'shape' ? shape : (text || 'Text');
        if(label.length > 5) label = label.substring(0,4) + '..'; // UIä¸Šæˆªæ–­è¿‡é•¿çš„æ–‡å­—
        currentEditingBlock.dom.querySelector('span').innerText = label;
        
        const preview = currentEditingBlock.dom.querySelector('.block-color-preview');
        if (config.colors.length > 1) {
            preview.style.background = `linear-gradient(45deg, ${config.colors.join(',')})`;
        } else {
            preview.style.background = config.colors[0];
        }
        
        currentEditingBlock.dom.classList.add('configured');
        currentEditingBlock.dom.dataset.configured = "true";
        currentEditingBlock.dom.dataset.config = JSON.stringify(config);

        rebuildTimelineData();
        closePopup();
    }

    function rebuildTimelineData() {
        APP.timeline = [];
        const layers = timelineContainer.querySelectorAll('.timeline-layer');
        layers.forEach(layer => {
            const blocksData = [];
            layer.querySelectorAll('.block-item').forEach(b => {
                if(b.dataset.configured === "true" && b.dataset.config) {
                    blocksData.push(JSON.parse(b.dataset.config));
                }
            });
            APP.timeline.push({ blocks: blocksData });
        });
    }

    initTimeline();

    // ================= 3. Three.js =================
    const container = document.getElementById('three-canvas-drone');
    const width = container.clientWidth;
    const height = container.clientHeight;

    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x050505, 0.002);

    const camera = new THREE.PerspectiveCamera(60, width / height, 1, 2000);
    camera.position.set(0, 50, 200);
    camera.lookAt(0, 50, 0);

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(width, height);
    renderer.setPixelRatio(window.devicePixelRatio);
    container.appendChild(renderer.domElement);

    const gridHelper = new THREE.GridHelper(400, 40, 0x333333, 0x111111);
    scene.add(gridHelper);

    const droneGeo = new THREE.SphereGeometry(1.5, 8, 8); 

    function initDrones() {
        // 1. å½»åº•æ¸…é™¤æ—§ Mesh
        APP.drones.forEach(d => {
            if(d.mesh) {
                scene.remove(d.mesh);
                d.mesh.geometry.dispose();
                d.mesh.material.dispose();
            }
        });
        APP.drones = [];

        // 2. é‡æ–°ç”Ÿæˆ
        const count = APP.config.count;
        const cols = Math.floor(Math.sqrt(count));
        
        for(let i=0; i<count; i++) {
            const material = new THREE.MeshBasicMaterial({ color: 0xffffff });
            const mesh = new THREE.Mesh(droneGeo, material);
            
            // æ’åˆ—é€»è¾‘ï¼šå°½é‡æ’æˆæ­£æ–¹å½¢
            const row = Math.floor(i / cols);
            const col = i % cols;
            // é—´è·ç¨å¾®ç´§å‡‘ç‚¹ï¼š4
            const x = (col - cols/2) * 4;
            const z = (row - Math.floor(count/cols)/2) * 4;
            
            mesh.position.set(x, 0.5, z);
            scene.add(mesh);

            APP.drones.push({
                mesh: mesh,
                homePos: new THREE.Vector3(x, 0.5, z),
                targetPos: new THREE.Vector3(x, 0.5, z),
                baseColors: [new THREE.Color(1,1,1)], 
                colorMode: 'solid',
                delay: 0
            });
        }
        console.log(`Initialized ${count} drones.`);
    }
    // åˆå§‹è¿è¡Œä¸€æ¬¡
    initDrones();
    updateSysInfo();

    // ================= 4. Logic =================
    
    // â˜…â˜…â˜… å¢å¼ºç‰ˆæ–‡å­—ç”Ÿæˆï¼šæ”¯æŒå˜é•¿ï¼Œè‡ªåŠ¨å¸ƒå±€ â˜…â˜…â˜…
    function getTextPoints(text, maxCount, step=3) {
        const canvas = document.createElement('canvas');
        // æ ¹æ®å­—æ•°åŠ¨æ€è°ƒæ•´ç”»å¸ƒå¤§å°
        const fontSize = 70;
        const textLen = text.length;
        canvas.width = Math.max(100, textLen * fontSize); // å®½åº¦éšå­—æ•°å˜
        canvas.height = 100;
        
        const ctx = canvas.getContext('2d');
        ctx.font = `bold ${fontSize}px "Microsoft YaHei", sans-serif`; 
        ctx.fillStyle = 'white';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(text, canvas.width / 2, 50);
        
        const imageData = ctx.getImageData(0,0, canvas.width, 100);
        const points = [];
        
        // é‡‡æ ·
        for(let y=0; y<100; y+=step) { 
            for(let x=0; x<canvas.width; x+=step) {
                if(imageData.data[(y*canvas.width+x)*4] > 128) {
                    // æ˜ å°„å›3D: è®©æ–‡å­—å±…ä¸­
                    points.push(new THREE.Vector3((x - canvas.width/2)*3, (100-y)*2 + 20, 0));
                }
            }
        }
        return points;
    }

    function getShapePoints(shape, count) {
        const points = [];
        for(let i=0; i<count; i++) {
            const t = i / count;
            let x, y, z;
            if (shape === 'sphere') {
                const phi = Math.acos( -1 + ( 2 * i ) / count );
                const theta = Math.sqrt( count * Math.PI ) * phi;
                x = 60 * Math.cos(theta) * Math.sin(phi);
                y = 60 * Math.sin(theta) * Math.sin(phi) + 80;
                z = 60 * Math.cos(phi);
            } else if (shape === 'heart') {
                const angle = t * Math.PI * 2; 
                x = 16 * Math.pow(Math.sin(angle), 3) * 4;
                y = (13 * Math.cos(angle) - 5 * Math.cos(2*angle) - 2 * Math.cos(3*angle) - Math.cos(4*angle)) * 4 + 80;
                z = (Math.random()-0.5) * 10; 
            } else if (shape === 'tree') {
                const h = t * 100; 
                const r = (100 - h) * 0.4; 
                const angle = t * 30;
                x = Math.cos(angle) * r;
                y = h + 20;
                z = Math.sin(angle) * r;
            } else { 
                 const s = 80;
                 x = (Math.random() - 0.5) * s;
                 y = (Math.random() - 0.5) * s + 80;
                 z = (Math.random() - 0.5) * s;
            }
            points.push(new THREE.Vector3(x, y, z));
        }
        return points;
    }

    function calculateStageTargets(stageIndex) {
        if (stageIndex >= APP.timeline.length) return false;
        
        const layerData = APP.timeline[stageIndex];
        const validBlocks = layerData ? layerData.blocks.filter(b => b.configured) : [];
        if (validBlocks.length === 0) return false; 

        // ç®€å•å‡åˆ†æ— äººæœº
        const dronesPerBlock = Math.floor(APP.drones.length / validBlocks.length);
        let droneIdx = 0;
        
        validBlocks.forEach((block, blockIdx) => {
            let points = [];
            
            if (block.type === 'shape') {
                points = getShapePoints(block.shape, dronesPerBlock);
            } else {
                // â˜… æ–‡å­—ç”Ÿæˆï¼šå¦‚æœæ–‡å­—å¤ªé•¿ï¼Œè¿™é‡Œä¼šå°è¯•ç”Ÿæˆæ‰€æœ‰ç‚¹
                // ä½†å¦‚æœç‚¹æ•° > dronesPerBlockï¼Œéœ€è¦é‡‡æ ·æˆªæ–­ï¼Œæˆ–è€…è®©å¤šå‡ºæ¥çš„ç‚¹éšæœºé£
                const text = block.text || '?';
                
                // åŠ¨æ€æ­¥é•¿ï¼šå¦‚æœå­—å¤šï¼Œç‚¹ä¸å¤Ÿï¼Œå°±å¢åŠ  step (ç¨€ç–åŒ–)
                // ç²—ç•¥ä¼°ç®—ï¼š1ä¸ªå­— ~ 500ç‚¹(step=1) -> 55ç‚¹(step=3)
                // å…ˆå°è¯•é«˜ç²¾åº¦
                points = getTextPoints(text, dronesPerBlock, 3);
                
                // å¦‚æœç‚¹å¤ªå¤šï¼Œè¶…è¿‡äº†åˆ†é…ç»™è¿™ä¸ªç§¯æœ¨çš„é£æœºæ•°ï¼Œå°±å¿…é¡»é™é‡‡æ ·(ç¨€ç–)
                if (points.length > dronesPerBlock) {
                    // é‡æ–°ç”Ÿæˆï¼ŒåŠ å¤§æ­¥é•¿ (ç®€å•ç²—æš´çš„ä¼˜åŒ–)
                    points = getTextPoints(text, dronesPerBlock, 4); 
                }
            }
            
            // å¦‚æœç‚¹è¿˜æ˜¯ä¸å¤Ÿï¼Œè¡¥å…¨
            if (points.length === 0) points.push(new THREE.Vector3(0,50,0));
            const targetCount = dronesPerBlock;
            // å¾ªç¯ä½¿ç”¨ç‚¹ï¼Œæˆ–è€…æˆªæ–­
            
            for (let i = 0; i < targetCount; i++) {
                if (droneIdx >= APP.drones.length) break;
                
                const d = APP.drones[droneIdx];
                // å¦‚æœ points ä¸å¤Ÿï¼Œå–æ¨¡å¾ªç¯ï¼›å¦‚æœ points å¤ªå¤šï¼Œåªå–å‰ N ä¸ª
                const p = points[i % points.length];
                
                const offsetX = (validBlocks.length > 1) ? (blockIdx - (validBlocks.length-1)/2) * 80 : 0;
                d.targetPos.set(p.x + offsetX, p.y, p.z);
                
                d.colorMode = block.colorMode;
                d.baseColors = block.colors.map(c => new THREE.Color(c));
                
                if (block.colorMode === 'gradient') {
                    const ratio = i / targetCount;
                    const c1 = d.baseColors[0];
                    const c2 = d.baseColors[d.baseColors.length - 1];
                    d.mesh.material.color.copy(c1).lerp(c2, ratio);
                } else if (block.colorMode === 'breathing') {
                    d.mesh.material.color.copy(d.baseColors[0]); 
                } else {
                    const c = d.baseColors[i % d.baseColors.length];
                    d.mesh.material.color.copy(c);
                }
                
                droneIdx++;
            }
        });

        for (let j = droneIdx; j < APP.drones.length; j++) {
             APP.drones[j].targetPos.copy(APP.drones[j].homePos);
             APP.drones[j].mesh.material.color.setHex(0x222222);
        }
        
        return true;
    }

    // ================= 5. Animation =================

    function updateStatus(msg, type='normal') {
        const el = document.getElementById('sys-status');
        el.innerText = msg;
        el.style.color = type === 'error' ? 'red' : (type === 'success' ? '#00ff00' : 'cyan');
        el.style.borderColor = el.style.color;
    }

    function switchState(action) {
        if (action === 'TAKEOFF') {
            if (APP.timeline.length === 0 || !APP.timeline[0].blocks.some(b => b.configured)) {
                updateStatus("âš ï¸ ç¬¬1å±‚æœªè®¾ç½®æœ‰æ•ˆç§¯æœ¨", 'error');
                return;
            }
            APP.state = 'TAKEOFF';
            APP.currentStage = 0;
            updateStatus("ğŸš€ èµ·é£ä¸­...", 'cyan');
            setUILocked(true); 
            
            if(calculateStageTargets(0)) {
                APP.drones.forEach((d, i) => d.delay = i * 0.005);
            }
            if(APP.config.auto) startAutoPlay();

        } else if (action === 'NEXT') {
            let nextStage = APP.currentStage + 1;
            while(nextStage < APP.timeline.length && 
                  (!APP.timeline[nextStage].blocks || APP.timeline[nextStage].blocks.length === 0)) {
                nextStage++;
            }
            
            if (nextStage < APP.timeline.length) {
                APP.currentStage = nextStage;
                APP.state = 'TRANSITION';
                updateStatus(`å˜æ¢: ç¬¬ ${APP.currentStage+1} å¹•`);
                
                if(calculateStageTargets(APP.currentStage)){
                    APP.drones.forEach(d => d.delay = 0);
                } else {
                    updateStatus(`ç¬¬ ${APP.currentStage+1} å¹•ä¸ºç©º`, 'error');
                }
            } else {
                updateStatus("å·²æ˜¯æœ€åä¸€å¹•");
            }

        } else if (action === 'PREV') {
            if (APP.currentStage > 0) {
                APP.currentStage--;
                APP.state = 'TRANSITION';
                updateStatus(`å˜æ¢: ç¬¬ ${APP.currentStage+1} å¹•`);
                calculateStageTargets(APP.currentStage);
                APP.drones.forEach(d => d.delay = 0);
            }

        } else if (action === 'LAND') {
            APP.state = 'LANDING';
            updateStatus("ğŸ›¬ é™è½ä¸­...");
            APP.drones.forEach((d, i) => {
                d.targetPos.copy(d.homePos);
                d.delay = i * 0.002;
                d.mesh.material.color.setHex(0xffffff);
            });
            if(APP.autoTimer) clearInterval(APP.autoTimer);
        }
    }

    function startAutoPlay() {
        if(APP.autoTimer) clearInterval(APP.autoTimer);
        APP.autoTimer = setInterval(() => {
            if(APP.state === 'LANDED') return;
            if(APP.currentStage < APP.timeline.length - 2) { 
                switchState('NEXT');
            } else {
                switchState('LAND');
                clearInterval(APP.autoTimer);
            }
        }, parseInt(document.getElementById('inp-interval').value) * 1000);
    }

    const clock = new THREE.Clock();
    
    function animate() {
        requestAnimationFrame(animate);
        const dt = clock.getDelta();
        const time = clock.getElapsedTime();
        
        let allArrived = true;
        
        APP.drones.forEach(d => {
            if (d.delay > 0) {
                d.delay -= dt;
                allArrived = false;
            } else {
                const dist = d.mesh.position.distanceTo(d.targetPos);
                if (dist > 0.5) { 
                    allArrived = false;
                    const speed = APP.config.speed * 60 * dt; 
                    d.mesh.position.lerp(d.targetPos, 0.08 * speed); 
                } else {
                    d.mesh.position.copy(d.targetPos);
                }
            }

            if (d.colorMode === 'breathing' && d.baseColors.length > 0) {
                const t = (time * 2) % d.baseColors.length;
                const idx1 = Math.floor(t);
                const idx2 = (idx1 + 1) % d.baseColors.length;
                const alpha = t - idx1;
                d.mesh.material.color.copy(d.baseColors[idx1]).lerp(d.baseColors[idx2], alpha);
            }
        });

        if (allArrived) {
            if (APP.state === 'TAKEOFF' || APP.state === 'TRANSITION') {
                APP.state = 'HOVERING';
                updateStatus("âœ… æ‚¬åœè¡¨æ¼”ä¸­", 'success');
            } else if (APP.state === 'LANDING') {
                APP.state = 'LANDED';
                updateStatus("System Ready");
                setUILocked(false); 
            }
        }

        const r = 300;
        camera.position.x = r * Math.sin(time * 0.1);
        camera.position.z = r * Math.cos(time * 0.1);
        camera.lookAt(0, 60, 0);

        renderer.render(scene, camera);
    }
    animate();

    // ================= 6. Gestures =================
    const videoElement = document.getElementById('drone-video');
    const canvasElement = document.getElementById('drone-mask-canvas');
    const canvasCtx = canvasElement.getContext('2d');
    
    let lastPalmPos = null;

    function onResults(results) {
        canvasCtx.save();
        canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
        
        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
            const landmarks = results.multiHandLandmarks[0];
            drawConnectors(canvasCtx, landmarks, HAND_CONNECTIONS, {color: '#00FFFF', lineWidth: 2});
            drawLandmarks(canvasCtx, landmarks, {color: '#FF0000', lineWidth: 1, radius: 2});
            
            const palm = landmarks[9]; 
            
            if (APP.gestureCooldown > 0) {
                APP.gestureCooldown--;
                lastPalmPos = palm;
                canvasCtx.restore();
                return;
            }

            if (lastPalmPos) {
                const dx = palm.x - lastPalmPos.x;
                const dy = palm.y - lastPalmPos.y;
                const swipeThreshold = 0.15; 
                
                if (!APP.config.auto) {
                    if (APP.state === 'LANDED') {
                        if (palm.y < 0.4) { 
                             switchState('TAKEOFF');
                             triggerCooldown(60);
                        }
                    } else if (APP.state === 'HOVERING') { 
                        if (dx > swipeThreshold) { 
                             switchState('NEXT');
                             triggerCooldown(40);
                        } else if (dx < -swipeThreshold) {
                             switchState('PREV');
                             triggerCooldown(40);
                        } else if (dy > swipeThreshold) {
                             switchState('LAND');
                             triggerCooldown(60);
                        }
                    }
                }
            }
            lastPalmPos = palm;
        } else {
            lastPalmPos = null;
        }
        canvasCtx.restore();
    }
    
    function triggerCooldown(frames) {
        APP.gestureCooldown = frames;
    }

    const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
    hands.setOptions({maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5});
    hands.onResults(onResults);
    
    const cameraUtils = new Camera(videoElement, {
        onFrame: async () => { await hands.send({image: videoElement}); },
        width: 320, height: 240
    });
    cameraUtils.start();

    window.addEventListener('resize', () => {
        if(!container) return;
        camera.aspect = container.clientWidth / container.clientHeight;
        camera.updateProjectionMatrix();
        renderer.setSize( container.clientWidth, container.clientHeight );
    });
})();
</script>