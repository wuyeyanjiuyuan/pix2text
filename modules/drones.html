<style>
    /* === æ•´ä½“å¸ƒå±€ === */
    #drone-app {
        position: relative;
        display: flex;
        width: 100%;
        height: 600px;
        background: #050505; /* èƒŒæ™¯è°ƒæ›´æ·±é»‘ï¼Œçªå‡ºå…‰æ•ˆ */
        font-family: 'Segoe UI', sans-serif;
        border-radius: 12px;
        overflow: hidden;
        color: #ddd;
    }

    /* === å·¦ä¾§ 3D èˆå° (70%) === */
    #stage-container {
        flex: 7;
        position: relative;
        /* ç¨å¾®åŠ ä¸€ç‚¹å¾„å‘æ¸å˜ï¼Œè®©ä¸­å¿ƒäº®ä¸€ç‚¹ç‚¹ */
        background: radial-gradient(circle at center, #1a1a1a 0%, #000000 100%);
        overflow: hidden;
    }
    #three-canvas-drone { width: 100%; height: 100%; display: block; }
    
    .drone-overlay {
        position: absolute; top: 20px; left: 20px; pointer-events: none; z-index: 10;
        display: flex; flex-direction: column; gap: 5px;
    }
    .status-row { display: flex; gap: 10px; align-items: center; }
    .status-tag {
        background: rgba(0, 255, 255, 0.1); border: 1px solid cyan;
        color: cyan; padding: 5px 10px; border-radius: 4px;
        font-size: 14px; text-shadow: 0 0 5px cyan;
        transition: all 0.3s; white-space: nowrap;
    }
    .info-tag {
        background: rgba(255, 255, 255, 0.1); border: 1px solid #666;
        color: #ccc; padding: 5px 10px; border-radius: 4px;
        font-size: 12px; white-space: nowrap;
    }
    
    .gesture-hint { 
        font-size:12px; color:#fff; background: rgba(0,0,0,0.6); 
        padding: 8px; border-radius: 6px; border-left: 3px solid cyan;
        display: grid; grid-template-columns: 1fr 1fr; gap: 5px;
        width: 240px;
    }
    .gesture-item { display: flex; align-items: center; gap: 5px; }

    .cam-preview-box {
        position: absolute; bottom: 10px; left: 10px;
        width: 100px; height: 75px; background: #000;
        border: 1px solid #333; z-index: 5;
    }
    #drone-video { opacity: 0; position: absolute; pointer-events: none; }
    #drone-mask-canvas { width: 100%; height: 100%; transform: scaleX(-1); }

    /* === å³ä¾§ æ§åˆ¶å° (30%) === */
    #controls-panel {
        flex: 3;
        background: #1e1e1e;
        border-left: 1px solid #333;
        display: flex;
        flex-direction: column;
        user-select: none;
        transition: opacity 0.3s;
    }
    #controls-panel.ui-locked {
        opacity: 0.5; pointer-events: none; filter: grayscale(1);
    }

    .panel-section { padding: 15px; border-bottom: 1px solid #333; }
    .panel-title { font-size: 14px; color: #888; margin-bottom: 10px; text-transform: uppercase; letter-spacing: 1px; }
    .input-row { display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px; }
    .input-row label { font-size: 12px; }
    input[type="number"] { width: 50px; background: #333; border: none; color: white; padding: 4px; border-radius: 3px; }
    input[type="checkbox"] { accent-color: cyan; }

    .btn-start-auto {
        display: none; padding: 4px 10px; background: #00ff00; color: #000;
        border: none; border-radius: 4px; font-size: 11px; font-weight: bold;
        cursor: pointer; margin-right: 10px; box-shadow: 0 0 5px rgba(0,255,0,0.4);
    }
    .btn-start-auto:hover { background: #66ff66; box-shadow: 0 0 10px rgba(0,255,0,0.6); }

    #timeline-container { flex: 1; overflow-y: auto; padding: 15px; background: #151515; }
    .timeline-layer {
        background: #252525; border-radius: 6px; margin-bottom: 10px; padding: 8px;
        border: 1px solid #333; display: flex; flex-wrap: wrap; gap: 5px;
        align-items: center; min-height: 40px; position: relative;
    }
    .layer-index { 
        position: absolute; left: -8px; top: 50%; transform: translateY(-50%); 
        font-size: 10px; color: #555; 
    }
    .block-item {
        background: #3a3a3a; padding: 5px 10px; border-radius: 4px; font-size: 12px;
        cursor: pointer; border: 1px solid #555; display: flex; align-items: center; gap: 5px;
    }
    .block-item.configured { border-color: cyan; color: cyan; }
    .block-color-preview { width: 12px; height: 12px; border-radius: 2px; background: #666; border: 1px solid #fff; }
    
    .add-btn {
        width: 24px; height: 24px; border-radius: 4px;
        border: 1px dashed #666; color: #666; display: flex; align-items: center; justify-content: center;
        cursor: pointer; transition: 0.2s;
    }
    .add-btn:hover { border-color: cyan; color: cyan; }

    /* === å¼¹çª— (Popup) === */
    #popup-overlay {
        display: none; position: absolute; top: 0; left: 0; width: 100%; height: 100%;
        background: rgba(0,0,0,0.7); z-index: 90; backdrop-filter: blur(2px);
    }
    #config-popup {
        display: none;
        position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
        width: 320px; background: #252525; border: 1px solid #444;
        box-shadow: 0 20px 50px rgba(0,0,0,0.9);
        z-index: 100; border-radius: 12px; padding: 20px;
    }
    .popup-row { margin-bottom: 15px; }
    .popup-row label { display: block; font-size: 12px; color: #aaa; margin-bottom: 5px; }
    select, input[type="text"] { width: 100%; background: #111; border: 1px solid #444; color: white; padding: 8px; border-radius: 4px; box-sizing: border-box; }
    
    .color-manager { display: flex; flex-wrap: wrap; gap: 5px; margin-top: 5px; background: #1a1a1a; padding: 5px; border-radius: 4px; min-height: 30px;}
    .color-chip { width: 24px; height: 24px; border-radius: 4px; border: 1px solid #555; cursor: pointer; position: relative; }
    .color-chip:hover::after { content: 'x'; position: absolute; top:-5px; right:-5px; font-size:10px; background:red; color:white; width:12px; height:12px; border-radius:50%; display:flex; justify-content:center; align-items:center; }
    .btn-add-color { width: 24px; height: 24px; border: 1px dashed #666; color: #666; display: flex; justify-content: center; align-items: center; cursor: pointer; border-radius: 4px; }
    
    .popup-btns { display: flex; justify-content: flex-end; gap: 10px; margin-top: 10px; border-top: 1px solid #333; padding-top: 15px; }
    .btn { padding: 6px 16px; border-radius: 4px; border: none; cursor: pointer; font-size: 12px; }
    .btn-cancel { background: #333; color: #ccc; }
    .btn-confirm { background: cyan; color: #000; font-weight: bold; }
    
    #est-hint { font-size: 11px; color: #666; text-align: right; margin-top: -10px; margin-bottom: 10px; height: 16px;}
</style>

<div id="drone-app">
    <div id="stage-container">
        <div class="drone-overlay">
            <div class="status-row">
                <div id="sys-status" class="status-tag">System Ready</div>
                <div id="sys-info" class="info-tag">ğŸ›¸ 400 | âš¡ 8.0</div>
            </div>
            <div class="gesture-hint">
                <div class="gesture-item">âœ‹ <span>èµ·é£</span></div>
                <div class="gesture-item">âœŠ <span>é™è½</span></div>
                <div class="gesture-item">âœŒï¸ <span>ä¸‹ä¸€å¹•</span></div>
                <div class="gesture-item">â˜ï¸ <span>ä¸Šä¸€å¹•</span></div>
            </div>
        </div>
        <div class="cam-preview-box"><canvas id="drone-mask-canvas"></canvas></div>
        <video id="drone-video" playsinline></video>
        <div id="three-canvas-drone"></div>
    </div>

    <div id="controls-panel">
        <div class="panel-section">
            <div class="panel-title">é£è¡Œå‚æ•°</div>
            <div class="input-row">
                <label>æ— äººæœºæ•°é‡</label>
                <input type="number" id="inp-count" value="400" min="50" max="2000" step="50">
            </div>
            <div class="input-row">
                <label>é£è¡Œé€Ÿåº¦</label>
                <input type="number" id="inp-speed" value="8" min="1" max="20">
            </div>
            <div class="input-row">
                <label>è‡ªåŠ¨å˜æ¢</label>
                <div style="display:flex; align-items:center;">
                    <button id="btn-auto-start" class="btn-start-auto">â–¶ å¯åŠ¨</button>
                    <input type="checkbox" id="inp-auto">
                </div>
            </div>
            <div class="input-row" id="row-interval" style="opacity:0.5; pointer-events:none;">
                <label>æ¯å¹•æ—¶é•¿(s)</label>
                <input type="number" id="inp-interval" value="8">
            </div>
        </div>

        <div class="panel-title" style="padding: 15px 15px 0;">ç¼–æ’æ—¶é—´è½´</div>
        <div id="timeline-container"></div>
    </div>

    <div id="popup-overlay"></div>
    <div id="config-popup">
        <h3 style="margin:0 0 15px 0; color:white; font-size:16px;">ç§¯æœ¨é…ç½®</h3>
        
        <div class="popup-row">
            <label>å›¾æ¡ˆç±»å‹</label>
            <select id="cfg-type">
                <option value="shape">é¢„è®¾å‡ ä½•ä½“</option>
                <option value="text">æ–‡å­—ç”Ÿæˆ (æ”¯æŒé•¿å¥)</option>
            </select>
        </div>
        
        <div class="popup-row" id="group-shape">
            <label>é€‰æ‹©å½¢çŠ¶</label>
            <select id="cfg-shape">
                <option value="heart">â¤ï¸ çˆ±å¿ƒ (Heart)</option>
                <option value="star">â­ äº”è§’æ˜Ÿ (Star)</option>
                <option value="tree">ğŸŒ² åœ£è¯æ ‘ (Tree)</option>
                <option value="cube">ğŸ§Š ç«‹æ–¹ä½“ (Cube)</option>
                <option value="sphere">ğŸ”® çƒä½“ (Sphere)</option>
                <option value="helix">ğŸ§¬ åŒèºæ—‹ (Helix)</option>
            </select>
        </div>

        <div class="popup-row" id="group-text" style="display:none">
            <label>è¾“å…¥æ–‡å­—</label>
            <input type="text" id="cfg-text-val" placeholder="Hello World">
        </div>

        <div id="est-hint">é¢„ä¼°æ¶ˆè€—: 0 / 400</div>

        <div class="popup-row">
            <label>é¢œè‰²é…ç½®</label>
            <div class="color-manager" id="color-list-container">
                <div class="btn-add-color" onclick="addColorPicker()">+</div>
            </div>
        </div>

        <div class="popup-row">
            <label>é¢œè‰²æ•ˆæœ</label>
            <select id="cfg-color-mode">
                <option value="solid">æ— æ•ˆæœ (äº¤æ›¿åˆ†é…)</option>
                <option value="gradient">çº¿æ€§æ¸å˜ (å·¦->å³)</option>
                <option value="breathing">å‘¼å¸é—ªçƒ (åŠ¨æ€å¾ªç¯)</option>
            </select>
        </div>

        <div class="popup-btns">
            <button class="btn btn-cancel" id="btn-cancel">å–æ¶ˆ</button>
            <button class="btn btn-confirm" id="btn-ok">ç¡®å®šä¿å­˜</button>
        </div>
    </div>
</div>

<script src="js/three.min.js"></script>
<script src="js/camera_utils.js"></script>
<script src="js/control_utils.js"></script>
<script src="js/drawing_utils.js"></script>
<script src="js/hands.js"></script>

<script>
(function() {
    const APP = {
        drones: [],         
        timeline: [],       
        currentStage: -1,   
        state: 'LANDED',   
        config: {
            count: 400,
            speed: 0.08,
            auto: false,
            interval: 8000
        },
        autoTimer: null,
        gestureCooldown: 0,
        tempColors: ['#ff0000'],
        cameraRadius: 200,      
        targetRadius: 200,      
        cameraHeight: 50,       
        targetHeight: 50,
        // å…¨å±€çº¹ç†ç¼“å­˜
        droneTexture: null 
    };

    const timelineContainer = document.getElementById('timeline-container');
    const popup = document.getElementById('config-popup');
    const overlay = document.getElementById('popup-overlay');
    const controlsPanel = document.getElementById('controls-panel');
    const estHint = document.getElementById('est-hint');
    const sysInfo = document.getElementById('sys-info');
    let currentEditingBlock = null; 

    // â˜…â˜…â˜… æ ¸å¿ƒï¼šåˆ›å»ºè‡ªå‘å…‰çš„å…‰æ™•çº¹ç† â˜…â˜…â˜…
    function createDroneTexture() {
        if(APP.droneTexture) return APP.droneTexture;
        const canvas = document.createElement('canvas');
        canvas.width = 64; canvas.height = 64;
        const context = canvas.getContext('2d');
        // å¾„å‘æ¸å˜ï¼šæ¨¡æ‹Ÿ LED ç¯èŠ¯
        const gradient = context.createRadialGradient(32, 32, 0, 32, 32, 32);
        gradient.addColorStop(0, 'rgba(255,255,255,1)');    // ä¸­å¿ƒæäº®
        gradient.addColorStop(0.2, 'rgba(255,255,255,0.8)'); // é«˜å…‰åŒº
        gradient.addColorStop(0.5, 'rgba(255,255,255,0.2)'); // æ³›å…‰åŒº
        gradient.addColorStop(1, 'rgba(0,0,0,0)');           // è¾¹ç¼˜é€æ˜
        
        context.fillStyle = gradient;
        context.fillRect(0,0,64,64);
        APP.droneTexture = new THREE.CanvasTexture(canvas);
        return APP.droneTexture;
    }

    function setUILocked(locked) {
        if(locked) controlsPanel.classList.add('ui-locked');
        else controlsPanel.classList.remove('ui-locked');
    }

    function updateSysInfo() {
        sysInfo.innerText = `ğŸ›¸ ${APP.config.count} | âš¡ ${document.getElementById('inp-speed').value}`;
    }

    function initTimeline() { addLayer(); }

    function addLayer() {
        const div = document.createElement('div');
        div.className = 'timeline-layer';
        div.innerHTML = `<span class="layer-index">${APP.timeline.length + 1}</span>`;
        
        const addBtn = document.createElement('div');
        addBtn.className = 'add-btn';
        addBtn.innerHTML = '+';
        addBtn.onclick = () => addBlockToLayer(div, addBtn);
        
        div.appendChild(addBtn);
        timelineContainer.appendChild(div);
        APP.timeline.push({ blocks: [] });
    }

    function addBlockToLayer(layerDom, btnDom) {
        const block = document.createElement('div');
        block.className = 'block-item';
        block.innerHTML = `<div class="block-color-preview"></div><span>æœªè®¾ç½®</span>`;
        block.dataset.configured = "false";
        block.onclick = () => {
            if(APP.state !== 'LANDED') {
                alert("è¯·å…ˆé™è½æ— äººæœºå†ä¿®æ”¹è®¾ç½®ï¼");
                return;
            }
            openConfig(block, layerDom);
        };
        layerDom.insertBefore(block, btnDom);
        if (layerDom === timelineContainer.lastElementChild) {
            addLayer();
        }
    }

    window.addColorPicker = function() {
        APP.tempColors.push('#00ffff');
        renderColorList();
    }
    window.removeColor = function(index) {
        if(APP.tempColors.length > 1) {
            APP.tempColors.splice(index, 1);
            renderColorList();
        }
    }
    window.updateColor = function(index, val) {
        APP.tempColors[index] = val;
        renderColorList();
    }
    
    function renderColorList() {
        const container = document.getElementById('color-list-container');
        const addBtn = container.lastElementChild;
        container.innerHTML = '';
        APP.tempColors.forEach((c, i) => {
            const chip = document.createElement('div');
            chip.className = 'color-chip';
            chip.style.backgroundColor = c;
            const input = document.createElement('input');
            input.type = 'color';
            input.value = c;
            input.style.opacity = 0;
            input.style.position = 'absolute';
            input.style.width = '100%'; input.style.height = '100%'; input.style.cursor = 'pointer';
            input.oninput = (e) => {
                chip.style.backgroundColor = e.target.value;
                APP.tempColors[i] = e.target.value;
            };
            chip.title = "å•å‡»æ”¹è‰²ï¼ŒåŒå‡»åˆ é™¤";
            chip.ondblclick = () => removeColor(i);
            chip.appendChild(input);
            container.appendChild(chip);
        });
        container.appendChild(addBtn);
    }

    function openConfig(blockDom, layerDom) {
        currentEditingBlock = { dom: blockDom, layerIndex: Array.from(timelineContainer.children).indexOf(layerDom) };
        overlay.style.display = 'block';
        popup.style.display = 'block'; 
        if (blockDom.dataset.config) {
            const cfg = JSON.parse(blockDom.dataset.config);
            document.getElementById('cfg-type').value = cfg.type;
            document.getElementById('cfg-shape').value = cfg.shape;
            document.getElementById('cfg-text-val').value = cfg.text;
            document.getElementById('cfg-color-mode').value = cfg.colorMode || 'solid';
            APP.tempColors = cfg.colors || ['#ff0000'];
        } else {
            APP.tempColors = ['#00ffff'];
        }
        document.getElementById('cfg-type').dispatchEvent(new Event('change'));
        renderColorList();
        checkPointCount(); 
    }

    function checkPointCount() {
        const type = document.getElementById('cfg-type').value;
        const text = document.getElementById('cfg-text-val').value;
        const currentTotal = APP.config.count;
        let estimated = 0;
        if (type === 'shape') {
            estimated = Math.min(currentTotal, 200); 
            estHint.innerText = `é¢„ä¼°æ¶ˆè€—: ${estimated} / ${currentTotal} (è‡ªåŠ¨é€‚é…)`;
            estHint.style.color = '#666';
        } else {
            if(!text) {
                estHint.innerText = `é¢„ä¼°æ¶ˆè€—: 0 / ${currentTotal}`;
                return;
            }
            const pts = getTextPoints(text, 1000, 5); 
            estimated = pts.length;
            if (estimated > currentTotal) {
                estHint.innerText = `âš ï¸ è­¦å‘Š: æ–‡å­—å¤ªé•¿ (éœ€çº¦ ${estimated} æ¶)ï¼Œå»ºè®®å¢åŠ æ— äººæœºæ•°é‡`;
                estHint.style.color = 'red';
            } else {
                estHint.innerText = `é¢„ä¼°æ¶ˆè€—: ${estimated} / ${currentTotal}`;
                estHint.style.color = '#00ff00';
            }
        }
    }

    document.getElementById('cfg-text-val').addEventListener('input', checkPointCount);

    document.getElementById('btn-cancel').onclick = closePopup;
    document.getElementById('btn-ok').onclick = saveConfig;
    document.getElementById('cfg-type').onchange = (e) => {
        document.getElementById('group-shape').style.display = e.target.value === 'shape' ? 'block' : 'none';
        document.getElementById('group-text').style.display = e.target.value === 'text' ? 'block' : 'none';
        checkPointCount();
    };
    
    document.getElementById('inp-count').onchange = e => {
        const val = parseInt(e.target.value);
        if(APP.state !== 'LANDED') {
            alert("è¯·å…ˆé™è½å†ä¿®æ”¹æ•°é‡ï¼Œè¿™æ¶‰åŠåˆ°ç¡¬ä»¶é‡ç½®ï¼");
            e.target.value = APP.config.count; 
            return;
        }
        APP.config.count = val;
        updateSysInfo();
        initDrones(); 
    };

    document.getElementById('inp-speed').onchange = e => {
        const val = parseFloat(e.target.value);
        APP.config.speed = val / 100;
        updateSysInfo(); 
    };
    
    document.getElementById('inp-auto').onchange = e => {
        APP.config.auto = e.target.checked;
        const rowInterval = document.getElementById('row-interval');
        const btnStart = document.getElementById('btn-auto-start');
        rowInterval.style.opacity = APP.config.auto ? 1 : 0.5;
        rowInterval.style.pointerEvents = APP.config.auto ? 'auto' : 'none';
        btnStart.style.display = APP.config.auto ? 'block' : 'none';
    };

    document.getElementById('btn-auto-start').onclick = () => {
        if(APP.state === 'LANDED') {
            switchState('TAKEOFF');
        }
    };

    function closePopup() {
        overlay.style.display = 'none';
        popup.style.display = 'none';
        currentEditingBlock = null;
    }

    function saveConfig() {
        if (!currentEditingBlock) return;
        const type = document.getElementById('cfg-type').value;
        const shape = document.getElementById('cfg-shape').value;
        const text = document.getElementById('cfg-text-val').value;
        const colorMode = document.getElementById('cfg-color-mode').value;
        
        const config = {
            type, shape, text, colorMode,
            colors: [...APP.tempColors], 
            configured: true
        };

        let label = type === 'shape' ? shape : (text || 'Text');
        if(label.length > 5) label = label.substring(0,4) + '..'; 
        currentEditingBlock.dom.querySelector('span').innerText = label;
        
        const preview = currentEditingBlock.dom.querySelector('.block-color-preview');
        if (config.colors.length > 1) {
            preview.style.background = `linear-gradient(45deg, ${config.colors.join(',')})`;
        } else {
            preview.style.background = config.colors[0];
        }
        
        currentEditingBlock.dom.classList.add('configured');
        currentEditingBlock.dom.dataset.configured = "true";
        currentEditingBlock.dom.dataset.config = JSON.stringify(config);

        rebuildTimelineData();
        closePopup();
    }

    function rebuildTimelineData() {
        APP.timeline = [];
        const layers = timelineContainer.querySelectorAll('.timeline-layer');
        layers.forEach(layer => {
            const blocksData = [];
            layer.querySelectorAll('.block-item').forEach(b => {
                if(b.dataset.configured === "true" && b.dataset.config) {
                    blocksData.push(JSON.parse(b.dataset.config));
                }
            });
            APP.timeline.push({ blocks: blocksData });
        });
    }

    initTimeline();

    // ================= 3. Three.js =================
    const container = document.getElementById('three-canvas-drone');
    const width = container.clientWidth;
    const height = container.clientHeight;

    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x050505, 0.002);

    const camera = new THREE.PerspectiveCamera(60, width / height, 1, 2000);
    camera.position.set(0, 50, 200);
    camera.lookAt(0, 50, 0);

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(width, height);
    renderer.setPixelRatio(window.devicePixelRatio);
    container.appendChild(renderer.domElement);

    const gridHelper = new THREE.GridHelper(400, 40, 0x333333, 0x111111);
    scene.add(gridHelper);

    // â˜…â˜…â˜… ç”Ÿæˆæ— äººæœºé€»è¾‘å‡çº§ï¼šä½¿ç”¨ Sprite æ›¿ä»£ Mesh â˜…â˜…â˜…
    function initDrones() {
        APP.drones.forEach(d => {
            if(d.mesh) {
                scene.remove(d.mesh);
                d.mesh.material.dispose(); // Sprite æ²¡æœ‰ geometryï¼Œåªæœ‰ material
            }
        });
        APP.drones = [];

        const count = APP.config.count;
        const cols = Math.floor(Math.sqrt(count));
        const tex = createDroneTexture(); // å…±äº«çº¹ç†

        for(let i=0; i<count; i++) {
            // ä½¿ç”¨ SpriteMaterialï¼Œå¼€å¯ additive blending (å åŠ å‘å…‰)
            const material = new THREE.SpriteMaterial({ 
                map: tex, 
                color: 0xffffff,
                transparent: true,
                blending: THREE.AdditiveBlending, // å…³é”®ï¼šå…‰æ•ˆå åŠ 
                depthWrite: false // å…³é”®ï¼šé˜²æ­¢é®æŒ¡é»‘è¾¹
            });
            
            const sprite = new THREE.Sprite(material);
            // æ”¾å¤§ä¸€ç‚¹ï¼Œå› ä¸ºå…‰æ™•æ˜¯è™šçš„ï¼Œéœ€è¦æ¯”å®ä½“çƒå¤§æ‰èƒ½çœ‹æ¸…
            sprite.scale.set(6, 6, 1); 

            const row = Math.floor(i / cols);
            const col = i % cols;
            const x = (col - cols/2) * 4;
            const z = (row - Math.floor(count/cols)/2) * 4;
            
            sprite.position.set(x, 0.5, z);
            scene.add(sprite);

            APP.drones.push({
                mesh: sprite,
                homePos: new THREE.Vector3(x, 0.5, z),
                targetPos: new THREE.Vector3(x, 0.5, z),
                baseColors: [new THREE.Color(1,1,1)], 
                colorMode: 'solid',
                delay: 0
            });
        }
    }
    initDrones();
    updateSysInfo();

    // ================= 4. Logic =================
    
    function getTextPoints(text, maxCount, step=3) {
        const canvas = document.createElement('canvas');
        const fontSize = 70;
        const textLen = text.length;
        canvas.width = Math.max(100, textLen * fontSize); 
        canvas.height = 100;
        const ctx = canvas.getContext('2d');
        ctx.font = `bold ${fontSize}px "Microsoft YaHei", sans-serif`; 
        ctx.fillStyle = 'white';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(text, canvas.width / 2, 50);
        
        const imageData = ctx.getImageData(0,0, canvas.width, 100);
        const points = [];
        
        for(let y=0; y<100; y+=step) { 
            for(let x=0; x<canvas.width; x+=step) {
                if(imageData.data[(y*canvas.width+x)*4] > 128) {
                    points.push(new THREE.Vector3((x - canvas.width/2)*3, (100-y)*2 + 20, 0));
                }
            }
        }
        return points;
    }

    function getShapePoints(shape, count) {
        const points = [];
        for(let i=0; i<count; i++) {
            const t = i / count;
            let x, y, z;
            if (shape === 'sphere') {
                const phi = Math.acos( -1 + ( 2 * i ) / count );
                const theta = Math.sqrt( count * Math.PI ) * phi;
                x = 60 * Math.cos(theta) * Math.sin(phi);
                y = 60 * Math.sin(theta) * Math.sin(phi) + 80;
                z = 60 * Math.cos(phi);
            } else if (shape === 'heart') {
                const angle = t * Math.PI * 2; 
                x = 16 * Math.pow(Math.sin(angle), 3) * 4;
                y = (13 * Math.cos(angle) - 5 * Math.cos(2*angle) - 2 * Math.cos(3*angle) - Math.cos(4*angle)) * 4 + 80;
                z = (Math.random()-0.5) * 10; 
            } else if (shape === 'tree') {
                const h = t * 100; 
                const r = (100 - h) * 0.4; 
                const angle = t * 30;
                x = Math.cos(angle) * r;
                y = h + 20;
                z = Math.sin(angle) * r;
            } else { 
                 const s = 80;
                 x = (Math.random() - 0.5) * s;
                 y = (Math.random() - 0.5) * s + 80;
                 z = (Math.random() - 0.5) * s;
            }
            points.push(new THREE.Vector3(x, y, z));
        }
        return points;
    }

    function calculateStageTargets(stageIndex) {
        if (stageIndex >= APP.timeline.length) return false;
        
        const layerData = APP.timeline[stageIndex];
        const validBlocks = layerData ? layerData.blocks.filter(b => b.configured) : [];
        if (validBlocks.length === 0) return false; 

        const dronesPerBlock = Math.floor(APP.drones.length / validBlocks.length);
        let droneIdx = 0;
        
        let maxPos = 0; 
        let avgY = 0;   
        let activePointsCount = 0;

        validBlocks.forEach((block, blockIdx) => {
            let points = [];
            
            if (block.type === 'shape') {
                points = getShapePoints(block.shape, dronesPerBlock);
            } else {
                const text = block.text || '?';
                points = getTextPoints(text, dronesPerBlock, 3);
                if (points.length > dronesPerBlock) {
                    points = getTextPoints(text, dronesPerBlock, 4); 
                }
            }
            
            if (points.length === 0) points.push(new THREE.Vector3(0,50,0));
            const targetCount = dronesPerBlock;
            
            for (let i = 0; i < targetCount; i++) {
                if (droneIdx >= APP.drones.length) break;
                
                const d = APP.drones[droneIdx];
                const p = points[i % points.length];
                const offsetX = (validBlocks.length > 1) ? (blockIdx - (validBlocks.length-1)/2) * 80 : 0;
                
                d.targetPos.set(p.x + offsetX, p.y, p.z);
                
                const dist = Math.abs(d.targetPos.x); 
                if (dist > maxPos) maxPos = dist;
                avgY += d.targetPos.y;
                activePointsCount++;

                d.colorMode = block.colorMode;
                d.baseColors = block.colors.map(c => new THREE.Color(c));
                
                if (block.colorMode === 'gradient') {
                    const ratio = i / targetCount;
                    const c1 = d.baseColors[0];
                    const c2 = d.baseColors[d.baseColors.length - 1];
                    d.mesh.material.color.copy(c1).lerp(c2, ratio);
                } else if (block.colorMode === 'breathing') {
                    d.mesh.material.color.copy(d.baseColors[0]); 
                } else {
                    const c = d.baseColors[i % d.baseColors.length];
                    d.mesh.material.color.copy(c);
                }
                droneIdx++;
            }
        });

        if (activePointsCount > 0) {
            const fov = 60 * (Math.PI / 180);
            const safeDistance = (maxPos * 1.3) / Math.tan(fov / 2);
            APP.targetRadius = Math.max(200, Math.min(safeDistance, 800));
            APP.targetHeight = avgY / activePointsCount;
        }

        for (let j = droneIdx; j < APP.drones.length; j++) {
             APP.drones[j].targetPos.copy(APP.drones[j].homePos);
             APP.drones[j].mesh.material.color.setHex(0x222222);
        }
        return true;
    }

    // ================= 5. Animation =================

    function updateStatus(msg, type='normal') {
        const el = document.getElementById('sys-status');
        el.innerText = msg;
        el.style.color = type === 'error' ? 'red' : (type === 'success' ? '#00ff00' : 'cyan');
        el.style.borderColor = el.style.color;
    }

    function switchState(action) {
        if (action === 'TAKEOFF') {
            if (APP.timeline.length === 0 || !APP.timeline[0].blocks.some(b => b.configured)) {
                updateStatus("âš ï¸ ç¬¬1å±‚æœªè®¾ç½®æœ‰æ•ˆç§¯æœ¨", 'error');
                return;
            }
            APP.state = 'TAKEOFF';
            APP.currentStage = 0;
            updateStatus("ğŸš€ èµ·é£ä¸­...", 'cyan');
            setUILocked(true); 
            
            if(calculateStageTargets(0)) {
                APP.drones.forEach((d, i) => d.delay = i * 0.005);
            }
            if(APP.config.auto) startAutoPlay();

        } else if (action === 'NEXT') {
            let nextStage = APP.currentStage + 1;
            while(nextStage < APP.timeline.length && 
                  (!APP.timeline[nextStage].blocks || APP.timeline[nextStage].blocks.length === 0)) {
                nextStage++;
            }
            
            if (nextStage < APP.timeline.length) {
                APP.currentStage = nextStage;
                APP.state = 'TRANSITION';
                updateStatus(`å˜æ¢: ç¬¬ ${APP.currentStage+1} å¹•`);
                
                if(calculateStageTargets(APP.currentStage)){
                    APP.drones.forEach(d => d.delay = 0);
                } else {
                    updateStatus(`ç¬¬ ${APP.currentStage+1} å¹•ä¸ºç©º`, 'error');
                }
            } else {
                updateStatus("å·²æ˜¯æœ€åä¸€å¹•");
            }

        } else if (action === 'PREV') {
            if (APP.currentStage > 0) {
                APP.currentStage--;
                APP.state = 'TRANSITION';
                updateStatus(`å˜æ¢: ç¬¬ ${APP.currentStage+1} å¹•`);
                calculateStageTargets(APP.currentStage);
                APP.drones.forEach(d => d.delay = 0);
            }

        } else if (action === 'LAND') {
            APP.state = 'LANDING';
            updateStatus("ğŸ›¬ é™è½ä¸­...");
            APP.drones.forEach((d, i) => {
                d.targetPos.copy(d.homePos);
                d.delay = i * 0.002;
                d.mesh.material.color.setHex(0xffffff);
            });
            APP.targetRadius = 200;
            APP.targetHeight = 50;
            if(APP.autoTimer) clearInterval(APP.autoTimer);
        }
    }

    function startAutoPlay() {
        if(APP.autoTimer) clearInterval(APP.autoTimer);
        APP.autoTimer = setInterval(() => {
            if(APP.state === 'LANDED') return;
            if(APP.currentStage < APP.timeline.length - 2) { 
                switchState('NEXT');
            } else {
                switchState('LAND');
                clearInterval(APP.autoTimer);
            }
        }, parseInt(document.getElementById('inp-interval').value) * 1000);
    }

    const clock = new THREE.Clock();
    
    function animate() {
        requestAnimationFrame(animate);
        const dt = clock.getDelta();
        const time = clock.getElapsedTime();
        
        let allArrived = true;
        
        APP.drones.forEach(d => {
            if (d.delay > 0) {
                d.delay -= dt;
                allArrived = false;
            } else {
                const dist = d.mesh.position.distanceTo(d.targetPos);
                if (dist > 0.5) { 
                    allArrived = false;
                    const speed = APP.config.speed * 60 * dt; 
                    d.mesh.position.lerp(d.targetPos, 0.08 * speed); 
                } else {
                    d.mesh.position.copy(d.targetPos);
                }
            }

            if (d.colorMode === 'breathing' && d.baseColors.length > 0) {
                const t = (time * 2) % d.baseColors.length;
                const idx1 = Math.floor(t);
                const idx2 = (idx1 + 1) % d.baseColors.length;
                const alpha = t - idx1;
                d.mesh.material.color.copy(d.baseColors[idx1]).lerp(d.baseColors[idx2], alpha);
            }
        });

        if (allArrived) {
            if (APP.state === 'TAKEOFF' || APP.state === 'TRANSITION') {
                APP.state = 'HOVERING';
                updateStatus("âœ… æ‚¬åœè¡¨æ¼”ä¸­", 'success');
            } else if (APP.state === 'LANDING') {
                APP.state = 'LANDED';
                updateStatus("System Ready");
                setUILocked(false); 
            }
        }

        APP.cameraRadius = THREE.MathUtils.lerp(APP.cameraRadius, APP.targetRadius, 0.03);
        APP.cameraHeight = THREE.MathUtils.lerp(APP.cameraHeight, APP.targetHeight, 0.03);
        
        camera.position.x = APP.cameraRadius * Math.sin(time * 0.1); 
        camera.position.z = APP.cameraRadius * Math.cos(time * 0.1);
        
        camera.lookAt(0, APP.cameraHeight, 0);

        renderer.render(scene, camera);
    }
    animate();

    // ================= 6. Gestures (Static Pose) =================
    const videoElement = document.getElementById('drone-video');
    const canvasElement = document.getElementById('drone-mask-canvas');
    const canvasCtx = canvasElement.getContext('2d');
    
    function isFingerExtended(landmarks, tipIdx, pipIdx) {
        const wrist = landmarks[0];
        const tip = landmarks[tipIdx];
        const pip = landmarks[pipIdx]; 
        const dTip = Math.hypot(tip.x - wrist.x, tip.y - wrist.y);
        const dPip = Math.hypot(pip.x - wrist.x, pip.y - wrist.y);
        return dTip > dPip; 
    }

    function onResults(results) {
        canvasCtx.save();
        canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
        
        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
            const landmarks = results.multiHandLandmarks[0];
            drawConnectors(canvasCtx, landmarks, HAND_CONNECTIONS, {color: '#00FFFF', lineWidth: 2});
            drawLandmarks(canvasCtx, landmarks, {color: '#FF0000', lineWidth: 1, radius: 2});
            
            if (APP.gestureCooldown > 0) {
                APP.gestureCooldown--;
                canvasCtx.restore();
                return;
            }

            const indexOpen = isFingerExtended(landmarks, 8, 6);
            const middleOpen = isFingerExtended(landmarks, 12, 10);
            const ringOpen = isFingerExtended(landmarks, 16, 14);
            const pinkyOpen = isFingerExtended(landmarks, 20, 18);
            
            let detected = null;

            if (!indexOpen && !middleOpen && !ringOpen && !pinkyOpen) {
                detected = 'FIST';
            }
            else if (indexOpen && middleOpen && !ringOpen && !pinkyOpen) {
                detected = 'PEACE';
            }
            else if (indexOpen && !middleOpen && !ringOpen && !pinkyOpen) {
                detected = 'ONE';
            }
            else if (indexOpen && middleOpen && ringOpen && pinkyOpen) {
                detected = 'OPEN';
            }

            if (detected) {
                const statusText = document.getElementById('sys-status');
                
                if (!APP.config.auto) {
                    if (APP.state === 'LANDED') {
                        if (detected === 'OPEN') { 
                             switchState('TAKEOFF');
                             triggerCooldown(60);
                        }
                    } else if (APP.state === 'HOVERING') {
                        if (detected === 'PEACE') { 
                             statusText.innerText = "âœŒï¸ è¯†åˆ«: ä¸‹ä¸€å¹•";
                             switchState('NEXT');
                             triggerCooldown(40);
                        } else if (detected === 'ONE') { 
                             statusText.innerText = "â˜ï¸ è¯†åˆ«: ä¸Šä¸€å¹•";
                             switchState('PREV');
                             triggerCooldown(40);
                        } else if (detected === 'FIST') { 
                             statusText.innerText = "âœŠ è¯†åˆ«: é™è½";
                             switchState('LAND');
                             triggerCooldown(60);
                        }
                    }
                }
            }
        }
        canvasCtx.restore();
    }
    
    function triggerCooldown(frames) {
        APP.gestureCooldown = frames;
    }

    const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
    hands.setOptions({maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5});
    hands.onResults(onResults);
    
    const cameraUtils = new Camera(videoElement, {
        onFrame: async () => { await hands.send({image: videoElement}); },
        width: 320, height: 240
    });
    cameraUtils.start();

    window.addEventListener('resize', () => {
        if(!container) return;
        camera.aspect = container.clientWidth / container.clientHeight;
        camera.updateProjectionMatrix();
        renderer.setSize( container.clientWidth, container.clientHeight );
    });
})();
</script>