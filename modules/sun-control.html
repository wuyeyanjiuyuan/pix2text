<style>
    /* å®¹å™¨æ ·å¼ */
    #sun-interaction-container {
        position: relative; width: 100%; height: 600px;
        background: #000; border-radius: 12px; overflow: hidden;
        box-shadow: 0 10px 30px rgba(0,0,0,0.2);
    }
    #three-canvas { width: 100%; height: 100%; display: block; }
    
    .ui-overlay {
        position: absolute; top: 20px; left: 20px; z-index: 10;
        color: white; font-family: 'Segoe UI', sans-serif;
        text-shadow: 0 1px 3px rgba(0,0,0,0.8); pointer-events: none;
    }
    .status-badge {
        display: inline-block; padding: 6px 12px;
        background: rgba(0,0,0,0.5); border: 1px solid rgba(255,255,255,0.3);
        border-radius: 20px; backdrop-filter: blur(4px);
        font-size: 14px; margin-bottom: 10px; color: #ffd700; transition: all 0.3s;
    }
    .cam-preview {
        position: absolute; bottom: 20px; right: 20px;
        width: 120px; height: 90px; border-radius: 8px; overflow: hidden;
        border: 2px solid rgba(255,255,255,0.5); z-index: 10; background: #000;
    }
    #input-video { position: absolute; opacity: 0; pointer-events: none; }
    #output-canvas { width: 100%; height: 100%; transform: scaleX(-1); }
</style>

<div id="sun-interaction-container">
    <div class="ui-overlay">
        <div id="status-text" class="status-badge">æ­£åœ¨åˆå§‹åŒ–å¼•æ“...</div>
        <div style="font-size:12px; opacity:0.9">âœ‹ å¼ å¼€ï¼šç¼“ç¼“å‡èµ· | âœŠ æ¡æ‹³ï¼šç¼“ç¼“è½ä¸‹</div>
    </div>

    <div class="cam-preview"><canvas id="output-canvas"></canvas></div>
    <video id="input-video" playsinline></video>
    <div id="three-canvas"></div>
</div>

<script src="js/three.min.js"></script>
<script src="js/camera_utils.js"></script>
<script src="js/control_utils.js"></script>
<script src="js/drawing_utils.js"></script>
<script src="js/hands.js"></script>

<script src="js/Water.js"></script>
<script src="js/Sky.js"></script>

<script>
    const statusText = document.getElementById('status-text');

    // ç”Ÿæˆæµ·é¢çº¹ç† (æ— éœ€æ”¹åŠ¨)
    function createWaterNormalTexture() {
        const size = 512;
        const canvas = document.createElement('canvas');
        canvas.width = size; canvas.height = size;
        const ctx = canvas.getContext('2d');
        ctx.fillStyle = '#8080ff'; 
        ctx.fillRect(0, 0, size, size);
        for (let i = 0; i < 20000; i++) {
            const x = Math.random() * size;
            const y = Math.random() * size;
            const r = Math.random() * 2 + 1;
            ctx.beginPath();
            ctx.arc(x, y, r, 0, Math.PI * 2);
            ctx.fillStyle = `rgba(${128 + Math.random()*127}, ${128 + Math.random()*127}, 255, 0.5)`;
            ctx.fill();
        }
        const texture = new THREE.CanvasTexture(canvas);
        texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
        return texture;
    }

    try {
        if (!THREE.Water || !THREE.Sky) {
            throw new Error("è¯·ç¡®ä¿ js æ–‡ä»¶å¤¹å†…åŒ…å« Water.js å’Œ Sky.js");
        }

        const container = document.getElementById('three-canvas');
        const width = container.clientWidth;
        const height = container.clientHeight;

        const scene = new THREE.Scene();

        // è°ƒæ•´ç›¸æœºä½ç½®ï¼Œæ›´è´´è¿‘æµ·é¢ï¼Œå¢å¼ºæ²‰æµ¸æ„Ÿ
        const camera = new THREE.PerspectiveCamera(55, width / height, 1, 20000);
        camera.position.set(30, 30, 100);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(width, height);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.outputEncoding = THREE.sRGBEncoding;
        container.appendChild(renderer.domElement);

        // â˜… PMREM Generator (ç›´æ¥ä» THREE æ ¸å¿ƒåº“è°ƒç”¨ï¼Œæ— éœ€å•ç‹¬æ–‡ä»¶)
        const pmremGenerator = new THREE.PMREMGenerator(renderer);
        pmremGenerator.compileEquirectangularShader();

        // --- åˆ›å»ºæµ·æ´‹ ---
        const waterGeometry = new THREE.PlaneGeometry(10000, 10000);
        const water = new THREE.Water(
            waterGeometry,
            {
                textureWidth: 512,
                textureHeight: 512,
                waterNormals: createWaterNormalTexture(),
                sunDirection: new THREE.Vector3(),
                sunColor: 0xffffff,
                waterColor: 0x001e0f,
                distortionScale: 3.7,
                fog: scene.fog !== undefined
            }
        );
        water.rotation.x = - Math.PI / 2;
        scene.add(water);

        // --- åˆ›å»ºå¤©ç©º ---
        const sky = new THREE.Sky();
        sky.scale.setScalar(10000);
        scene.add(sky);

        const skyUniforms = sky.material.uniforms;
        skyUniforms['turbidity'].value = 10;
        skyUniforms['rayleigh'].value = 2;
        skyUniforms['mieCoefficient'].value = 0.005; 
        skyUniforms['mieDirectionalG'].value = 0.8;

        const sun = new THREE.Vector3();

        // å¤ªé˜³çƒä½“
        const sunSphere = new THREE.Mesh(
            new THREE.SphereGeometry(200, 32, 32),
            new THREE.MeshBasicMaterial({ color: 0xffffaa })
        );
        scene.add(sunSphere);

        // ================= 2. é€»è¾‘æ§åˆ¶ =================

        let elevation = 0; 
        let moveState = 0; 
        
        // â˜…â˜…â˜… é€Ÿåº¦æ§åˆ¶åŒºåŸŸ â˜…â˜…â˜…
        // 0.003 -> 0.0005 (å˜æ…¢äº†6å€ï¼Œéå¸¸ä¸æ»‘)
        const SPEED = 0.0005; 

        function updateSunPosition() {
            if (moveState !== 0) {
                elevation += moveState * SPEED;
                // é™åˆ¶æœ€é«˜å’Œæœ€ä½ç‚¹
                if (elevation > 0.4) elevation = 0.4; 
                if (elevation < -0.05) elevation = -0.05; 
            }

            const phi = THREE.MathUtils.degToRad(90 - (elevation * 180)); 
            const theta = THREE.MathUtils.degToRad(180); 

            sun.setFromSphericalCoords(1, phi, theta);

            sky.material.uniforms['sunPosition'].value.copy(sun);
            water.material.uniforms['sunDirection'].value.copy(sun).normalize();
            sunSphere.position.copy(sun).multiplyScalar(4000); 
            
            const sunColor = new THREE.Color(0xff0000).lerp(new THREE.Color(0xffffeb), (elevation + 0.05) * 2.5);
            sunSphere.material.color.copy(sunColor);

            // å®æ—¶è®¡ç®—ç¯å¢ƒå…‰åå°„ï¼ˆè¿™ä¸€æ­¥æœ€è€—æ€§èƒ½ï¼Œä½†æ•ˆæœæœ€çœŸï¼‰
            scene.environment = pmremGenerator.fromScene(sky).texture;
        }

        function animate() {
            requestAnimationFrame(animate);
            water.material.uniforms[ 'time' ].value += 1.0 / 60.0;
            updateSunPosition();
            renderer.render(scene, camera);
        }
        animate();

        // ================= 3. AI æ‰‹åŠ¿è¯†åˆ« =================
        
        const videoElement = document.getElementById('input-video');
        const canvasElement = document.getElementById('output-canvas');
        const canvasCtx = canvasElement.getContext('2d');

        function onResults(results) {
            statusText.innerText = "ç³»ç»Ÿè¿è¡Œä¸­ï¼Œè¯·å±•ç¤ºæ‰‹åŠ¿";
            statusText.style.color = "yellow";
            
            canvasCtx.save();
            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
            canvasCtx.drawImage(results.image, 0, 0, canvasElement.width, canvasElement.height);

            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const landmarks = results.multiHandLandmarks[0];
                drawConnectors(canvasCtx, landmarks, HAND_CONNECTIONS, {color: '#00FF00', lineWidth: 2});
                drawLandmarks(canvasCtx, landmarks, {color: '#FF0000', lineWidth: 1, radius: 2});

                const wrist = landmarks[0];
                const middleTip = landmarks[12];
                const dist = Math.sqrt(Math.pow(middleTip.x - wrist.x, 2) + Math.pow(middleTip.y - wrist.y, 2));

                if (dist > 0.32) {
                    moveState = 1; 
                    statusText.innerText = "çŠ¶æ€ï¼šğŸ–ï¸ æ—¥å‡º (ç¼“ç¼“å‡èµ·)";
                    statusText.style.color = "#00ff00";
                } else if (dist < 0.22) {
                    moveState = -1; 
                    statusText.innerText = "çŠ¶æ€ï¼šâœŠ æ—¥è½ (ç¼“ç¼“è½ä¸‹)";
                    statusText.style.color = "#ff4400";
                } else {
                    moveState = 0; 
                    statusText.innerText = "çŠ¶æ€ï¼šâœ‹ æ‚¬åœ (ä¿æŒå½“å‰é«˜åº¦)";
                    statusText.style.color = "white";
                }
            } else {
                moveState = 0;
            }
            canvasCtx.restore();
        }

        const hands = new Hands({locateFile: (file) => {
            return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
        }});

        hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 1,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });

        hands.onResults(onResults);

        statusText.innerText = "æ­£åœ¨å¯åŠ¨æ‘„åƒå¤´...";
        const cameraUtils = new Camera(videoElement, {
            onFrame: async () => { await hands.send({image: videoElement}); },
            width: 320,
            height: 240
        });
        
        cameraUtils.start();

        window.addEventListener('resize', () => {
            if(!container) return;
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize( container.clientWidth, container.clientHeight );
        });

    } catch (e) {
        statusText.innerText = "âŒ åˆå§‹åŒ–é”™è¯¯: " + e.message;
        statusText.style.color = "red";
        console.error(e);
    }
</script>