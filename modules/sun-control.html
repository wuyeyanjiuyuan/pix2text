<style>
    #sun-interaction-container {
        position: relative;
        width: 100%;
        height: 600px;
        background: #000;
        border-radius: 12px;
        overflow: hidden;
        box-shadow: 0 10px 30px rgba(0,0,0,0.2);
    }
    #three-canvas { width: 100%; height: 100%; display: block; }
    
    /* UI æ ·å¼ */
    .ui-overlay {
        position: absolute; top: 20px; left: 20px; z-index: 10;
        color: white; font-family: 'Segoe UI', sans-serif;
        text-shadow: 0 1px 3px rgba(0,0,0,0.8);
        pointer-events: none;
    }
    .status-badge {
        display: inline-block; padding: 6px 12px;
        background: rgba(0,0,0,0.5); border: 1px solid rgba(255,255,255,0.3);
        border-radius: 20px; backdrop-filter: blur(4px);
        font-size: 14px; margin-bottom: 10px;
        color: #ffd700; transition: all 0.3s;
    }
    
    .cam-preview {
        position: absolute; bottom: 20px; right: 20px;
        width: 120px; height: 90px; border-radius: 8px; overflow: hidden;
        border: 2px solid rgba(255,255,255,0.5); z-index: 10; background: #000;
    }
    #input-video { position: absolute; opacity: 0; pointer-events: none; }
    #output-canvas { width: 100%; height: 100%; transform: scaleX(-1); }
</style>

<div id="sun-interaction-container">
    <div class="ui-overlay">
        <div id="status-text" class="status-badge">æ­£åœ¨åˆå§‹åŒ–çœŸå®æµ·æ´‹å¼•æ“...</div>
        <div style="font-size:12px; opacity:0.9">âœ‹ å¼ å¼€ï¼šæ—¥å‡º (æµ·é¢æ³¢å…‰) | âœŠ æ¡æ‹³ï¼šæ—¥è½ (æ™šéœ)</div>
    </div>

    <div class="cam-preview"><canvas id="output-canvas"></canvas></div>
    <video id="input-video" playsinline></video>
    <div id="three-canvas"></div>
</div>

<script src="js/three.min.js"></script>
<script src="js/camera_utils.js"></script>
<script src="js/control_utils.js"></script>
<script src="js/drawing_utils.js"></script>
<script src="js/hands.js"></script>
<script src="js/objects/Water.js"></script>
<script src="js/objects/Sky.js"></script>

<script>
    // ================= 1. 3D åœºæ™¯åˆå§‹åŒ– (çœŸå®æµ·æ´‹ç‰ˆ) =================
    const container = document.getElementById('three-canvas');
    const width = container.clientWidth;
    const height = container.clientHeight;

    const scene = new THREE.Scene();

    // ç›¸æœºä½ç½®ï¼šæ”¾ä½ä¸€ç‚¹ï¼Œè¥é€ â€œç«™åœ¨æµ·è¾¹â€çš„æ„Ÿè§‰
    const camera = new THREE.PerspectiveCamera(55, width / height, 1, 20000);
    camera.position.set(30, 30, 100);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(width, height);
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.toneMapping = THREE.ACESFilmicToneMapping; // å¼€å¯ç”µå½±çº§è‰²è°ƒæ˜ å°„
    container.appendChild(renderer.domElement);

    // --- A. å¤ªé˜³ (çœ‹ä¸è§çš„æ•°å­¦å¤ªé˜³) ---
    // æˆ‘ä»¬éœ€è¦ä¸€ä¸ªå‘é‡æ¥ä»£è¡¨å¤ªé˜³çš„ä½ç½®ï¼Œä¼ ç»™ Sky å’Œ Water shader
    const sun = new THREE.Vector3();

    // --- B. åˆ›å»ºæµ·æ´‹ (Water) ---
    const waterGeometry = new THREE.PlaneGeometry(10000, 10000);

    const water = new THREE.Water(
        waterGeometry,
        {
            textureWidth: 512,
            textureHeight: 512,
            waterNormals: new THREE.TextureLoader().load('https://raw.githubusercontent.com/mrdoob/three.js/master/examples/textures/water/waternormals.jpg', function ( texture ) {
                texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
            }),
            sunDirection: new THREE.Vector3(),
            sunColor: 0xffffff,
            waterColor: 0x001e0f, // æ·±æµ·è“ç»¿è‰²
            distortionScale: 3.7, // æ³¢æµªå¤§å°
            fog: scene.fog !== undefined
        }
    );
    water.rotation.x = - Math.PI / 2;
    scene.add(water);

    // --- C. åˆ›å»ºå¤©ç©º (Sky) ---
    const sky = new THREE.Sky();
    sky.scale.setScalar(10000);
    scene.add(sky);

    const skyUniforms = sky.material.uniforms;
    skyUniforms['turbidity'].value = 10;   // æµ‘æµŠåº¦
    skyUniforms['rayleigh'].value = 2;     // ç‘åˆ©æ•£å°„ (æ§åˆ¶å¤©ç©ºé¢œè‰²)
    skyUniforms['mieCoefficient'].value = 0.005; 
    skyUniforms['mieDirectionalG'].value = 0.8;

    // --- D. å¯è§†åŒ–çš„å¤ªé˜³çƒä½“ (ä¸ºäº†è®©ä½ è‚‰çœ¼çœ‹åˆ°é‚£ä¸ªçƒ) ---
    // è™½ç„¶ Sky Shader ä¼šè‡ªå¸¦ä¸€ä¸ªå‘å…‰çš„å¤ªé˜³ç›˜ï¼Œä½†ä¸ºäº†é…åˆä½ çš„æ‰‹åŠ¿æ“ä½œæ„Ÿï¼Œ
    // æˆ‘ä»¬åŠ ä¸€ä¸ªå‘å…‰çš„çƒä½“å åœ¨é‚£ä¸ªä½ç½®
    const sunSphereGeo = new THREE.SphereGeometry(200, 32, 32); // å¾ˆå¤§å¾ˆè¿œ
    const sunSphereMat = new THREE.MeshBasicMaterial({ color: 0xffffaa });
    const sunSphere = new THREE.Mesh(sunSphereGeo, sunSphereMat);
    scene.add(sunSphere);

    // ================= 2. é€»è¾‘æ§åˆ¶ =================

    // å¤ªé˜³é«˜åº¦æ§åˆ¶å˜é‡
    // 0 = åœ°å¹³çº¿, 0.5 = æ­£åˆ(90åº¦), -0.05 = åˆšè½ä¸‹
    let elevation = 0; // åˆå§‹åœ¨åœ°å¹³çº¿
    let moveState = 0; // 0=åœ, 1=å‡, -1=é™
    const SPEED = 0.003; // å¤ªé˜³è§’åº¦å˜åŒ–é€Ÿåº¦ (å¼§åº¦)

    function updateSunPosition() {
        // å¢é‡æ§åˆ¶
        if (moveState !== 0) {
            elevation += moveState * SPEED;
            // é™åˆ¶èŒƒå›´ï¼š-2åº¦åˆ° 45åº¦
            if (elevation > 0.4) elevation = 0.4; // æœ€é«˜å‡åˆ°çº¦45åº¦è§’
            if (elevation < -0.05) elevation = -0.05; // æœ€ä½è½åˆ°æµ·å¹³é¢ä¸‹ä¸€ç‚¹ç‚¹
        }

        // --- æ ¸å¿ƒæ•°å­¦è®¡ç®—ï¼šæŠŠè§’åº¦å˜æˆ XYZ åæ ‡ ---
        const phi = THREE.MathUtils.degToRad(90 - (elevation * 180)); // ä»°è§’
        const theta = THREE.MathUtils.degToRad(180); // æ–¹ä½è§’ (æ­£å—æ–¹)

        // 1. æ›´æ–°æ•°å­¦å¤ªé˜³åæ ‡
        sun.setFromSphericalCoords(1, phi, theta);

        // 2. ä¼ ç»™ Sky Shader (å¤©ç©ºå˜è‰²)
        sky.material.uniforms['sunPosition'].value.copy(sun);

        // 3. ä¼ ç»™ Water Shader (æµ·é¢åå…‰)
        water.material.uniforms['sunDirection'].value.copy(sun).normalize();

        // 4. æ›´æ–°å¯è§†åŒ–çš„å¤ªé˜³çƒä½“ä½ç½® (å®ƒåœ¨å¾ˆè¿œçš„åœ°æ–¹)
        sunSphere.position.copy(sun).multiplyScalar(4000); // æ”¾åœ¨4000ç±³å¤–
        
        // 5. æ ¹æ®é«˜åº¦æ”¹å˜å¤ªé˜³çƒçš„é¢œè‰² (çº¢ -> é»„)
        const sunColor = new THREE.Color(0xff0000).lerp(new THREE.Color(0xffffeb), (elevation + 0.05) * 2.5);
        sunSphere.material.color.copy(sunColor);
    }

    function animate() {
        requestAnimationFrame(animate);

        // è®©æµ·æ°´æµåŠ¨
        water.material.uniforms[ 'time' ].value += 1.0 / 60.0;

        updateSunPosition();
        renderer.render(scene, camera);
    }
    animate();

    // ================= 3. AI æ‰‹åŠ¿è¯†åˆ« (å¸¦å®æ™¯é¢„è§ˆ) =================
    
    const videoElement = document.getElementById('input-video');
    const canvasElement = document.getElementById('output-canvas');
    const canvasCtx = canvasElement.getContext('2d');
    const statusText = document.getElementById('status-text');

    function onResults(results) {
        statusText.classList.remove('loading');
        
        canvasCtx.save();
        canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
        // ç»˜åˆ¶å®æ™¯
        canvasCtx.drawImage(results.image, 0, 0, canvasElement.width, canvasElement.height);

        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
            const landmarks = results.multiHandLandmarks[0];
            
            drawConnectors(canvasCtx, landmarks, HAND_CONNECTIONS, {color: '#00FF00', lineWidth: 2});
            drawLandmarks(canvasCtx, landmarks, {color: '#FF0000', lineWidth: 1, radius: 2});

            // ç®€å•çš„å¼ åˆè®¡ç®—
            const wrist = landmarks[0];
            const middleTip = landmarks[12];
            const dist = Math.sqrt(Math.pow(middleTip.x - wrist.x, 2) + Math.pow(middleTip.y - wrist.y, 2));

            if (dist > 0.32) {
                moveState = 1; // å‡
                statusText.innerText = "çŠ¶æ€ï¼šğŸ–ï¸ æ—¥å‡º (æµ·é¢æ³¢å…‰æµ®ç°)";
                statusText.style.color = "#00ff00";
            } else if (dist < 0.22) {
                moveState = -1; // é™
                statusText.innerText = "çŠ¶æ€ï¼šâœŠ æ—¥è½ (æ­£åœ¨è¿›å…¥é»„æ˜)";
                statusText.style.color = "#ff4400";
            } else {
                moveState = 0; // åœ
                statusText.innerText = "çŠ¶æ€ï¼šâœ‹ æ‚¬åœ (æ¬£èµå½“å‰ç¾æ™¯)";
                statusText.style.color = "yellow";
            }
        } else {
            moveState = 0;
            statusText.innerText = "æœªæ£€æµ‹åˆ°æ‰‹åŠ¿ï¼Œè¯·ä¼¸æ‰‹";
            statusText.style.color = "white";
        }
        canvasCtx.restore();
    }

    const hands = new Hands({locateFile: (file) => {
        return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
    }});

    hands.setOptions({
        maxNumHands: 1,
        modelComplexity: 1,
        minDetectionConfidence: 0.5,
        minTrackingConfidence: 0.5
    });

    hands.onResults(onResults);

    const cameraUtils = new Camera(videoElement, {
        onFrame: async () => { await hands.send({image: videoElement}); },
        width: 320,
        height: 240
    });
    
    cameraUtils.start();

    // çª—å£å¤§å°æ”¹å˜æ—¶è‡ªé€‚åº”
    window.addEventListener('resize', onWindowResize, false);
    function onWindowResize() {
        if(!container) return;
        camera.aspect = container.clientWidth / container.clientHeight;
        camera.updateProjectionMatrix();
        renderer.setSize( container.clientWidth, container.clientHeight );
    }

</script>