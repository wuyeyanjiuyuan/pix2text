<style>
    /* å®¹å™¨æ ·å¼ */
    #sun-interaction-container {
        position: relative; width: 100%; height: 600px;
        background: #000; border-radius: 12px; overflow: hidden;
        box-shadow: 0 10px 30px rgba(0,0,0,0.2);
    }
    #three-canvas { width: 100%; height: 100%; display: block; }
    
    .ui-overlay {
        position: absolute; top: 20px; left: 20px; z-index: 10;
        color: white; font-family: 'Segoe UI', sans-serif;
        text-shadow: 0 1px 3px rgba(0,0,0,0.8); pointer-events: none;
    }
    .status-badge {
        display: inline-block; padding: 6px 12px;
        background: rgba(0,0,0,0.5); border: 1px solid rgba(255,255,255,0.3);
        border-radius: 20px; backdrop-filter: blur(4px);
        font-size: 14px; margin-bottom: 10px; color: #ffd700; transition: all 0.3s;
    }
    .cam-preview {
        position: absolute; bottom: 20px; right: 20px;
        width: 120px; height: 90px; border-radius: 8px; overflow: hidden;
        border: 2px solid rgba(255,255,255,0.5); z-index: 10; background: #000;
    }
    #input-video { position: absolute; opacity: 0; pointer-events: none; }
    #output-canvas { width: 100%; height: 100%; transform: scaleX(-1); }
</style>

<div id="sun-interaction-container">
    <div class="ui-overlay">
        <div id="status-text" class="status-badge">æ­£åœ¨åˆå§‹åŒ–æ˜Ÿç©ºå¼•æ“...</div>
        <div style="font-size:12px; opacity:0.9">âœ‹ å¼ å¼€ï¼šæ—¥å‡º (é‡‘å…‰) | âœŠ æ¡æ‹³ï¼šå…¥å¤œ (æ˜Ÿæ²³)</div>
    </div>
    <div class="cam-preview"><canvas id="output-canvas"></canvas></div>
    <video id="input-video" playsinline></video>
    <div id="three-canvas"></div>
</div>

<script src="js/three.min.js"></script>
<script src="js/camera_utils.js"></script>
<script src="js/control_utils.js"></script>
<script src="js/drawing_utils.js"></script>
<script src="js/hands.js"></script>
<script src="js/Water.js"></script>
<script src="js/Sky.js"></script>

<script>
    const statusText = document.getElementById('status-text');

    // 1. æµ·é¢çº¹ç†
    function createWaterNormalTexture() {
        const size = 512;
        const canvas = document.createElement('canvas');
        canvas.width = size; canvas.height = size;
        const ctx = canvas.getContext('2d');
        ctx.fillStyle = '#8080ff'; 
        ctx.fillRect(0, 0, size, size);
        for (let i = 0; i < 20000; i++) {
            const x = Math.random() * size;
            const y = Math.random() * size;
            const r = Math.random() * 2 + 1;
            ctx.beginPath();
            ctx.arc(x, y, r, 0, Math.PI * 2);
            ctx.fillStyle = `rgba(${128 + Math.random()*127}, ${128 + Math.random()*127}, 255, 0.5)`;
            ctx.fill();
        }
        const texture = new THREE.CanvasTexture(canvas);
        texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
        return texture;
    }

    // 2. å…‰æ™•çº¹ç†
    function createGlowTexture() {
        const canvas = document.createElement('canvas');
        canvas.width = 128; canvas.height = 128;
        const ctx = canvas.getContext('2d');
        const gradient = ctx.createRadialGradient(64,64,0, 64,64,64);
        gradient.addColorStop(0, 'rgba(255, 255, 255, 1)'); 
        gradient.addColorStop(0.2, 'rgba(255, 255, 255, 0.8)'); 
        gradient.addColorStop(0.5, 'rgba(255, 255, 255, 0.2)'); 
        gradient.addColorStop(1, 'rgba(0, 0, 0, 0)'); 
        ctx.fillStyle = gradient;
        ctx.fillRect(0,0,128,128);
        return new THREE.CanvasTexture(canvas);
    }

    try {
        if (!THREE.Water || !THREE.Sky) {
            throw new Error("è¯·ç¡®ä¿ js æ–‡ä»¶å¤¹å†…åŒ…å« Water.js å’Œ Sky.js");
        }

        const container = document.getElementById('three-canvas');
        const width = container.clientWidth;
        const height = container.clientHeight;

        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000000, 0.0005); 

        const camera = new THREE.PerspectiveCamera(55, width / height, 1, 20000);
        camera.position.set(30, 30, 100);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(width, height);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.outputEncoding = THREE.sRGBEncoding;
        renderer.toneMappingExposure = 0.5; 
        container.appendChild(renderer.domElement);

        const pmremGenerator = new THREE.PMREMGenerator(renderer);
        pmremGenerator.compileEquirectangularShader();

        // --- æµ·æ´‹ ---
        const waterGeometry = new THREE.PlaneGeometry(10000, 10000);
        const water = new THREE.Water(
            waterGeometry,
            {
                textureWidth: 512,
                textureHeight: 512,
                waterNormals: createWaterNormalTexture(),
                sunDirection: new THREE.Vector3(),
                sunColor: 0xffffff,
                waterColor: 0x001e0f,
                distortionScale: 3.7,
                fog: scene.fog !== undefined
            }
        );
        water.rotation.x = - Math.PI / 2;
        scene.add(water);

        // --- å¤©ç©º ---
        const sky = new THREE.Sky();
        sky.scale.setScalar(10000);
        scene.add(sky);
        const skyUniforms = sky.material.uniforms;
        skyUniforms['mieCoefficient'].value = 0.005; 
        skyUniforms['mieDirectionalG'].value = 0.8;

        const sun = new THREE.Vector3();

        // --- å¤ªé˜³æœ¬ä½“ ---
        const sunGeometry = new THREE.SphereGeometry(60, 32, 32); 
        // å°è¯•ä¿®å¤å˜é»‘ï¼šä½¿ç”¨æé«˜çš„äº®åº¦å€¼æ¥æŠµæŠ— ToneMapping
        const sunMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff, fog: false, toneMapped: false });
        const sunSphere = new THREE.Mesh(sunGeometry, sunMaterial);
        scene.add(sunSphere);

        // --- å¤ªé˜³å…‰æ™• ---
        const glowMaterial = new THREE.SpriteMaterial({ 
            map: createGlowTexture(), 
            color: 0xff4400, 
            transparent: true, 
            blending: THREE.AdditiveBlending,
            depthWrite: false,
            fog: false,
            toneMapped: false
        });
        const sunGlow = new THREE.Sprite(glowMaterial);
        sunGlow.scale.set(300, 300, 1); 
        scene.add(sunGlow);

        // --- â˜…â˜…â˜… æ–°å¢ï¼šæ˜Ÿç©ºç³»ç»Ÿ â˜…â˜…â˜… ---
        const starsGeometry = new THREE.BufferGeometry();
        const starsCount = 5000; // æ˜Ÿæ˜Ÿæ•°é‡
        const posArray = new Float32Array(starsCount * 3);
        
        for(let i = 0; i < starsCount * 3; i++) {
            // åœ¨å¤§èŒƒå›´å†…éšæœºåˆ†å¸ƒ
            posArray[i] = (Math.random() - 0.5) * 8000; 
        }
        starsGeometry.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
        
        const starsMaterial = new THREE.PointsMaterial({
            size: 8, // æ˜Ÿæ˜Ÿå¤§å°
            color: 0xffffff,
            transparent: true,
            opacity: 0, // åˆå§‹éšè—
            fog: false
        });
        const stars = new THREE.Points(starsGeometry, starsMaterial);
        scene.add(stars);

        // ================= é€»è¾‘æ§åˆ¶ =================

        let elevation = 0.0; 
        let moveState = 0; 
        const SPEED = 0.0005; 

        // é˜¶æ®µå®šä¹‰
        const H_NIGHT_DEEP = -0.20; // æ·±å¤œ (æ˜Ÿæ˜Ÿå…¨äº®)
        const H_HORIZON = -0.02;    // åœ°å¹³çº¿ (æ—¥è½å¼€å§‹)
        const H_HALF = 0.04;        // åŠä¸ªå¤ªé˜³
        const H_FULL = 0.10;        // ä¸€ä¸ªå¤ªé˜³
        const H_MAX = 0.40;         // æœ€é«˜ç‚¹

        // ç”¨äºæ¨¡æ‹Ÿæœˆå…‰çš„è™šæ‹Ÿå‘é‡
        const moonPosition = new THREE.Vector3(-100, 50, -100).normalize(); 

        function updateSunPosition() {
            if (moveState !== 0) {
                elevation += moveState * SPEED;
                if (elevation > H_MAX) elevation = H_MAX; 
                // â˜… å…è®¸ä¸‹é™åˆ°æ›´æ·±çš„åœ°æ–¹ï¼Œæ¨¡æ‹Ÿé»‘å¤œ
                if (elevation < H_NIGHT_DEEP) elevation = H_NIGHT_DEEP; 
            }

            const phi = THREE.MathUtils.degToRad(90 - (elevation * 180)); 
            const theta = THREE.MathUtils.degToRad(180); 
            sun.setFromSphericalCoords(1, phi, theta);

            // æ›´æ–°å¤©ç©º (Sky)
            sky.material.uniforms['sunPosition'].value.copy(sun);

            // å¤ªé˜³ä½ç½®
            const sunPos = sun.clone().multiplyScalar(4000);
            sunSphere.position.copy(sunPos);
            sunGlow.position.copy(sunPos);

            // ================== å¤šé˜¶æ®µé€»è¾‘ ==================

            let targetScale = 300;
            let targetGlowColor = new THREE.Color(0xff4400); 
            let targetTurbidity = 20; 
            let targetRayleigh = 4;
            let starOpacity = 0;
            
            // é¢œè‰²å®šä¹‰
            const colOrange = new THREE.Color(0xff2200); 
            const colGold = new THREE.Color(0xffcc00);   
            const colWhite = new THREE.Color(0xffffee); 

            // â˜… é˜¶æ®µ 0: é»‘å¤œ (-0.2 ~ -0.02)
            if (elevation < H_HORIZON) {
                // è®¡ç®—é»‘å¤œæ·±åº¦è¿›åº¦ (0=åˆšæ—¥è½, 1=æ·±é»‘)
                const nightProgress = (H_HORIZON - elevation) / (H_HORIZON - H_NIGHT_DEEP);
                
                // æ˜Ÿæ˜Ÿæ¸æ¸æµ®ç°
                starOpacity = Math.min(1, nightProgress * 1.5);
                
                // å¤ªé˜³å’Œå…‰æ™•æ·¡å‡º
                sunSphere.visible = false; // è—èµ·æ¥
                sunGlow.visible = true;
                sunGlow.material.opacity = 1.0 - nightProgress; // å…‰æ™•æ…¢æ…¢æ¶ˆå¤±
                targetGlowColor.copy(colOrange);
                
                // â˜…â˜…â˜… æ ¸å¿ƒï¼šæµ·é¢å…‰æºåˆ‡æ¢ â˜…â˜…â˜…
                // å½“å®Œå…¨å…¥å¤œåï¼Œæˆ‘ä»¬å°†ä¼ ç»™æµ·é¢çš„å…‰æºæ¢æˆâ€œæœˆå…‰â€
                // è¿™æ ·æµ·é¢ä¼šæ³›èµ·å†·å†·çš„å…‰ï¼Œè€Œä¸æ˜¯æ­»é»‘
                if (nightProgress > 0.5) {
                    // æ¨¡æ‹Ÿæœˆå…‰/æ˜Ÿå…‰
                    water.material.uniforms['sunDirection'].value.copy(moonPosition);
                    water.material.uniforms['sunColor'].value.setHex(0x8888ff); // é“¶è“è‰²å†·å…‰
                } else {
                    // ä½™æ™–
                    water.material.uniforms['sunDirection'].value.copy(sun).normalize();
                    water.material.uniforms['sunColor'].value.setHex(0xffffff); 
                }

            } else {
                // ç™½å¤©æ¨¡å¼ï¼šç¡®ä¿å¤ªé˜³æ˜¾ç¤ºï¼Œæ˜Ÿæ˜Ÿéšè—
                sunSphere.visible = true;
                sunGlow.visible = true;
                sunGlow.material.opacity = 1;
                starOpacity = 0;
                
                // æ¢å¤æµ·é¢ä¸ºå¤ªé˜³å…‰
                water.material.uniforms['sunDirection'].value.copy(sun).normalize();
                water.material.uniforms['sunColor'].value.setHex(0xffffff); // æš–ç™½å…‰

                // â˜… é˜¶æ®µ 1: åˆšå‡ºæµ·é¢ (ä¿æŒæ©˜çº¢)
                if (elevation <= H_HALF) {
                    targetScale = 300;
                    targetGlowColor.copy(colOrange);
                    targetTurbidity = 20; targetRayleigh = 4;
                } 
                // â˜… é˜¶æ®µ 2: æ¸å˜ (æ©˜çº¢->é‡‘)
                else if (elevation <= H_FULL) {
                    const t = (elevation - H_HALF) / (H_FULL - H_HALF);
                    targetScale = THREE.MathUtils.lerp(300, 600, t);
                    targetGlowColor.copy(colOrange).lerp(colGold, t);
                    targetTurbidity = THREE.MathUtils.lerp(20, 10, t);
                    targetRayleigh = THREE.MathUtils.lerp(4, 2.5, t);
                } 
                // â˜… é˜¶æ®µ 3: ç™½å¤© (é‡‘->ç™½)
                else {
                    const t = (elevation - H_FULL) / (H_MAX - H_FULL);
                    targetScale = THREE.MathUtils.lerp(600, 800, t);
                    targetGlowColor.copy(colGold).lerp(colWhite, t);
                    targetTurbidity = THREE.MathUtils.lerp(10, 2, t);
                    targetRayleigh = THREE.MathUtils.lerp(2.5, 1, t);
                }
            }

            // åº”ç”¨æ˜Ÿæ˜Ÿé€æ˜åº¦
            stars.material.opacity = starOpacity;
            
            // åº”ç”¨å…‰æ™•
            sunGlow.scale.set(targetScale, targetScale, 1);
            sunGlow.material.color.copy(targetGlowColor);

            // æš´åŠ›ä¿®å¤å¤ªé˜³äº®åº¦
            sunSphere.material.color.setScalar(2.0); // å¼ºåº¦ç¿»å€

            sky.material.uniforms['turbidity'].value = targetTurbidity;
            sky.material.uniforms['rayleigh'].value = targetRayleigh;

            scene.environment = pmremGenerator.fromScene(sky).texture;
        }

        function animate() {
            requestAnimationFrame(animate);
            water.material.uniforms[ 'time' ].value += 1.0 / 60.0;
            updateSunPosition();
            renderer.render(scene, camera);
        }
        animate();

        // ================= æ‰‹åŠ¿è¯†åˆ« =================
        const videoElement = document.getElementById('input-video');
        const canvasElement = document.getElementById('output-canvas');
        const canvasCtx = canvasElement.getContext('2d');

        function onResults(results) {
            statusText.innerText = "ç³»ç»Ÿè¿è¡Œä¸­";
            statusText.style.color = "yellow";
            
            canvasCtx.save();
            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
            canvasCtx.drawImage(results.image, 0, 0, canvasElement.width, canvasElement.height);

            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const landmarks = results.multiHandLandmarks[0];
                drawConnectors(canvasCtx, landmarks, HAND_CONNECTIONS, {color: '#00FF00', lineWidth: 2});
                drawLandmarks(canvasCtx, landmarks, {color: '#FF0000', lineWidth: 1, radius: 2});

                const wrist = landmarks[0];
                const middleTip = landmarks[12];
                const dist = Math.sqrt(Math.pow(middleTip.x - wrist.x, 2) + Math.pow(middleTip.y - wrist.y, 2));

                if (dist > 0.32) {
                    moveState = 1; 
                    statusText.innerText = "çŠ¶æ€ï¼šğŸ–ï¸ æ—­æ—¥ä¸œå‡";
                    statusText.style.color = "#00ff00";
                } else if (dist < 0.22) {
                    moveState = -1; 
                    statusText.innerText = "çŠ¶æ€ï¼šâœŠ å…¥å¤œæ˜Ÿæ²³";
                    statusText.style.color = "#55aaff"; // è“è‰²æç¤º
                } else {
                    moveState = 0; 
                    statusText.innerText = "çŠ¶æ€ï¼šâœ‹ æ‚¬åœ";
                    statusText.style.color = "white";
                }
            } else {
                moveState = 0;
            }
            canvasCtx.restore();
        }

        const hands = new Hands({locateFile: (file) => {
            return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
        }});
        hands.setOptions({maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5});
        hands.onResults(onResults);
        
        const cameraUtils = new Camera(videoElement, {
            onFrame: async () => { await hands.send({image: videoElement}); },
            width: 320, height: 240
        });
        cameraUtils.start();

        window.addEventListener('resize', () => {
            if(!container) return;
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize( container.clientWidth, container.clientHeight );
        });

    } catch (e) {
        statusText.innerText = "âŒ åˆå§‹åŒ–é”™è¯¯: " + e.message;
        statusText.style.color = "red";
        console.error(e);
    }
</script>